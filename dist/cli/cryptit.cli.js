#!/usr/bin/env node
import{createRequire as $J}from"node:module";var a$=Object.create;var{getPrototypeOf:t$,defineProperty:CU,getOwnPropertyNames:e$}=Object;var UJ=Object.prototype.hasOwnProperty;var x0=(U,$,J)=>{J=U!=null?a$(t$(U)):{};let Q=$||!U||!U.__esModule?CU(J,"default",{value:U,enumerable:!0}):J;for(let Y of e$(U))if(!UJ.call(Q,Y))CU(Q,Y,{get:()=>U[Y],enumerable:!0});return Q};var r=(U,$)=>()=>($||U(($={exports:{}}).exports,$),$.exports);var h=$J(import.meta.url);var _0=r((JJ)=>{class UU extends Error{constructor(U,$,J){super(J);Error.captureStackTrace(this,this.constructor),this.name=this.constructor.name,this.code=$,this.exitCode=U,this.nestedError=void 0}}class kU extends UU{constructor(U){super(1,"commander.invalidArgument",U);Error.captureStackTrace(this,this.constructor),this.name=this.constructor.name}}JJ.CommanderError=UU;JJ.InvalidArgumentError=kU});var h0=r((XJ)=>{var{InvalidArgumentError:ZJ}=_0();class vU{constructor(U,$){switch(this.description=$||"",this.variadic=!1,this.parseArg=void 0,this.defaultValue=void 0,this.defaultValueDescription=void 0,this.argChoices=void 0,U[0]){case"<":this.required=!0,this._name=U.slice(1,-1);break;case"[":this.required=!1,this._name=U.slice(1,-1);break;default:this.required=!0,this._name=U;break}if(this._name.length>3&&this._name.slice(-3)==="...")this.variadic=!0,this._name=this._name.slice(0,-3)}name(){return this._name}_concatValue(U,$){if($===this.defaultValue||!Array.isArray($))return[U];return $.concat(U)}default(U,$){return this.defaultValue=U,this.defaultValueDescription=$,this}argParser(U){return this.parseArg=U,this}choices(U){return this.argChoices=U.slice(),this.parseArg=($,J)=>{if(!this.argChoices.includes($))throw new ZJ(`Allowed choices are ${this.argChoices.join(", ")}.`);if(this.variadic)return this._concatValue($,J);return $},this}argRequired(){return this.required=!0,this}argOptional(){return this.required=!1,this}}function GJ(U){let $=U.name()+(U.variadic===!0?"...":"");return U.required?"<"+$+">":"["+$+"]"}XJ.Argument=vU;XJ.humanReadableArgName=GJ});var $U=r((TJ)=>{var{humanReadableArgName:zJ}=h0();class yU{constructor(){this.helpWidth=void 0,this.sortSubcommands=!1,this.sortOptions=!1,this.showGlobalOptions=!1}visibleCommands(U){let $=U.commands.filter((J)=>!J._hidden);if(U._hasImplicitHelpCommand()){let[,J,Q]=U._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/),Y=U.createCommand(J).helpOption(!1);if(Y.description(U._helpCommandDescription),Q)Y.arguments(Q);$.push(Y)}if(this.sortSubcommands)$.sort((J,Q)=>{return J.name().localeCompare(Q.name())});return $}compareOptions(U,$){let J=(Q)=>{return Q.short?Q.short.replace(/^-/,""):Q.long.replace(/^--/,"")};return J(U).localeCompare(J($))}visibleOptions(U){let $=U.options.filter((Y)=>!Y.hidden),J=U._hasHelpOption&&U._helpShortFlag&&!U._findOption(U._helpShortFlag),Q=U._hasHelpOption&&!U._findOption(U._helpLongFlag);if(J||Q){let Y;if(!J)Y=U.createOption(U._helpLongFlag,U._helpDescription);else if(!Q)Y=U.createOption(U._helpShortFlag,U._helpDescription);else Y=U.createOption(U._helpFlags,U._helpDescription);$.push(Y)}if(this.sortOptions)$.sort(this.compareOptions);return $}visibleGlobalOptions(U){if(!this.showGlobalOptions)return[];let $=[];for(let J=U.parent;J;J=J.parent){let Q=J.options.filter((Y)=>!Y.hidden);$.push(...Q)}if(this.sortOptions)$.sort(this.compareOptions);return $}visibleArguments(U){if(U._argsDescription)U.registeredArguments.forEach(($)=>{$.description=$.description||U._argsDescription[$.name()]||""});if(U.registeredArguments.find(($)=>$.description))return U.registeredArguments;return[]}subcommandTerm(U){let $=U.registeredArguments.map((J)=>zJ(J)).join(" ");return U._name+(U._aliases[0]?"|"+U._aliases[0]:"")+(U.options.length?" [options]":"")+($?" "+$:"")}optionTerm(U){return U.flags}argumentTerm(U){return U.name()}longestSubcommandTermLength(U,$){return $.visibleCommands(U).reduce((J,Q)=>{return Math.max(J,$.subcommandTerm(Q).length)},0)}longestOptionTermLength(U,$){return $.visibleOptions(U).reduce((J,Q)=>{return Math.max(J,$.optionTerm(Q).length)},0)}longestGlobalOptionTermLength(U,$){return $.visibleGlobalOptions(U).reduce((J,Q)=>{return Math.max(J,$.optionTerm(Q).length)},0)}longestArgumentTermLength(U,$){return $.visibleArguments(U).reduce((J,Q)=>{return Math.max(J,$.argumentTerm(Q).length)},0)}commandUsage(U){let $=U._name;if(U._aliases[0])$=$+"|"+U._aliases[0];let J="";for(let Q=U.parent;Q;Q=Q.parent)J=Q.name()+" "+J;return J+$+" "+U.usage()}commandDescription(U){return U.description()}subcommandDescription(U){return U.summary()||U.description()}optionDescription(U){let $=[];if(U.argChoices)$.push(`choices: ${U.argChoices.map((J)=>JSON.stringify(J)).join(", ")}`);if(U.defaultValue!==void 0){if(U.required||U.optional||U.isBoolean()&&typeof U.defaultValue==="boolean")$.push(`default: ${U.defaultValueDescription||JSON.stringify(U.defaultValue)}`)}if(U.presetArg!==void 0&&U.optional)$.push(`preset: ${JSON.stringify(U.presetArg)}`);if(U.envVar!==void 0)$.push(`env: ${U.envVar}`);if($.length>0)return`${U.description} (${$.join(", ")})`;return U.description}argumentDescription(U){let $=[];if(U.argChoices)$.push(`choices: ${U.argChoices.map((J)=>JSON.stringify(J)).join(", ")}`);if(U.defaultValue!==void 0)$.push(`default: ${U.defaultValueDescription||JSON.stringify(U.defaultValue)}`);if($.length>0){let J=`(${$.join(", ")})`;if(U.description)return`${U.description} ${J}`;return J}return U.description}formatHelp(U,$){let J=$.padWidth(U,$),Q=$.helpWidth||80,Y=2,Z=2;function G(H,I){if(I){let M=`${H.padEnd(J+2)}${I}`;return $.wrap(M,Q-2,J+2)}return H}function X(H){return H.join(`
`).replace(/^/gm," ".repeat(2))}let q=[`Usage: ${$.commandUsage(U)}`,""],W=$.commandDescription(U);if(W.length>0)q=q.concat([$.wrap(W,Q,0),""]);let z=$.visibleArguments(U).map((H)=>{return G($.argumentTerm(H),$.argumentDescription(H))});if(z.length>0)q=q.concat(["Arguments:",X(z),""]);let T=$.visibleOptions(U).map((H)=>{return G($.optionTerm(H),$.optionDescription(H))});if(T.length>0)q=q.concat(["Options:",X(T),""]);if(this.showGlobalOptions){let H=$.visibleGlobalOptions(U).map((I)=>{return G($.optionTerm(I),$.optionDescription(I))});if(H.length>0)q=q.concat(["Global Options:",X(H),""])}let K=$.visibleCommands(U).map((H)=>{return G($.subcommandTerm(H),$.subcommandDescription(H))});if(K.length>0)q=q.concat(["Commands:",X(K),""]);return q.join(`
`)}padWidth(U,$){return Math.max($.longestOptionTermLength(U,$),$.longestGlobalOptionTermLength(U,$),$.longestSubcommandTermLength(U,$),$.longestArgumentTermLength(U,$))}wrap(U,$,J,Q=40){let Z=new RegExp(`[\\n][${" \\f\\t\\v   -   　\uFEFF"}]+`);if(U.match(Z))return U;let G=$-J;if(G<Q)return U;let X=U.slice(0,J),q=U.slice(J).replace(`\r
`,`
`),W=" ".repeat(J),T=`\\s${"​"}`,K=new RegExp(`
|.{1,${G-1}}([${T}]|$)|[^${T}]+?([${T}]|$)`,"g"),H=q.match(K)||[];return X+H.map((I,M)=>{if(I===`
`)return"";return(M>0?W:"")+I.trimEnd()}).join(`
`)}}TJ.Help=yU});var JU=r((IJ)=>{var{InvalidArgumentError:HJ}=_0();class fU{constructor(U,$){this.flags=U,this.description=$||"",this.required=U.includes("<"),this.optional=U.includes("["),this.variadic=/\w\.\.\.[>\]]$/.test(U),this.mandatory=!1;let J=xU(U);if(this.short=J.shortFlag,this.long=J.longFlag,this.negate=!1,this.long)this.negate=this.long.startsWith("--no-");this.defaultValue=void 0,this.defaultValueDescription=void 0,this.presetArg=void 0,this.envVar=void 0,this.parseArg=void 0,this.hidden=!1,this.argChoices=void 0,this.conflictsWith=[],this.implied=void 0}default(U,$){return this.defaultValue=U,this.defaultValueDescription=$,this}preset(U){return this.presetArg=U,this}conflicts(U){return this.conflictsWith=this.conflictsWith.concat(U),this}implies(U){let $=U;if(typeof U==="string")$={[U]:!0};return this.implied=Object.assign(this.implied||{},$),this}env(U){return this.envVar=U,this}argParser(U){return this.parseArg=U,this}makeOptionMandatory(U=!0){return this.mandatory=!!U,this}hideHelp(U=!0){return this.hidden=!!U,this}_concatValue(U,$){if($===this.defaultValue||!Array.isArray($))return[U];return $.concat(U)}choices(U){return this.argChoices=U.slice(),this.parseArg=($,J)=>{if(!this.argChoices.includes($))throw new HJ(`Allowed choices are ${this.argChoices.join(", ")}.`);if(this.variadic)return this._concatValue($,J);return $},this}name(){if(this.long)return this.long.replace(/^--/,"");return this.short.replace(/^-/,"")}attributeName(){return VJ(this.name().replace(/^no-/,""))}is(U){return this.short===U||this.long===U}isBoolean(){return!this.required&&!this.optional&&!this.negate}}class bU{constructor(U){this.positiveOptions=new Map,this.negativeOptions=new Map,this.dualOptions=new Set,U.forEach(($)=>{if($.negate)this.negativeOptions.set($.attributeName(),$);else this.positiveOptions.set($.attributeName(),$)}),this.negativeOptions.forEach(($,J)=>{if(this.positiveOptions.has(J))this.dualOptions.add(J)})}valueFromOption(U,$){let J=$.attributeName();if(!this.dualOptions.has(J))return!0;let Q=this.negativeOptions.get(J).presetArg,Y=Q!==void 0?Q:!1;return $.negate===(Y===U)}}function VJ(U){return U.split("-").reduce(($,J)=>{return $+J[0].toUpperCase()+J.slice(1)})}function xU(U){let $,J,Q=U.split(/[ |,]+/);if(Q.length>1&&!/^[[<]/.test(Q[1]))$=Q.shift();if(J=Q.shift(),!$&&/^-[^-]$/.test(J))$=J,J=void 0;return{shortFlag:$,longFlag:J}}IJ.Option=fU;IJ.splitOptionFlags=xU;IJ.DualOptions=bU});var hU=r((DJ)=>{function RJ(U,$){if(Math.abs(U.length-$.length)>3)return Math.max(U.length,$.length);let J=[];for(let Q=0;Q<=U.length;Q++)J[Q]=[Q];for(let Q=0;Q<=$.length;Q++)J[0][Q]=Q;for(let Q=1;Q<=$.length;Q++)for(let Y=1;Y<=U.length;Y++){let Z=1;if(U[Y-1]===$[Q-1])Z=0;else Z=1;if(J[Y][Q]=Math.min(J[Y-1][Q]+1,J[Y][Q-1]+1,J[Y-1][Q-1]+Z),Y>1&&Q>1&&U[Y-1]===$[Q-2]&&U[Y-2]===$[Q-1])J[Y][Q]=Math.min(J[Y][Q],J[Y-2][Q-2]+1)}return J[U.length][$.length]}function NJ(U,$){if(!$||$.length===0)return"";$=Array.from(new Set($));let J=U.startsWith("--");if(J)U=U.slice(2),$=$.map((G)=>G.slice(2));let Q=[],Y=3,Z=0.4;if($.forEach((G)=>{if(G.length<=1)return;let X=RJ(U,G),q=Math.max(U.length,G.length);if((q-X)/q>Z){if(X<Y)Y=X,Q=[G];else if(X===Y)Q.push(G)}}),Q.sort((G,X)=>G.localeCompare(X)),J)Q=Q.map((G)=>`--${G}`);if(Q.length>1)return`
(Did you mean one of ${Q.join(", ")}?)`;if(Q.length===1)return`
(Did you mean ${Q[0]}?)`;return""}DJ.suggestSimilar=NJ});var cU=r((EJ)=>{var FJ=h("events").EventEmitter,QU=h("child_process"),Q0=h("path"),YU=h("fs"),C=h("process"),{Argument:LJ,humanReadableArgName:_J}=h0(),{CommanderError:ZU}=_0(),{Help:wJ}=$U(),{Option:gU,splitOptionFlags:AJ,DualOptions:jJ}=JU(),{suggestSimilar:mU}=hU();class GU extends FJ{constructor(U){super();this.commands=[],this.options=[],this.parent=null,this._allowUnknownOption=!1,this._allowExcessArguments=!0,this.registeredArguments=[],this._args=this.registeredArguments,this.args=[],this.rawArgs=[],this.processedArgs=[],this._scriptPath=null,this._name=U||"",this._optionValues={},this._optionValueSources={},this._storeOptionsAsProperties=!1,this._actionHandler=null,this._executableHandler=!1,this._executableFile=null,this._executableDir=null,this._defaultCommandName=null,this._exitCallback=null,this._aliases=[],this._combineFlagAndOptionalValue=!0,this._description="",this._summary="",this._argsDescription=void 0,this._enablePositionalOptions=!1,this._passThroughOptions=!1,this._lifeCycleHooks={},this._showHelpAfterError=!1,this._showSuggestionAfterError=!0,this._outputConfiguration={writeOut:($)=>C.stdout.write($),writeErr:($)=>C.stderr.write($),getOutHelpWidth:()=>C.stdout.isTTY?C.stdout.columns:void 0,getErrHelpWidth:()=>C.stderr.isTTY?C.stderr.columns:void 0,outputError:($,J)=>J($)},this._hidden=!1,this._hasHelpOption=!0,this._helpFlags="-h, --help",this._helpDescription="display help for command",this._helpShortFlag="-h",this._helpLongFlag="--help",this._addImplicitHelpCommand=void 0,this._helpCommandName="help",this._helpCommandnameAndArgs="help [command]",this._helpCommandDescription="display help for command",this._helpConfiguration={}}copyInheritedSettings(U){return this._outputConfiguration=U._outputConfiguration,this._hasHelpOption=U._hasHelpOption,this._helpFlags=U._helpFlags,this._helpDescription=U._helpDescription,this._helpShortFlag=U._helpShortFlag,this._helpLongFlag=U._helpLongFlag,this._helpCommandName=U._helpCommandName,this._helpCommandnameAndArgs=U._helpCommandnameAndArgs,this._helpCommandDescription=U._helpCommandDescription,this._helpConfiguration=U._helpConfiguration,this._exitCallback=U._exitCallback,this._storeOptionsAsProperties=U._storeOptionsAsProperties,this._combineFlagAndOptionalValue=U._combineFlagAndOptionalValue,this._allowExcessArguments=U._allowExcessArguments,this._enablePositionalOptions=U._enablePositionalOptions,this._showHelpAfterError=U._showHelpAfterError,this._showSuggestionAfterError=U._showSuggestionAfterError,this}_getCommandAndAncestors(){let U=[];for(let $=this;$;$=$.parent)U.push($);return U}command(U,$,J){let Q=$,Y=J;if(typeof Q==="object"&&Q!==null)Y=Q,Q=null;Y=Y||{};let[,Z,G]=U.match(/([^ ]+) *(.*)/),X=this.createCommand(Z);if(Q)X.description(Q),X._executableHandler=!0;if(Y.isDefault)this._defaultCommandName=X._name;if(X._hidden=!!(Y.noHelp||Y.hidden),X._executableFile=Y.executableFile||null,G)X.arguments(G);if(this.commands.push(X),X.parent=this,X.copyInheritedSettings(this),Q)return this;return X}createCommand(U){return new GU(U)}createHelp(){return Object.assign(new wJ,this.configureHelp())}configureHelp(U){if(U===void 0)return this._helpConfiguration;return this._helpConfiguration=U,this}configureOutput(U){if(U===void 0)return this._outputConfiguration;return Object.assign(this._outputConfiguration,U),this}showHelpAfterError(U=!0){if(typeof U!=="string")U=!!U;return this._showHelpAfterError=U,this}showSuggestionAfterError(U=!0){return this._showSuggestionAfterError=!!U,this}addCommand(U,$){if(!U._name)throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);if($=$||{},$.isDefault)this._defaultCommandName=U._name;if($.noHelp||$.hidden)U._hidden=!0;return this.commands.push(U),U.parent=this,this}createArgument(U,$){return new LJ(U,$)}argument(U,$,J,Q){let Y=this.createArgument(U,$);if(typeof J==="function")Y.default(Q).argParser(J);else Y.default(J);return this.addArgument(Y),this}arguments(U){return U.trim().split(/ +/).forEach(($)=>{this.argument($)}),this}addArgument(U){let $=this.registeredArguments.slice(-1)[0];if($&&$.variadic)throw new Error(`only the last argument can be variadic '${$.name()}'`);if(U.required&&U.defaultValue!==void 0&&U.parseArg===void 0)throw new Error(`a default value for a required argument is never used: '${U.name()}'`);return this.registeredArguments.push(U),this}addHelpCommand(U,$){if(U===!1)this._addImplicitHelpCommand=!1;else{if(this._addImplicitHelpCommand=!0,typeof U==="string")this._helpCommandName=U.split(" ")[0],this._helpCommandnameAndArgs=U;this._helpCommandDescription=$||this._helpCommandDescription}return this}_hasImplicitHelpCommand(){if(this._addImplicitHelpCommand===void 0)return this.commands.length&&!this._actionHandler&&!this._findCommand("help");return this._addImplicitHelpCommand}hook(U,$){let J=["preSubcommand","preAction","postAction"];if(!J.includes(U))throw new Error(`Unexpected value for event passed to hook : '${U}'.
Expecting one of '${J.join("', '")}'`);if(this._lifeCycleHooks[U])this._lifeCycleHooks[U].push($);else this._lifeCycleHooks[U]=[$];return this}exitOverride(U){if(U)this._exitCallback=U;else this._exitCallback=($)=>{if($.code!=="commander.executeSubCommandAsync")throw $};return this}_exit(U,$,J){if(this._exitCallback)this._exitCallback(new ZU(U,$,J));C.exit(U)}action(U){let $=(J)=>{let Q=this.registeredArguments.length,Y=J.slice(0,Q);if(this._storeOptionsAsProperties)Y[Q]=this;else Y[Q]=this.opts();return Y.push(this),U.apply(this,Y)};return this._actionHandler=$,this}createOption(U,$){return new gU(U,$)}_callParseArg(U,$,J,Q){try{return U.parseArg($,J)}catch(Y){if(Y.code==="commander.invalidArgument"){let Z=`${Q} ${Y.message}`;this.error(Z,{exitCode:Y.exitCode,code:Y.code})}throw Y}}addOption(U){let $=U.name(),J=U.attributeName();if(U.negate){let Y=U.long.replace(/^--no-/,"--");if(!this._findOption(Y))this.setOptionValueWithSource(J,U.defaultValue===void 0?!0:U.defaultValue,"default")}else if(U.defaultValue!==void 0)this.setOptionValueWithSource(J,U.defaultValue,"default");this.options.push(U);let Q=(Y,Z,G)=>{if(Y==null&&U.presetArg!==void 0)Y=U.presetArg;let X=this.getOptionValue(J);if(Y!==null&&U.parseArg)Y=this._callParseArg(U,Y,X,Z);else if(Y!==null&&U.variadic)Y=U._concatValue(Y,X);if(Y==null)if(U.negate)Y=!1;else if(U.isBoolean()||U.optional)Y=!0;else Y="";this.setOptionValueWithSource(J,Y,G)};if(this.on("option:"+$,(Y)=>{let Z=`error: option '${U.flags}' argument '${Y}' is invalid.`;Q(Y,Z,"cli")}),U.envVar)this.on("optionEnv:"+$,(Y)=>{let Z=`error: option '${U.flags}' value '${Y}' from env '${U.envVar}' is invalid.`;Q(Y,Z,"env")});return this}_optionEx(U,$,J,Q,Y){if(typeof $==="object"&&$ instanceof gU)throw new Error("To add an Option object use addOption() instead of option() or requiredOption()");let Z=this.createOption($,J);if(Z.makeOptionMandatory(!!U.mandatory),typeof Q==="function")Z.default(Y).argParser(Q);else if(Q instanceof RegExp){let G=Q;Q=(X,q)=>{let W=G.exec(X);return W?W[0]:q},Z.default(Y).argParser(Q)}else Z.default(Q);return this.addOption(Z)}option(U,$,J,Q){return this._optionEx({},U,$,J,Q)}requiredOption(U,$,J,Q){return this._optionEx({mandatory:!0},U,$,J,Q)}combineFlagAndOptionalValue(U=!0){return this._combineFlagAndOptionalValue=!!U,this}allowUnknownOption(U=!0){return this._allowUnknownOption=!!U,this}allowExcessArguments(U=!0){return this._allowExcessArguments=!!U,this}enablePositionalOptions(U=!0){return this._enablePositionalOptions=!!U,this}passThroughOptions(U=!0){if(this._passThroughOptions=!!U,!!this.parent&&U&&!this.parent._enablePositionalOptions)throw new Error("passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)");return this}storeOptionsAsProperties(U=!0){if(this.options.length)throw new Error("call .storeOptionsAsProperties() before adding options");return this._storeOptionsAsProperties=!!U,this}getOptionValue(U){if(this._storeOptionsAsProperties)return this[U];return this._optionValues[U]}setOptionValue(U,$){return this.setOptionValueWithSource(U,$,void 0)}setOptionValueWithSource(U,$,J){if(this._storeOptionsAsProperties)this[U]=$;else this._optionValues[U]=$;return this._optionValueSources[U]=J,this}getOptionValueSource(U){return this._optionValueSources[U]}getOptionValueSourceWithGlobals(U){let $;return this._getCommandAndAncestors().forEach((J)=>{if(J.getOptionValueSource(U)!==void 0)$=J.getOptionValueSource(U)}),$}_prepareUserArgs(U,$){if(U!==void 0&&!Array.isArray(U))throw new Error("first parameter to parse must be array or undefined");if($=$||{},U===void 0){if(U=C.argv,C.versions&&C.versions.electron)$.from="electron"}this.rawArgs=U.slice();let J;switch($.from){case void 0:case"node":this._scriptPath=U[1],J=U.slice(2);break;case"electron":if(C.defaultApp)this._scriptPath=U[1],J=U.slice(2);else J=U.slice(1);break;case"user":J=U.slice(0);break;default:throw new Error(`unexpected parse option { from: '${$.from}' }`)}if(!this._name&&this._scriptPath)this.nameFromFilename(this._scriptPath);return this._name=this._name||"program",J}parse(U,$){let J=this._prepareUserArgs(U,$);return this._parseCommand([],J),this}async parseAsync(U,$){let J=this._prepareUserArgs(U,$);return await this._parseCommand([],J),this}_executeSubCommand(U,$){$=$.slice();let J=!1,Q=[".js",".ts",".tsx",".mjs",".cjs"];function Y(W,z){let T=Q0.resolve(W,z);if(YU.existsSync(T))return T;if(Q.includes(Q0.extname(z)))return;let K=Q.find((H)=>YU.existsSync(`${T}${H}`));if(K)return`${T}${K}`;return}this._checkForMissingMandatoryOptions(),this._checkForConflictingOptions();let Z=U._executableFile||`${this._name}-${U._name}`,G=this._executableDir||"";if(this._scriptPath){let W;try{W=YU.realpathSync(this._scriptPath)}catch(z){W=this._scriptPath}G=Q0.resolve(Q0.dirname(W),G)}if(G){let W=Y(G,Z);if(!W&&!U._executableFile&&this._scriptPath){let z=Q0.basename(this._scriptPath,Q0.extname(this._scriptPath));if(z!==this._name)W=Y(G,`${z}-${U._name}`)}Z=W||Z}J=Q.includes(Q0.extname(Z));let X;if(C.platform!=="win32")if(J)$.unshift(Z),$=lU(C.execArgv).concat($),X=QU.spawn(C.argv[0],$,{stdio:"inherit"});else X=QU.spawn(Z,$,{stdio:"inherit"});else $.unshift(Z),$=lU(C.execArgv).concat($),X=QU.spawn(C.execPath,$,{stdio:"inherit"});if(!X.killed)["SIGUSR1","SIGUSR2","SIGTERM","SIGINT","SIGHUP"].forEach((z)=>{C.on(z,()=>{if(X.killed===!1&&X.exitCode===null)X.kill(z)})});let q=this._exitCallback;if(!q)X.on("close",C.exit.bind(C));else X.on("close",()=>{q(new ZU(C.exitCode||0,"commander.executeSubCommandAsync","(close)"))});X.on("error",(W)=>{if(W.code==="ENOENT"){let z=G?`searched for local subcommand relative to directory '${G}'`:"no directory for search for local subcommand, use .executableDir() to supply a custom directory",T=`'${Z}' does not exist
 - if '${U._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${z}`;throw new Error(T)}else if(W.code==="EACCES")throw new Error(`'${Z}' not executable`);if(!q)C.exit(1);else{let z=new ZU(1,"commander.executeSubCommandAsync","(error)");z.nestedError=W,q(z)}}),this.runningCommand=X}_dispatchSubcommand(U,$,J){let Q=this._findCommand(U);if(!Q)this.help({error:!0});let Y;return Y=this._chainOrCallSubCommandHook(Y,Q,"preSubcommand"),Y=this._chainOrCall(Y,()=>{if(Q._executableHandler)this._executeSubCommand(Q,$.concat(J));else return Q._parseCommand($,J)}),Y}_dispatchHelpCommand(U){if(!U)this.help();let $=this._findCommand(U);if($&&!$._executableHandler)$.help();return this._dispatchSubcommand(U,[],[this._helpLongFlag||this._helpShortFlag])}_checkNumberOfArguments(){if(this.registeredArguments.forEach((U,$)=>{if(U.required&&this.args[$]==null)this.missingArgument(U.name())}),this.registeredArguments.length>0&&this.registeredArguments[this.registeredArguments.length-1].variadic)return;if(this.args.length>this.registeredArguments.length)this._excessArguments(this.args)}_processArguments(){let U=(J,Q,Y)=>{let Z=Q;if(Q!==null&&J.parseArg){let G=`error: command-argument value '${Q}' is invalid for argument '${J.name()}'.`;Z=this._callParseArg(J,Q,Y,G)}return Z};this._checkNumberOfArguments();let $=[];this.registeredArguments.forEach((J,Q)=>{let Y=J.defaultValue;if(J.variadic){if(Q<this.args.length){if(Y=this.args.slice(Q),J.parseArg)Y=Y.reduce((Z,G)=>{return U(J,G,Z)},J.defaultValue)}else if(Y===void 0)Y=[]}else if(Q<this.args.length){if(Y=this.args[Q],J.parseArg)Y=U(J,Y,J.defaultValue)}$[Q]=Y}),this.processedArgs=$}_chainOrCall(U,$){if(U&&U.then&&typeof U.then==="function")return U.then(()=>$());return $()}_chainOrCallHooks(U,$){let J=U,Q=[];if(this._getCommandAndAncestors().reverse().filter((Y)=>Y._lifeCycleHooks[$]!==void 0).forEach((Y)=>{Y._lifeCycleHooks[$].forEach((Z)=>{Q.push({hookedCommand:Y,callback:Z})})}),$==="postAction")Q.reverse();return Q.forEach((Y)=>{J=this._chainOrCall(J,()=>{return Y.callback(Y.hookedCommand,this)})}),J}_chainOrCallSubCommandHook(U,$,J){let Q=U;if(this._lifeCycleHooks[J]!==void 0)this._lifeCycleHooks[J].forEach((Y)=>{Q=this._chainOrCall(Q,()=>{return Y(this,$)})});return Q}_parseCommand(U,$){let J=this.parseOptions($);if(this._parseOptionsEnv(),this._parseOptionsImplied(),U=U.concat(J.operands),$=J.unknown,this.args=U.concat($),U&&this._findCommand(U[0]))return this._dispatchSubcommand(U[0],U.slice(1),$);if(this._hasImplicitHelpCommand()&&U[0]===this._helpCommandName)return this._dispatchHelpCommand(U[1]);if(this._defaultCommandName)return uU(this,$),this._dispatchSubcommand(this._defaultCommandName,U,$);if(this.commands.length&&this.args.length===0&&!this._actionHandler&&!this._defaultCommandName)this.help({error:!0});uU(this,J.unknown),this._checkForMissingMandatoryOptions(),this._checkForConflictingOptions();let Q=()=>{if(J.unknown.length>0)this.unknownOption(J.unknown[0])},Y=`command:${this.name()}`;if(this._actionHandler){Q(),this._processArguments();let Z;if(Z=this._chainOrCallHooks(Z,"preAction"),Z=this._chainOrCall(Z,()=>this._actionHandler(this.processedArgs)),this.parent)Z=this._chainOrCall(Z,()=>{this.parent.emit(Y,U,$)});return Z=this._chainOrCallHooks(Z,"postAction"),Z}if(this.parent&&this.parent.listenerCount(Y))Q(),this._processArguments(),this.parent.emit(Y,U,$);else if(U.length){if(this._findCommand("*"))return this._dispatchSubcommand("*",U,$);if(this.listenerCount("command:*"))this.emit("command:*",U,$);else if(this.commands.length)this.unknownCommand();else Q(),this._processArguments()}else if(this.commands.length)Q(),this.help({error:!0});else Q(),this._processArguments()}_findCommand(U){if(!U)return;return this.commands.find(($)=>$._name===U||$._aliases.includes(U))}_findOption(U){return this.options.find(($)=>$.is(U))}_checkForMissingMandatoryOptions(){this._getCommandAndAncestors().forEach((U)=>{U.options.forEach(($)=>{if($.mandatory&&U.getOptionValue($.attributeName())===void 0)U.missingMandatoryOptionValue($)})})}_checkForConflictingLocalOptions(){let U=this.options.filter((J)=>{let Q=J.attributeName();if(this.getOptionValue(Q)===void 0)return!1;return this.getOptionValueSource(Q)!=="default"});U.filter((J)=>J.conflictsWith.length>0).forEach((J)=>{let Q=U.find((Y)=>J.conflictsWith.includes(Y.attributeName()));if(Q)this._conflictingOption(J,Q)})}_checkForConflictingOptions(){this._getCommandAndAncestors().forEach((U)=>{U._checkForConflictingLocalOptions()})}parseOptions(U){let $=[],J=[],Q=$,Y=U.slice();function Z(X){return X.length>1&&X[0]==="-"}let G=null;while(Y.length){let X=Y.shift();if(X==="--"){if(Q===J)Q.push(X);Q.push(...Y);break}if(G&&!Z(X)){this.emit(`option:${G.name()}`,X);continue}if(G=null,Z(X)){let q=this._findOption(X);if(q){if(q.required){let W=Y.shift();if(W===void 0)this.optionMissingArgument(q);this.emit(`option:${q.name()}`,W)}else if(q.optional){let W=null;if(Y.length>0&&!Z(Y[0]))W=Y.shift();this.emit(`option:${q.name()}`,W)}else this.emit(`option:${q.name()}`);G=q.variadic?q:null;continue}}if(X.length>2&&X[0]==="-"&&X[1]!=="-"){let q=this._findOption(`-${X[1]}`);if(q){if(q.required||q.optional&&this._combineFlagAndOptionalValue)this.emit(`option:${q.name()}`,X.slice(2));else this.emit(`option:${q.name()}`),Y.unshift(`-${X.slice(2)}`);continue}}if(/^--[^=]+=/.test(X)){let q=X.indexOf("="),W=this._findOption(X.slice(0,q));if(W&&(W.required||W.optional)){this.emit(`option:${W.name()}`,X.slice(q+1));continue}}if(Z(X))Q=J;if((this._enablePositionalOptions||this._passThroughOptions)&&$.length===0&&J.length===0){if(this._findCommand(X)){if($.push(X),Y.length>0)J.push(...Y);break}else if(X===this._helpCommandName&&this._hasImplicitHelpCommand()){if($.push(X),Y.length>0)$.push(...Y);break}else if(this._defaultCommandName){if(J.push(X),Y.length>0)J.push(...Y);break}}if(this._passThroughOptions){if(Q.push(X),Y.length>0)Q.push(...Y);break}Q.push(X)}return{operands:$,unknown:J}}opts(){if(this._storeOptionsAsProperties){let U={},$=this.options.length;for(let J=0;J<$;J++){let Q=this.options[J].attributeName();U[Q]=Q===this._versionOptionName?this._version:this[Q]}return U}return this._optionValues}optsWithGlobals(){return this._getCommandAndAncestors().reduce((U,$)=>Object.assign(U,$.opts()),{})}error(U,$){if(this._outputConfiguration.outputError(`${U}
`,this._outputConfiguration.writeErr),typeof this._showHelpAfterError==="string")this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`);else if(this._showHelpAfterError)this._outputConfiguration.writeErr(`
`),this.outputHelp({error:!0});let J=$||{},Q=J.exitCode||1,Y=J.code||"commander.error";this._exit(Q,Y,U)}_parseOptionsEnv(){this.options.forEach((U)=>{if(U.envVar&&U.envVar in C.env){let $=U.attributeName();if(this.getOptionValue($)===void 0||["default","config","env"].includes(this.getOptionValueSource($)))if(U.required||U.optional)this.emit(`optionEnv:${U.name()}`,C.env[U.envVar]);else this.emit(`optionEnv:${U.name()}`)}})}_parseOptionsImplied(){let U=new jJ(this.options),$=(J)=>{return this.getOptionValue(J)!==void 0&&!["default","implied"].includes(this.getOptionValueSource(J))};this.options.filter((J)=>J.implied!==void 0&&$(J.attributeName())&&U.valueFromOption(this.getOptionValue(J.attributeName()),J)).forEach((J)=>{Object.keys(J.implied).filter((Q)=>!$(Q)).forEach((Q)=>{this.setOptionValueWithSource(Q,J.implied[Q],"implied")})})}missingArgument(U){let $=`error: missing required argument '${U}'`;this.error($,{code:"commander.missingArgument"})}optionMissingArgument(U){let $=`error: option '${U.flags}' argument missing`;this.error($,{code:"commander.optionMissingArgument"})}missingMandatoryOptionValue(U){let $=`error: required option '${U.flags}' not specified`;this.error($,{code:"commander.missingMandatoryOptionValue"})}_conflictingOption(U,$){let J=(Z)=>{let G=Z.attributeName(),X=this.getOptionValue(G),q=this.options.find((z)=>z.negate&&G===z.attributeName()),W=this.options.find((z)=>!z.negate&&G===z.attributeName());if(q&&(q.presetArg===void 0&&X===!1||q.presetArg!==void 0&&X===q.presetArg))return q;return W||Z},Q=(Z)=>{let G=J(Z),X=G.attributeName();if(this.getOptionValueSource(X)==="env")return`environment variable '${G.envVar}'`;return`option '${G.flags}'`},Y=`error: ${Q(U)} cannot be used with ${Q($)}`;this.error(Y,{code:"commander.conflictingOption"})}unknownOption(U){if(this._allowUnknownOption)return;let $="";if(U.startsWith("--")&&this._showSuggestionAfterError){let Q=[],Y=this;do{let Z=Y.createHelp().visibleOptions(Y).filter((G)=>G.long).map((G)=>G.long);Q=Q.concat(Z),Y=Y.parent}while(Y&&!Y._enablePositionalOptions);$=mU(U,Q)}let J=`error: unknown option '${U}'${$}`;this.error(J,{code:"commander.unknownOption"})}_excessArguments(U){if(this._allowExcessArguments)return;let $=this.registeredArguments.length,J=$===1?"":"s",Y=`error: too many arguments${this.parent?` for '${this.name()}'`:""}. Expected ${$} argument${J} but got ${U.length}.`;this.error(Y,{code:"commander.excessArguments"})}unknownCommand(){let U=this.args[0],$="";if(this._showSuggestionAfterError){let Q=[];this.createHelp().visibleCommands(this).forEach((Y)=>{if(Q.push(Y.name()),Y.alias())Q.push(Y.alias())}),$=mU(U,Q)}let J=`error: unknown command '${U}'${$}`;this.error(J,{code:"commander.unknownCommand"})}version(U,$,J){if(U===void 0)return this._version;this._version=U,$=$||"-V, --version",J=J||"output the version number";let Q=this.createOption($,J);return this._versionOptionName=Q.attributeName(),this.options.push(Q),this.on("option:"+Q.name(),()=>{this._outputConfiguration.writeOut(`${U}
`),this._exit(0,"commander.version",U)}),this}description(U,$){if(U===void 0&&$===void 0)return this._description;if(this._description=U,$)this._argsDescription=$;return this}summary(U){if(U===void 0)return this._summary;return this._summary=U,this}alias(U){if(U===void 0)return this._aliases[0];let $=this;if(this.commands.length!==0&&this.commands[this.commands.length-1]._executableHandler)$=this.commands[this.commands.length-1];if(U===$._name)throw new Error("Command alias can't be the same as its name");return $._aliases.push(U),this}aliases(U){if(U===void 0)return this._aliases;return U.forEach(($)=>this.alias($)),this}usage(U){if(U===void 0){if(this._usage)return this._usage;let $=this.registeredArguments.map((J)=>{return _J(J)});return[].concat(this.options.length||this._hasHelpOption?"[options]":[],this.commands.length?"[command]":[],this.registeredArguments.length?$:[]).join(" ")}return this._usage=U,this}name(U){if(U===void 0)return this._name;return this._name=U,this}nameFromFilename(U){return this._name=Q0.basename(U,Q0.extname(U)),this}executableDir(U){if(U===void 0)return this._executableDir;return this._executableDir=U,this}helpInformation(U){let $=this.createHelp();if($.helpWidth===void 0)$.helpWidth=U&&U.error?this._outputConfiguration.getErrHelpWidth():this._outputConfiguration.getOutHelpWidth();return $.formatHelp(this,$)}_getHelpContext(U){U=U||{};let $={error:!!U.error},J;if($.error)J=(Q)=>this._outputConfiguration.writeErr(Q);else J=(Q)=>this._outputConfiguration.writeOut(Q);return $.write=U.write||J,$.command=this,$}outputHelp(U){let $;if(typeof U==="function")$=U,U=void 0;let J=this._getHelpContext(U);this._getCommandAndAncestors().reverse().forEach((Y)=>Y.emit("beforeAllHelp",J)),this.emit("beforeHelp",J);let Q=this.helpInformation(J);if($){if(Q=$(Q),typeof Q!=="string"&&!Buffer.isBuffer(Q))throw new Error("outputHelp callback must return a string or a Buffer")}if(J.write(Q),this._helpLongFlag)this.emit(this._helpLongFlag);this.emit("afterHelp",J),this._getCommandAndAncestors().forEach((Y)=>Y.emit("afterAllHelp",J))}helpOption(U,$){if(typeof U==="boolean")return this._hasHelpOption=U,this;this._helpFlags=U||this._helpFlags,this._helpDescription=$||this._helpDescription;let J=AJ(this._helpFlags);return this._helpShortFlag=J.shortFlag,this._helpLongFlag=J.longFlag,this}help(U){this.outputHelp(U);let $=C.exitCode||0;if($===0&&U&&typeof U!=="function"&&U.error)$=1;this._exit($,"commander.help","(outputHelp)")}addHelpText(U,$){let J=["beforeAll","before","after","afterAll"];if(!J.includes(U))throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${J.join("', '")}'`);let Q=`${U}Help`;return this.on(Q,(Y)=>{let Z;if(typeof $==="function")Z=$({error:Y.error,command:Y.command});else Z=$;if(Z)Y.write(`${Z}
`)}),this}}function uU(U,$){if(U._hasHelpOption&&$.find((Q)=>Q===U._helpLongFlag||Q===U._helpShortFlag))U.outputHelp(),U._exit(0,"commander.helpDisplayed","(outputHelp)")}function lU(U){return U.map(($)=>{if(!$.startsWith("--inspect"))return $;let J,Q="127.0.0.1",Y="9229",Z;if((Z=$.match(/^(--inspect(-brk)?)$/))!==null)J=Z[1];else if((Z=$.match(/^(--inspect(-brk|-port)?)=([^:]+)$/))!==null)if(J=Z[1],/^\d+$/.test(Z[3]))Y=Z[3];else Q=Z[3];else if((Z=$.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/))!==null)J=Z[1],Q=Z[3],Y=Z[4];if(J&&Y!=="0")return`${J}=${Q}:${parseInt(Y)+1}`;return $})}EJ.Command=GU});var nU=r((o,iU)=>{var{Argument:CJ}=h0(),{Command:dU}=cU(),{CommanderError:kJ,InvalidArgumentError:pU}=_0(),{Help:vJ}=$U(),{Option:yJ}=JU();o=iU.exports=new dU;o.program=o;o.Command=dU;o.Option=yJ;o.Argument=CJ;o.Help=vJ;o.CommanderError=kJ;o.InvalidArgumentError=pU;o.InvalidOptionArgumentError=pU});var I$=r((OY,V$)=>{var i0=/^[a-z0-9-]{1,32}$/,n0=/^[a-z0-9-]{1,32}$/,s0=/^[a-zA-Z0-9/+.-]+$/,K$=/^([a-zA-Z0-9/+.-]+|)$/,tJ=/^((-)?[1-9]\d*|0)$/,PU=/^v=(\d+)$/;function eJ(U){return k0(U).map(($)=>[$,U[$]].join("=")).join(",")}function UQ(U){let $={};return U.split(",").forEach((J)=>{let Q=J.split("=");if(Q.length<2)throw new TypeError("params must be in the format name=value");$[Q.shift()]=Q.join("=")}),$}function k0(U){return Object.keys(U)}function H$(U){if(typeof Object.values==="function")return Object.values(U);return k0(U).map(($)=>U[$])}function $Q(U){let $=[""];if(typeof U!=="object"||U===null)throw new TypeError("opts must be an object");if(typeof U.id!=="string")throw new TypeError("id must be a string");if(!i0.test(U.id))throw new TypeError(`id must satisfy ${i0}`);if($.push(U.id),typeof U.version!=="undefined"){if(typeof U.version!=="number"||U.version<0||!Number.isInteger(U.version))throw new TypeError("version must be a positive integer number");$.push(`v=${U.version}`)}if(typeof U.params!=="undefined"){if(typeof U.params!=="object"||U.params===null)throw new TypeError("params must be an object");let Q=k0(U.params);if(!Q.every((G)=>n0.test(G)))throw new TypeError(`params names must satisfy ${n0}`);Q.forEach((G)=>{if(typeof U.params[G]==="number")U.params[G]=U.params[G].toString();else if(Buffer.isBuffer(U.params[G]))U.params[G]=U.params[G].toString("base64").split("=")[0]});let Y=H$(U.params);if(!Y.every((G)=>typeof G==="string"))throw new TypeError("params values must be strings");if(!Y.every((G)=>s0.test(G)))throw new TypeError(`params values must satisfy ${s0}`);let Z=eJ(U.params);$.push(Z)}if(typeof U.salt!=="undefined"){if(!Buffer.isBuffer(U.salt))throw new TypeError("salt must be a Buffer");if($.push(U.salt.toString("base64").split("=")[0]),typeof U.hash!=="undefined"){if(!Buffer.isBuffer(U.hash))throw new TypeError("hash must be a Buffer");$.push(U.hash.toString("base64").split("=")[0])}}return $.join("$")}function JQ(U){if(typeof U!=="string"||U==="")throw new TypeError("pchstr must be a non-empty string");if(U[0]!=="$")throw new TypeError("pchstr must contain a $ as first char");let $=U.split("$");$.shift();let J=5;if(!PU.test($[1]))J--;if($.length>J)throw new TypeError(`pchstr contains too many fileds: ${$.length}/${J}`);let Q=$.shift();if(!i0.test(Q))throw new TypeError(`id must satisfy ${i0}`);let Y;if(PU.test($[0]))Y=parseInt($.shift().match(PU)[1],10);let Z,G;if(K$.test($[$.length-1]))if($.length>1&&K$.test($[$.length-2]))Z=Buffer.from($.pop(),"base64"),G=Buffer.from($.pop(),"base64");else G=Buffer.from($.pop(),"base64");let X;if($.length>0){let W=$.pop();if(X=UQ(W),!k0(X).every((K)=>n0.test(K)))throw new TypeError(`params names must satisfy ${n0}`);if(!H$(X).every((K)=>s0.test(K)))throw new TypeError(`params values must satisfy ${s0}`);k0(X).forEach((K)=>{X[K]=tJ.test(X[K])?parseInt(X[K],10):X[K]})}if($.length>0)throw new TypeError(`pchstr contains unrecognized fileds: ${$}`);let q={id:Q};if(Y)q.version=Y;if(X)q.params=X;if(G)q.salt=G;if(Z)q.hash=Z;return q}V$.exports={serialize:$Q,deserialize:JQ}});var C$=r((CY,O$)=>{var R$=h("fs"),X0=h("path"),N$=h("os"),D$=typeof __webpack_require__==="function"?__non_webpack_require__:h,QQ=process.config&&process.config.variables||{},YQ=!!process.env.PREBUILDS_ONLY,P$=process.versions.modules,MU=XQ()?"electron":GQ()?"node-webkit":"node",BU=process.env.npm_config_arch||N$.arch(),RU=process.env.npm_config_platform||N$.platform(),S$=process.env.LIBC||(qQ(RU)?"musl":"glibc"),NU=process.env.ARM_VERSION||(BU==="arm64"?"8":QQ.arm_version)||"",F$=(process.versions.uv||"").split(".")[0];O$.exports=$0;function $0(U){return D$($0.resolve(U))}$0.resolve=$0.path=function(U){U=X0.resolve(U||".");try{var $=D$(X0.join(U,"package.json")).name.toUpperCase().replace(/-/g,"_");if(process.env[$+"_PREBUILD"])U=process.env[$+"_PREBUILD"]}catch(q){}if(!YQ){var J=M$(X0.join(U,"build/Release"),B$);if(J)return J;var Q=M$(X0.join(U,"build/Debug"),B$);if(Q)return Q}var Y=X(U);if(Y)return Y;var Z=X(X0.dirname(process.execPath));if(Z)return Z;var G=["platform="+RU,"arch="+BU,"runtime="+MU,"abi="+P$,"uv="+F$,NU?"armv="+NU:"","libc="+S$,"node="+process.versions.node,process.versions.electron?"electron="+process.versions.electron:"",typeof __webpack_require__==="function"?"webpack=true":""].filter(Boolean).join(" ");throw new Error("No native build was found for "+G+`
    loaded from: `+U+`
`);function X(q){var W=DU(X0.join(q,"prebuilds")).map(L$),z=W.filter(_$(RU,BU)).sort(w$)[0];if(!z)return;var T=X0.join(q,"prebuilds",z.name),K=DU(T).map(A$),H=K.filter(j$(MU,P$)),I=H.sort(E$(MU))[0];if(I)return X0.join(T,I.file)}};function DU(U){try{return R$.readdirSync(U)}catch($){return[]}}function M$(U,$){var J=DU(U).filter($);return J[0]&&X0.join(U,J[0])}function B$(U){return/\.node$/.test(U)}function L$(U){var $=U.split("-");if($.length!==2)return;var J=$[0],Q=$[1].split("+");if(!J)return;if(!Q.length)return;if(!Q.every(Boolean))return;return{name:U,platform:J,architectures:Q}}function _$(U,$){return function(J){if(J==null)return!1;if(J.platform!==U)return!1;return J.architectures.includes($)}}function w$(U,$){return U.architectures.length-$.architectures.length}function A$(U){var $=U.split("."),J=$.pop(),Q={file:U,specificity:0};if(J!=="node")return;for(var Y=0;Y<$.length;Y++){var Z=$[Y];if(Z==="node"||Z==="electron"||Z==="node-webkit")Q.runtime=Z;else if(Z==="napi")Q.napi=!0;else if(Z.slice(0,3)==="abi")Q.abi=Z.slice(3);else if(Z.slice(0,2)==="uv")Q.uv=Z.slice(2);else if(Z.slice(0,4)==="armv")Q.armv=Z.slice(4);else if(Z==="glibc"||Z==="musl")Q.libc=Z;else continue;Q.specificity++}return Q}function j$(U,$){return function(J){if(J==null)return!1;if(J.runtime&&J.runtime!==U&&!ZQ(J))return!1;if(J.abi&&J.abi!==$&&!J.napi)return!1;if(J.uv&&J.uv!==F$)return!1;if(J.armv&&J.armv!==NU)return!1;if(J.libc&&J.libc!==S$)return!1;return!0}}function ZQ(U){return U.runtime==="node"&&U.napi}function E$(U){return function($,J){if($.runtime!==J.runtime)return $.runtime===U?-1:1;else if($.abi!==J.abi)return $.abi?-1:1;else if($.specificity!==J.specificity)return $.specificity>J.specificity?-1:1;else return 0}}function GQ(){return!!(process.versions&&process.versions.nw)}function XQ(){if(process.versions&&process.versions.electron)return!0;if(process.env.ELECTRON_RUN_AS_NODE)return!0;return typeof window!=="undefined"&&window.process&&window.process.type==="renderer"}function qQ(U){return U==="linux"&&R$.existsSync("/etc/alpine-release")}$0.parseTags=A$;$0.matchTags=j$;$0.compareTags=E$;$0.parseTuple=L$;$0.matchTuple=_$;$0.compareTuples=w$});var k$=r((vY,FU)=>{var SU=typeof __webpack_require__==="function"?__non_webpack_require__:h;if(typeof SU.addon==="function")FU.exports=SU.addon.bind(SU);else FU.exports=C$()});var b$=r((RQ,I0)=>{var __dirname="/Users/maxim/Projects/Private/Sites/cryptit/node_modules/argon2",fY=h("node:assert"),{randomBytes:WQ,timingSafeEqual:zQ}=h("node:crypto"),{promisify:TQ}=h("node:util"),{deserialize:v$,serialize:KQ}=I$(),HQ=k$(),{hash:y$}=HQ(__dirname),VQ=TQ(WQ);RQ.argon2d=0;RQ.argon2i=1;RQ.argon2id=2;var v0=Object.freeze({argon2d:0,argon2i:1,argon2id:2}),IQ=Object.freeze({[v0.argon2d]:"argon2d",[v0.argon2i]:"argon2i",[v0.argon2id]:"argon2id"}),f$={hashLength:32,timeCost:3,memoryCost:65536,parallelism:4,type:2,version:19};async function PQ(U,$){let{raw:J,salt:Q,...Y}={...f$,...$};if(Y.hashLength>4294967295)throw new RangeError("Hash length is too large");if(Y.memoryCost>4294967295)throw new RangeError("Memory cost is too large");if(Y.timeCost>4294967295)throw new RangeError("Time cost is too large");if(Y.parallelism>16777215)throw new RangeError("Parallelism is too large");Q=Q??await VQ(16);let{hashLength:Z,secret:G=Buffer.alloc(0),type:X,version:q,memoryCost:W,timeCost:z,parallelism:T,associatedData:K=Buffer.alloc(0)}=Y,H=await y$({password:Buffer.from(U),salt:Q,secret:G,data:K,hashLength:Z,m:W,t:z,p:T,version:q,type:X});if(J)return H;return KQ({id:IQ[X],version:q,params:{m:W,t:z,p:T,...K.byteLength>0?{data:K}:{}},salt:Q,hash:H})}RQ.hash=PQ;function MQ(U,$={}){let{memoryCost:J,timeCost:Q,parallelism:Y,version:Z}={...f$,...$},{version:G,params:{m:X,t:q,p:W}}=v$(U);return+G!==+Z||+X!==+J||+q!==+Q||+W!==+Y}RQ.needsRehash=MQ;async function BQ(U,$,J={}){let{id:Q,...Y}=v$(U);if(!(Q in v0))return!1;let{version:Z=16,params:{m:G,t:X,p:q,data:W=""},salt:z,hash:T}=Y,{secret:K=Buffer.alloc(0)}=J;return zQ(await y$({password:Buffer.from($),salt:z,secret:K,data:Buffer.from(W,"base64"),hashLength:T.byteLength,m:+G,t:+X,p:+q,version:+Z,type:v0[Q]}),T)}RQ.verify=BQ});var sU=x0(nU(),1),{program:sQ,createCommand:rQ,createArgument:oQ,createOption:aQ,CommanderError:tQ,InvalidArgumentError:eQ,InvalidOptionArgumentError:UY,Command:rU,Argument:$Y,Option:K0,Help:JY}=sU.default;import{existsSync as EU,accessSync as vQ,constants as yQ,realpathSync as p$}from"node:fs";import{createReadStream as n$,createWriteStream as OU}from"node:fs";import{stdin as n,stdout as W0,stderr as d,exit as s}from"node:process";class e extends Error{constructor(U){super(U);Object.setPrototypeOf(this,new.target.prototype),this.name=new.target.name,this.stack=void 0}}class U0 extends e{}class w0 extends e{}class XU extends e{}class g0 extends e{}class S0 extends e{}class Y0 extends e{}class m0 extends e{}class p extends e{}class A0 extends e{}function oU(){return typeof process!=="undefined"&&typeof process.versions==="object"&&!0}function j0(...U){let $=U.reduce((Y,Z)=>Y+Z.byteLength,0),J=new Uint8Array($),Q=0;for(let Y of U)J.set(Y,Q),Q+=Y.byteLength;return J}function E0(...U){try{let $=j0(...U);if(oU())return Buffer.from($).toString("base64");let J="";for(let Q=0;Q<$.length;Q++)J+=String.fromCharCode($[Q]);return btoa(J)}catch{throw new XU("Base64 Encoding Error")}}function O0(U){try{if(!/^[A-Za-z0-9+/]+={0,2}$/.test(U)||U.length%4!==0)throw new Error("Invalid Base64");if(oU())return new Uint8Array(Buffer.from(U,"base64"));let $=atob(U),J=new Uint8Array($.length);for(let Q=0;Q<$.length;Q++)J[Q]=$.charCodeAt(Q);return J}catch{throw new w0(`Invalid Base64: length=${U.length}, content='${U.slice(0,12)}…'`)}}function a(U){let $=U.value.length,J=new Array($).fill("\x00").join("");U.value=J}function qU(U,$,J){if($<0||J<0||$+J>U)throw new RangeError("read() slice exceeds data bounds")}import{promises as fJ}from"fs";class WU{src;#U=null;constructor(U){this.src=U}get length(){if(this.src instanceof Uint8Array)return this.src.byteLength;if(this.src instanceof Blob)return this.src.size;return this.ensureUint8().byteLength}async read(U,$){if(qU(this.length,U,$),this.src instanceof Uint8Array)return this.src.slice(U,U+$);if(this.src instanceof Blob){let J=await this.src.slice(U,U+$).arrayBuffer();return new Uint8Array(J)}return this.ensureUint8().slice(U,U+$)}ensureUint8(){if(!this.#U)this.#U=O0(this.src);return this.#U}}class C0{fd;length;constructor(U,$){this.fd=U;this.length=$}static async open(U){let $=await fJ.open(U,"r"),J=await $.stat();return new C0($,J.size)}async read(U,$){qU(this.length,U,$);let J=Buffer.allocUnsafe($);return await this.fd.read(J,0,$,U),new Uint8Array(J)}async close(){await this.fd.close()}}class c{static byId=new Map;static register(U){if(this.byId.has(U.id))throw new g0(`Scheme ${U.id} already registered`);this.byId.set(U.id,U)}static get(U){let $=this.byId.get(U);if(!$)throw new g0(`Unknown scheme: ${U}`);return $}static get current(){return this.get(0)}}class H0{p;static IV_LENGTH=12;IV_LENGTH=H0.IV_LENGTH;key;constructor(U){this.p=U}async setKey(U){this.key=U}async encryptChunk(U){let $=this.p.getRandomValues(new Uint8Array(H0.IV_LENGTH)),J=new Uint8Array(await this.p.subtle.encrypt({name:"AES-GCM",iv:$},this.key,U));U.fill(0);let Q=new Uint8Array($.length+J.length);return Q.set($),Q.set(J,$.length),Q}async decryptChunk(U){let $=U.slice(0,H0.IV_LENGTH),J=U.slice(H0.IV_LENGTH);try{let Q=await this.p.subtle.decrypt({name:"AES-GCM",iv:$},this.key,J);return new Uint8Array(Q)}catch{throw new p("Decryption failed: wrong passphrase or corrupted ciphertext")}}zeroKey(){}}/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function tU(U){return U instanceof Uint8Array||ArrayBuffer.isView(U)&&U.constructor.name==="Uint8Array"}function u0(U){if(typeof U!=="boolean")throw new Error(`boolean expected, not ${U}`)}function l0(U){if(!Number.isSafeInteger(U)||U<0)throw new Error("positive integer expected, got "+U)}function l(U,...$){if(!tU(U))throw new Error("Uint8Array expected");if($.length>0&&!$.includes(U.length))throw new Error("Uint8Array expected of length "+$+", got length="+U.length)}function zU(U,$=!0){if(U.destroyed)throw new Error("Hash instance has been destroyed");if($&&U.finished)throw new Error("Hash#digest() has already been called")}function eU(U,$){l(U);let J=$.outputLen;if(U.length<J)throw new Error("digestInto() expects output buffer of length at least "+J)}function Z0(U){return new Uint32Array(U.buffer,U.byteOffset,Math.floor(U.byteLength/4))}function G0(...U){for(let $=0;$<U.length;$++)U[$].fill(0)}function bJ(U){return new DataView(U.buffer,U.byteOffset,U.byteLength)}var xJ=(()=>new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68)();function hJ(U){if(typeof U!=="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(U))}function c0(U){if(typeof U==="string")U=hJ(U);else if(tU(U))U=d0(U);else throw new Error("Uint8Array expected, got "+typeof U);return U}function U$(U,$){if($==null||typeof $!=="object")throw new Error("options must be defined");return Object.assign(U,$)}function $$(U,$){if(U.length!==$.length)return!1;let J=0;for(let Q=0;Q<U.length;Q++)J|=U[Q]^$[Q];return J===0}var TU=(U,$)=>{function J(Q,...Y){if(l(Q),!xJ)throw new Error("Non little-endian hardware is not yet supported");if(U.nonceLength!==void 0){let z=Y[0];if(!z)throw new Error("nonce / iv required");if(U.varSizeNonce)l(z);else l(z,U.nonceLength)}let Z=U.tagLength;if(Z&&Y[1]!==void 0)l(Y[1]);let G=$(Q,...Y),X=(z,T)=>{if(T!==void 0){if(z!==2)throw new Error("cipher output not supported");l(T)}},q=!1;return{encrypt(z,T){if(q)throw new Error("cannot encrypt() twice with same key + nonce");return q=!0,l(z),X(G.encrypt.length,T),G.encrypt(z,T)},decrypt(z,T){if(l(z),Z&&z.length<Z)throw new Error("invalid ciphertext length: smaller than tagLength="+Z);return X(G.decrypt.length,T),G.decrypt(z,T)}}}return Object.assign(J,U),J};function KU(U,$,J=!0){if($===void 0)return new Uint8Array(U);if($.length!==U)throw new Error("invalid output length, expected "+U+", got: "+$.length);if(J&&!gJ($))throw new Error("invalid output, must be aligned");return $}function aU(U,$,J,Q){if(typeof U.setBigUint64==="function")return U.setBigUint64($,J,Q);let Y=BigInt(32),Z=BigInt(4294967295),G=Number(J>>Y&Z),X=Number(J&Z),q=Q?4:0,W=Q?0:4;U.setUint32($+q,G,Q),U.setUint32($+W,X,Q)}function J$(U,$,J){u0(J);let Q=new Uint8Array(16),Y=bJ(Q);return aU(Y,0,BigInt($),J),aU(Y,8,BigInt(U),J),Q}function gJ(U){return U.byteOffset%4===0}function d0(U){return Uint8Array.from(U)}var Y$=(U)=>Uint8Array.from(U.split("").map(($)=>$.charCodeAt(0))),mJ=Y$("expand 16-byte k"),uJ=Y$("expand 32-byte k"),lJ=Z0(mJ),cJ=Z0(uJ);function V(U,$){return U<<$|U>>>32-$}function HU(U){return U.byteOffset%4===0}var p0=64,dJ=16,Z$=4294967295,Q$=new Uint32Array;function pJ(U,$,J,Q,Y,Z,G,X){let q=Y.length,W=new Uint8Array(p0),z=Z0(W),T=HU(Y)&&HU(Z),K=T?Z0(Y):Q$,H=T?Z0(Z):Q$;for(let I=0;I<q;G++){if(U($,J,Q,z,G,X),G>=Z$)throw new Error("arx: counter overflow");let M=Math.min(p0,q-I);if(T&&M===p0){let B=I/4;if(I%4!==0)throw new Error("arx: invalid block position");for(let R=0,N;R<dJ;R++)N=B+R,H[N]=K[N]^z[R];I+=p0;continue}for(let B=0,R;B<M;B++)R=I+B,Z[R]=Y[R]^W[B];I+=M}}function VU(U,$){let{allowShortKeys:J,extendNonceFn:Q,counterLength:Y,counterRight:Z,rounds:G}=U$({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},$);if(typeof U!=="function")throw new Error("core must be a function");return l0(Y),l0(G),u0(Z),u0(J),(X,q,W,z,T=0)=>{l(X),l(q),l(W);let K=W.length;if(z===void 0)z=new Uint8Array(K);if(l(z),l0(T),T<0||T>=Z$)throw new Error("arx: counter overflow");if(z.length<K)throw new Error(`arx: output (${z.length}) is shorter than data (${K})`);let H=[],I=X.length,M,B;if(I===32)H.push(M=d0(X)),B=cJ;else if(I===16&&J)M=new Uint8Array(32),M.set(X),M.set(X,16),B=lJ,H.push(M);else throw new Error(`arx: invalid 32-byte key, got length=${I}`);if(!HU(q))H.push(q=d0(q));let R=Z0(M);if(Q){if(q.length!==24)throw new Error("arx: extended nonce must be 24 bytes");Q(B,R,Z0(q.subarray(0,16)),R),q=q.subarray(16)}let N=16-Y;if(N!==q.length)throw new Error(`arx: nonce must be ${N} or 16 bytes`);if(N!==12){let x=new Uint8Array(12);x.set(q,Z?0:12-q.length),q=x,H.push(q)}let y=Z0(q);return pJ(U,B,R,y,W,z,T,G),G0(...H),z}}var g=(U,$)=>U[$++]&255|(U[$++]&255)<<8;class G${constructor(U){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,U=c0(U),l(U,32);let $=g(U,0),J=g(U,2),Q=g(U,4),Y=g(U,6),Z=g(U,8),G=g(U,10),X=g(U,12),q=g(U,14);this.r[0]=$&8191,this.r[1]=($>>>13|J<<3)&8191,this.r[2]=(J>>>10|Q<<6)&7939,this.r[3]=(Q>>>7|Y<<9)&8191,this.r[4]=(Y>>>4|Z<<12)&255,this.r[5]=Z>>>1&8190,this.r[6]=(Z>>>14|G<<2)&8191,this.r[7]=(G>>>11|X<<5)&8065,this.r[8]=(X>>>8|q<<8)&8191,this.r[9]=q>>>5&127;for(let W=0;W<8;W++)this.pad[W]=g(U,16+2*W)}process(U,$,J=!1){let Q=J?0:2048,{h:Y,r:Z}=this,G=Z[0],X=Z[1],q=Z[2],W=Z[3],z=Z[4],T=Z[5],K=Z[6],H=Z[7],I=Z[8],M=Z[9],B=g(U,$+0),R=g(U,$+2),N=g(U,$+4),y=g(U,$+6),x=g(U,$+8),z0=g(U,$+10),m=g(U,$+12),u=g(U,$+14),D=Y[0]+(B&8191),S=Y[1]+((B>>>13|R<<3)&8191),F=Y[2]+((R>>>10|N<<6)&8191),L=Y[3]+((N>>>7|y<<9)&8191),_=Y[4]+((y>>>4|x<<12)&8191),w=Y[5]+(x>>>1&8191),A=Y[6]+((x>>>14|z0<<2)&8191),j=Y[7]+((z0>>>11|m<<5)&8191),E=Y[8]+((m>>>8|u<<8)&8191),O=Y[9]+(u>>>5|Q),P=0,v=P+D*G+S*(5*M)+F*(5*I)+L*(5*H)+_*(5*K);P=v>>>13,v&=8191,v+=w*(5*T)+A*(5*z)+j*(5*W)+E*(5*q)+O*(5*X),P+=v>>>13,v&=8191;let f=P+D*X+S*G+F*(5*M)+L*(5*I)+_*(5*H);P=f>>>13,f&=8191,f+=w*(5*K)+A*(5*T)+j*(5*z)+E*(5*W)+O*(5*q),P+=f>>>13,f&=8191;let b=P+D*q+S*X+F*G+L*(5*M)+_*(5*I);P=b>>>13,b&=8191,b+=w*(5*H)+A*(5*K)+j*(5*T)+E*(5*z)+O*(5*W),P+=b>>>13,b&=8191;let k=P+D*W+S*q+F*X+L*G+_*(5*M);P=k>>>13,k&=8191,k+=w*(5*I)+A*(5*H)+j*(5*K)+E*(5*T)+O*(5*z),P+=k>>>13,k&=8191;let J0=P+D*z+S*W+F*q+L*X+_*G;P=J0>>>13,J0&=8191,J0+=w*(5*M)+A*(5*I)+j*(5*H)+E*(5*K)+O*(5*T),P+=J0>>>13,J0&=8191;let M0=P+D*T+S*z+F*W+L*q+_*X;P=M0>>>13,M0&=8191,M0+=w*G+A*(5*M)+j*(5*I)+E*(5*H)+O*(5*K),P+=M0>>>13,M0&=8191;let B0=P+D*K+S*T+F*z+L*W+_*q;P=B0>>>13,B0&=8191,B0+=w*X+A*G+j*(5*M)+E*(5*I)+O*(5*H),P+=B0>>>13,B0&=8191;let R0=P+D*H+S*K+F*T+L*z+_*W;P=R0>>>13,R0&=8191,R0+=w*q+A*X+j*G+E*(5*M)+O*(5*I),P+=R0>>>13,R0&=8191;let N0=P+D*I+S*H+F*K+L*T+_*z;P=N0>>>13,N0&=8191,N0+=w*W+A*q+j*X+E*G+O*(5*M),P+=N0>>>13,N0&=8191;let D0=P+D*M+S*I+F*H+L*K+_*T;P=D0>>>13,D0&=8191,D0+=w*z+A*W+j*q+E*X+O*G,P+=D0>>>13,D0&=8191,P=(P<<2)+P|0,P=P+v|0,v=P&8191,P=P>>>13,f+=P,Y[0]=v,Y[1]=f,Y[2]=b,Y[3]=k,Y[4]=J0,Y[5]=M0,Y[6]=B0,Y[7]=R0,Y[8]=N0,Y[9]=D0}finalize(){let{h:U,pad:$}=this,J=new Uint16Array(10),Q=U[1]>>>13;U[1]&=8191;for(let G=2;G<10;G++)U[G]+=Q,Q=U[G]>>>13,U[G]&=8191;U[0]+=Q*5,Q=U[0]>>>13,U[0]&=8191,U[1]+=Q,Q=U[1]>>>13,U[1]&=8191,U[2]+=Q,J[0]=U[0]+5,Q=J[0]>>>13,J[0]&=8191;for(let G=1;G<10;G++)J[G]=U[G]+Q,Q=J[G]>>>13,J[G]&=8191;J[9]-=8192;let Y=(Q^1)-1;for(let G=0;G<10;G++)J[G]&=Y;Y=~Y;for(let G=0;G<10;G++)U[G]=U[G]&Y|J[G];U[0]=(U[0]|U[1]<<13)&65535,U[1]=(U[1]>>>3|U[2]<<10)&65535,U[2]=(U[2]>>>6|U[3]<<7)&65535,U[3]=(U[3]>>>9|U[4]<<4)&65535,U[4]=(U[4]>>>12|U[5]<<1|U[6]<<14)&65535,U[5]=(U[6]>>>2|U[7]<<11)&65535,U[6]=(U[7]>>>5|U[8]<<8)&65535,U[7]=(U[8]>>>8|U[9]<<5)&65535;let Z=U[0]+$[0];U[0]=Z&65535;for(let G=1;G<8;G++)Z=(U[G]+$[G]|0)+(Z>>>16)|0,U[G]=Z&65535;G0(J)}update(U){zU(this),U=c0(U),l(U);let{buffer:$,blockLen:J}=this,Q=U.length;for(let Y=0;Y<Q;){let Z=Math.min(J-this.pos,Q-Y);if(Z===J){for(;J<=Q-Y;Y+=J)this.process(U,Y);continue}if($.set(U.subarray(Y,Y+Z),this.pos),this.pos+=Z,Y+=Z,this.pos===J)this.process($,0,!1),this.pos=0}return this}destroy(){G0(this.h,this.r,this.buffer,this.pad)}digestInto(U){zU(this),eU(U,this),this.finished=!0;let{buffer:$,h:J}=this,{pos:Q}=this;if(Q){$[Q++]=1;for(;Q<16;Q++)$[Q]=0;this.process($,0,!0)}this.finalize();let Y=0;for(let Z=0;Z<8;Z++)U[Y++]=J[Z]>>>0,U[Y++]=J[Z]>>>8;return U}digest(){let{buffer:U,outputLen:$}=this;this.digestInto(U);let J=U.slice(0,$);return this.destroy(),J}}function iJ(U){let $=(Q,Y)=>U(Y).update(c0(Q)).digest(),J=U(new Uint8Array(32));return $.outputLen=J.outputLen,$.blockLen=J.blockLen,$.create=(Q)=>U(Q),$}var X$=iJ((U)=>new G$(U));function z$(U,$,J,Q,Y,Z=20){let G=U[0],X=U[1],q=U[2],W=U[3],z=$[0],T=$[1],K=$[2],H=$[3],I=$[4],M=$[5],B=$[6],R=$[7],N=Y,y=J[0],x=J[1],z0=J[2],m=G,u=X,D=q,S=W,F=z,L=T,_=K,w=H,A=I,j=M,E=B,O=R,P=N,v=y,f=x,b=z0;for(let J0=0;J0<Z;J0+=2)m=m+F|0,P=V(P^m,16),A=A+P|0,F=V(F^A,12),m=m+F|0,P=V(P^m,8),A=A+P|0,F=V(F^A,7),u=u+L|0,v=V(v^u,16),j=j+v|0,L=V(L^j,12),u=u+L|0,v=V(v^u,8),j=j+v|0,L=V(L^j,7),D=D+_|0,f=V(f^D,16),E=E+f|0,_=V(_^E,12),D=D+_|0,f=V(f^D,8),E=E+f|0,_=V(_^E,7),S=S+w|0,b=V(b^S,16),O=O+b|0,w=V(w^O,12),S=S+w|0,b=V(b^S,8),O=O+b|0,w=V(w^O,7),m=m+L|0,b=V(b^m,16),E=E+b|0,L=V(L^E,12),m=m+L|0,b=V(b^m,8),E=E+b|0,L=V(L^E,7),u=u+_|0,P=V(P^u,16),O=O+P|0,_=V(_^O,12),u=u+_|0,P=V(P^u,8),O=O+P|0,_=V(_^O,7),D=D+w|0,v=V(v^D,16),A=A+v|0,w=V(w^A,12),D=D+w|0,v=V(v^D,8),A=A+v|0,w=V(w^A,7),S=S+F|0,f=V(f^S,16),j=j+f|0,F=V(F^j,12),S=S+F|0,f=V(f^S,8),j=j+f|0,F=V(F^j,7);let k=0;Q[k++]=G+m|0,Q[k++]=X+u|0,Q[k++]=q+D|0,Q[k++]=W+S|0,Q[k++]=z+F|0,Q[k++]=T+L|0,Q[k++]=K+_|0,Q[k++]=H+w|0,Q[k++]=I+A|0,Q[k++]=M+j|0,Q[k++]=B+E|0,Q[k++]=R+O|0,Q[k++]=N+P|0,Q[k++]=y+v|0,Q[k++]=x+f|0,Q[k++]=z0+b|0}function nJ(U,$,J,Q){let Y=U[0],Z=U[1],G=U[2],X=U[3],q=$[0],W=$[1],z=$[2],T=$[3],K=$[4],H=$[5],I=$[6],M=$[7],B=J[0],R=J[1],N=J[2],y=J[3];for(let z0=0;z0<20;z0+=2)Y=Y+q|0,B=V(B^Y,16),K=K+B|0,q=V(q^K,12),Y=Y+q|0,B=V(B^Y,8),K=K+B|0,q=V(q^K,7),Z=Z+W|0,R=V(R^Z,16),H=H+R|0,W=V(W^H,12),Z=Z+W|0,R=V(R^Z,8),H=H+R|0,W=V(W^H,7),G=G+z|0,N=V(N^G,16),I=I+N|0,z=V(z^I,12),G=G+z|0,N=V(N^G,8),I=I+N|0,z=V(z^I,7),X=X+T|0,y=V(y^X,16),M=M+y|0,T=V(T^M,12),X=X+T|0,y=V(y^X,8),M=M+y|0,T=V(T^M,7),Y=Y+W|0,y=V(y^Y,16),I=I+y|0,W=V(W^I,12),Y=Y+W|0,y=V(y^Y,8),I=I+y|0,W=V(W^I,7),Z=Z+z|0,B=V(B^Z,16),M=M+B|0,z=V(z^M,12),Z=Z+z|0,B=V(B^Z,8),M=M+B|0,z=V(z^M,7),G=G+T|0,R=V(R^G,16),K=K+R|0,T=V(T^K,12),G=G+T|0,R=V(R^G,8),K=K+R|0,T=V(T^K,7),X=X+q|0,N=V(N^X,16),H=H+N|0,q=V(q^H,12),X=X+q|0,N=V(N^X,8),H=H+N|0,q=V(q^H,7);let x=0;Q[x++]=Y,Q[x++]=Z,Q[x++]=G,Q[x++]=X,Q[x++]=B,Q[x++]=R,Q[x++]=N,Q[x++]=y}var sJ=VU(z$,{counterRight:!1,counterLength:4,allowShortKeys:!1}),rJ=VU(z$,{counterRight:!1,counterLength:8,extendNonceFn:nJ,allowShortKeys:!1});var oJ=new Uint8Array(16),q$=(U,$)=>{U.update($);let J=$.length%16;if(J)U.update(oJ.subarray(J))},aJ=new Uint8Array(32);function W$(U,$,J,Q,Y){let Z=U($,J,aJ),G=X$.create(Z);if(Y)q$(G,Y);q$(G,Q);let X=J$(Q.length,Y?Y.length:0,!0);G.update(X);let q=G.digest();return G0(Z,X),q}var T$=(U)=>($,J,Q)=>{return{encrypt(Z,G){let X=Z.length;G=KU(X+16,G,!1),G.set(Z);let q=G.subarray(0,-16);U($,J,q,q,1);let W=W$(U,$,J,q,Q);return G.set(W,X),G0(W),G},decrypt(Z,G){G=KU(Z.length-16,G,!1);let X=Z.subarray(0,-16),q=Z.subarray(-16),W=W$(U,$,J,X,Q);if(!$$(q,W))throw new Error("invalid tag");return G.set(Z.subarray(0,-16)),U($,J,G,G,1),G0(W),G}}},_Y=TU({blockSize:64,nonceLength:12,tagLength:16},T$(sJ)),IU=TU({blockSize:64,nonceLength:24,tagLength:16},T$(rJ));class V0{p;static IV_LENGTH=24;IV_LENGTH=V0.IV_LENGTH;key;constructor(U){this.p=U}async setKey(U){this.key=new Uint8Array(await this.p.subtle.exportKey("raw",U))}async encryptChunk(U){let $=this.p.getRandomValues(new Uint8Array(V0.IV_LENGTH)),Q=IU(this.key,$).encrypt(U);U.fill(0);let Y=new Uint8Array($.length+Q.length);return Y.set($,0),Y.set(Q,$.length),Y}async decryptChunk(U){let $=U.slice(0,V0.IV_LENGTH),J=U.slice(V0.IV_LENGTH),Q=IU(this.key,$);try{return Q.decrypt(J)}catch{throw new p("Decryption failed: wrong passphrase or corrupted ciphertext")}}zeroKey(){this.key.fill(0)}}import*as r0 from"argon2-browser";async function wQ(){if(typeof window!=="undefined")return;if(globalThis.loadArgon2WasmModule)return;try{let{createRequire:U}=await import("node:module"),{readFile:$}=await import("node:fs/promises"),J=U(import.meta.url),Q=J.resolve("argon2-browser/dist/argon2.js"),Y=J.resolve("argon2-browser/dist/argon2.wasm");globalThis.loadArgon2WasmModule=async()=>{let Z=new Uint8Array(await $(Y));return globalThis.Module={wasmBinary:Z,locateFile:(G)=>G==="argon2.wasm"?Y:G},J(Q)}}catch{}}async function x$(U,$,J,Q){if(Q==="node"){let Y=await Promise.resolve().then(() => x0(b$(),1)),Z=typeof U==="string"?Buffer.from(U,"utf8"):Buffer.from(U),G=Buffer.from($),X=await Y.hash(Z,{salt:G,timeCost:J.time,memoryCost:J.mem,parallelism:J.parallelism,hashLength:32,raw:!0,type:Y.argon2id});return G.fill(0),Z.fill(0),{hash:new Uint8Array(X)}}if(Q==="browser")return await wQ(),r0.hash({pass:U,salt:$,time:J.time,mem:J.mem,parallelism:J.parallelism,hashLen:32,type:r0.ArgonType.Argon2id}).then((Y)=>{if(!Y||!Y.hash)throw new Y0("Failed to produce key derivation");return{hash:Y.hash}}).catch((Y)=>{let Z=Y instanceof Error?Y.message:typeof Y==="string"?Y:"Unknown error";throw new Y0(`argon2-browser failure: ${Z}`)});throw new Error(`Unsupported environment: ${Q}`)}class o0{presets;exportExtractable;name="argon2id";constructor(U,$=!1){this.presets=U;this.exportExtractable=$}async derive(U,$,J,Q){let{hash:Y}=await x$(U,$,this.presets[J],Q.isNode?"node":"browser");if(this.exportExtractable)return Q.subtle.importKey("raw",Y,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]);else return Q.subtle.importKey("raw",Y,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}}var h$={low:{time:5,mem:65536,parallelism:1},middle:{time:20,mem:65536,parallelism:1},high:{time:40,mem:65536,parallelism:1}},AQ={id:0,cipher:H0,kdf:new o0(h$),saltLengths:{low:12,high:16},difficulties:h$,defaultChunkSize:524288};c.register(AQ);var g$={low:{time:5,mem:65536,parallelism:2},middle:{time:10,mem:98304,parallelism:4},high:{time:20,mem:98304,parallelism:4}},jQ={id:1,cipher:V0,kdf:new o0(g$,!0),saltLengths:{low:12,high:16},difficulties:g$,defaultChunkSize:524288};c.register(jQ);var a0=1;function y0(U,$,J,Q){let Y={low:0,middle:1,high:2};if(!($ in Y))throw new TypeError(`Unsupported difficulty: ${$}`);let Z=Y[$],G=U<<5|(J==="high"?1:0)<<2|Z;return j0(new Uint8Array([a0,G]),Q)}function P0(U){if(U[0]!==a0)throw new U0("Invalid input format. The input is unknown.");if(U.length<14)throw new U0("Invalid input format. Header too short.");try{let $=U[1],J=$>>5,Q=$>>2&1?"high":"low",Y=$&3,Z=["low","middle","high"][Y],G=c.get(J).saltLengths[Q],X=U.slice(2,2+G);return{scheme:J,difficulty:Z,saltStrength:Q,salt:X,headerLen:2+G}}catch($){throw new S0($ instanceof Error?$.message:String($))}}async function t0(U){if(U instanceof Uint8Array)return U;if(U instanceof ArrayBuffer)return new Uint8Array(U);return new Uint8Array(await U.arrayBuffer())}function LU(U){let $=new Uint8Array(4);return new DataView($.buffer).setUint32(0,U,!1),$}function m$(U,$=0){if(U.length-$<4)throw new RangeError("Not enough bytes for frame header");return new DataView(U.buffer,U.byteOffset+$,4).getUint32(0,!1)}var q0=4;class f0{engine;chunkSize;buffer=new Uint8Array(0);constructor(U,$=524288){this.engine=U;this.chunkSize=$}toTransformStream(){return new TransformStream({transform:async(U,$)=>{await this.transform(await t0(U),$)},flush:async(U)=>this.flush(U)})}async transform(U,$){if(U.length>this.chunkSize*4)throw new RangeError(`Input block (${U.length} B) exceeds sane limit`);let J=new Uint8Array(this.buffer.length+U.length);J.set(this.buffer),J.set(U,this.buffer.length);let Q=0;while(J.length-Q>=this.chunkSize){let Y=J.slice(Q,Q+this.chunkSize);Q+=this.chunkSize;let Z=await this.engine.encryptChunk(Y),G=new Uint8Array(q0+Z.length);G.set(LU(Z.length)),G.set(Z,q0),$.enqueue(G)}this.buffer=J.slice(Q)}async flush(U){if(!this.buffer.length)return;let $=await this.engine.encryptChunk(this.buffer),J=new Uint8Array(q0+$.length);J.set(LU($.length)),J.set($,q0),U.enqueue(J),this.buffer=new Uint8Array(0),this.engine.zeroKey()}}class F0{engine;chunkSize;buffer=new Uint8Array(0);constructor(U,$=524288){this.engine=U;this.chunkSize=$}toTransformStream(){return new TransformStream({transform:async(U,$)=>{await this.transform(await t0(U),$)},flush:async(U)=>this.flush(U)})}async transform(U,$){let J=new Uint8Array(this.buffer.length+U.length);J.set(this.buffer),J.set(U,this.buffer.length);let Q=0;while(!0){if(J.length-Q<q0)break;let Y=m$(J,Q);if(Y>this.chunkSize*2)throw new p(`Frame length ${Y} exceeds …`);if(J.length-Q-q0<Y)break;Q+=q0;let Z=J.slice(Q,Q+Y);Q+=Y;try{let G=await this.engine.decryptChunk(Z);$.enqueue(G)}catch(G){throw G instanceof p?G:new p("Decryption failed: Wrong passphrase or corrupted ciphertext")}}this.buffer=J.slice(Q)}async flush(U){await this.transform(new Uint8Array(0),U),this.buffer=new Uint8Array(0),this.engine.zeroKey()}}async function u$(U,$){let J=U.getReader(),Q=$&&$.length?[$]:[];try{while(!0){let{value:X,done:q}=await J.read();if(q)break;Q.push(X)}}finally{J.releaseLock()}let Y=Q.reduce((X,q)=>X+q.byteLength,0),Z=new Uint8Array(Y),G=0;for(let X of Q)Z.set(X,G),G+=X.byteLength;return Z}class L0{engine;chunkSize;constructor(U,$=524288){this.engine=U;this.chunkSize=$}encryptionStream(){let U=new f0(this.engine,this.chunkSize).toTransformStream();return{writable:U.writable,readable:U.readable}}decryptionStream(U){let $=U,J=new TransformStream({transform(Y,Z){if($===0){Z.enqueue(Y);return}if(Y.byteLength<=$){$-=Y.byteLength;return}Z.enqueue(Y.slice($)),$=0}}),Q=new F0(this.engine,this.chunkSize).toTransformStream();return{writable:J.writable,readable:J.readable.pipeThrough(Q)}}async collect(U,$,J=null){return u$(U.pipeThrough($),J??void 0)}}function l$(U=0,$=console.info){return{level:U,log(J,Q){if(J<=U)$(`${J}| ${Q}`)}}}var c$=new WeakMap;class T0{static getEngine(U,$){let J=c$.get(U);if(!J)J=new Map,c$.set(U,J);let Q=J.get($);if(Q)return Q;let Y=c.get($);return Q={desc:Y,cipher:new Y.cipher(U),kdf:Y.kdf,chunkSize:Y.defaultChunkSize,provider:U},J.set($,Q),Q}static async deriveKey(U,$,J,Q){try{let Y=await U.kdf.derive($.value,J,Q,U.provider);await U.cipher.setKey(Y)}catch(Y){let Z=Y instanceof Error?Y.message:String(Y);throw new Y0(Z)}finally{a($)}}}class i{provider;v;cipher;kdf;chunkSize;stream;difficulty;saltStrength;engines=new Map;log;constructor(U,$={}){this.provider=U;this.v=c.get($.scheme??c.current.id),this.cipher=new this.v.cipher(U),this.kdf=this.v.kdf,this.chunkSize=this.setChunkSize($.chunkSize??this.v.defaultChunkSize),this.stream=new L0(this.cipher,this.chunkSize),this.difficulty=$.difficulty??"middle",this.saltStrength=$.saltStrength??"high",this.log=l$($.verbose??0,$.logger)}static async isEncrypted(U){try{return await i.peekHeader(U),!0}catch{return!1}}static async headerDecode(U){let $=await i.peekHeader(U),J=P0($);return{scheme:J.scheme,difficulty:J.difficulty,salt:E0(J.salt),saltLength:J.salt.byteLength}}static async decodeData(U){let $=typeof U?.read==="function"?U:new WU(U),J=await $.read(0,Math.min(256,$.length)),Q=await i.peekHeader(J),{scheme:Y,headerLen:Z}=P0(Q),G=$.length,X=G-Z;if(X<=0)throw new U0("Payload is empty");let q=await $.read(Z,4),W=new DataView(q.buffer,q.byteOffset,4).getUint32(0,!1);if(W+4<=X&&W>=28){let H=W,I=Z,M=0,B=0;while(I+4<=G){let R=await $.read(I,4),N=new DataView(R.buffer,R.byteOffset,4).getUint32(0,!1);if(N===0||I+4+N>G)break;M++,B+=N,I+=4+N}return{isChunked:!0,chunks:{chunkSize:H,count:M,totalPayload:B}}}let T=await $.read(Z,X),K=c.get(Y).cipher.IV_LENGTH;if(T.length<K+16)throw new U0("Ciphertext too short for IV & tag");return{isChunked:!1,payloadLength:X,params:{iv:T.slice(0,K),tag:T.slice(T.length-16)}}}setDifficulty(U){this.difficulty=U}getDifficulty(){return this.difficulty}setScheme(U){this.v=c.get(U),this.cipher=new this.v.cipher(this.provider),this.kdf=this.v.kdf,this.stream=new L0(this.cipher,this.chunkSize)}getScheme(){return this.v.id}setSaltDifficulty(U){this.saltStrength=U}getSaltDifficulty(){return this.saltStrength}setChunkSize(U){let $=U,J;if($==null)J=this.v.defaultChunkSize;else if(J=Number($),!Number.isInteger(J)||J<1)throw new Error(`Invalid chunkSize: ${$}. Must be a positive integer.`);return this.chunkSize=J,this.stream=new L0(this.cipher,this.chunkSize),J}getChunkSize(){return this.chunkSize}setVerbose(U){this.log.level=U}getVerbose(){return this.log.level}async encryptText(U,$){let J={value:$};try{this.log.log(1,`Start text encryption, scheme: ${this.getScheme()}`),this.log.log(2,"Deriving key for text encryption");let Q=this.genSalt();await this.deriveKey(J,Q),a(J),$=null,this.log.log(3,`Salt generated: ${E0(Q)}, KDF difficulty: ${this.difficulty}`),this.log.log(2,"Encrypting text data");let Y=await this.cipher.encryptChunk(typeof U==="string"?new TextEncoder().encode(U):U);this.cipher.zeroKey(),this.log.log(3,"Encoding header");let Z=y0(this.v.id,this.difficulty,this.saltStrength,Q);this.log.log(3,"Encoding text");let G=E0(Z,Y);return this.log.log(1,"Decryption finished"),G}catch(Q){throw new m0(Q instanceof Error?Q.message:String(Q))}}async decryptText(U,$){let J={value:$};try{this.log.log(1,`Start text decryption, Version ${this.getScheme()}`),this.log.log(3,"Start text decoding");let Q=O0(U);this.log.log(3,"Start header decoding"),await i.peekHeader(U);let Y=P0(Q);this.log.log(3,"Trying to get engine");let Z=T0.getEngine(this.provider,Y.scheme);this.log.log(2,`Deriving key via engine for scheme: ${Y.scheme}`),this.log.log(3,`Salt use: ${E0(Y.salt)}, KDF difficulty: ${Y.difficulty}`);try{await T0.deriveKey(Z,J,Y.salt,Y.difficulty)}finally{a(J),$=null}this.log.log(2,"Decrypting text data");let G=await Z.cipher.decryptChunk(Q.slice(Y.headerLen));Z.cipher.zeroKey(),this.log.log(3,"Decoding text");let X=new TextDecoder().decode(G);return this.log.log(1,"Decryption finished"),X}catch(Q){if(Q instanceof p||Q instanceof U0||Q instanceof S0||Q instanceof w0||Q instanceof Y0)throw Q;throw new p("Decryption failed: wrong passphrase or corrupted ciphertext")}}async encryptFile(U,$){let J={value:$};try{if(U.size===0){let G=this.genSalt();await this.deriveKey(J,G),a(J),$=null;let X=y0(this.v.id,this.difficulty,this.saltStrength,G);return new Blob([X],{type:"application/octet-stream"})}this.log.log(2,"Deriving key for file encryption");let Q=this.genSalt();await this.deriveKey(J,Q),a(J),$=null;let Y=y0(this.v.id,this.difficulty,this.saltStrength,Q),Z=await this.stream.collect(U.stream(),new f0(this.cipher,this.chunkSize).toTransformStream(),Y);return new Blob([Z],{type:"application/octet-stream"})}catch(Q){throw new m0(Q instanceof Error?Q.message:String(Q))}}async decryptFile(U,$){let J={value:$};try{let Q=await i.peekHeader(U),Y=P0(Q),Z=T0.getEngine(this.provider,Y.scheme);try{await T0.deriveKey(Z,J,Y.salt,Y.difficulty)}finally{a(J),$=null}if(U.size===Y.headerLen)return new Blob([],{type:"application/octet-stream"});this.log.log(2,"Decrypting file data");let X=await new L0(Z.cipher,Z.chunkSize).collect(U.slice(Y.headerLen).stream(),new F0(Z.cipher,Z.chunkSize).toTransformStream());return new Blob([X],{type:"application/octet-stream"})}catch(Q){if(Q instanceof p)throw Q;throw new p(Q instanceof Error?Q.message:String(Q))}}async createEncryptionStream(U){let $={value:U};this.log.log(2,"Deriving key for stream encryption");let J=this.genSalt();await this.deriveKey($,J),a($),U=null;let Q=y0(this.v.id,this.difficulty,this.saltStrength,J),Y=this.stream.encryptionStream();return{header:Q,writable:Y.writable,readable:Y.readable}}async createDecryptionStream(U){let $={value:U},J=this,Q=new Uint8Array(0),Y=null;async function Z(G,X){let q=G.getReader();while(!0){let{value:W,done:z}=await q.read();if(z)break;X.enqueue(W)}}return new TransformStream({async transform(G,X){if(!Y){if(Q=j0(Q,G),Q.length<2)return;let W=Q.slice(0,30),{salt:z,difficulty:T}=P0(W),K=Q[1]>>5,H=Q[1]>>2&1?"high":"low",M=2+c.get(K).saltLengths[H];if(Q.length<M)return;let B=T0.getEngine(J.provider,K);try{await T0.deriveKey(B,$,z,T)}finally{a($),U=null}Y=new F0(B.cipher,B.chunkSize).toTransformStream(),Z(Y.readable,X).catch((N)=>{X.error(N)});let R=Q.slice(M);if(R.length){let N=Y.writable.getWriter();await N.write(R),N.releaseLock()}return}let q=Y.writable.getWriter();await q.write(G),q.releaseLock()},async flush(){if(Y){let G=Y.writable.getWriter();await G.close(),G.releaseLock()}}})}async deriveKey(U,$,J=this.difficulty){let Q=performance.now();try{let Y=await this.kdf.derive(U.value,$,J,this.provider);a(U),await this.cipher.setKey(Y),this.log.log(3,`Key derivation completed in ${(performance.now()-Q).toFixed(1)} ms`)}catch(Y){throw new Y0(Y instanceof Error?Y.message:String(Y))}}genSalt(U=this.saltStrength){let $=this.v.saltLengths[this.saltStrength];return this.provider.getRandomValues(new Uint8Array($))}static async peekHeader(U){let $=await this.readAsUint8(U);if($ instanceof Uint8Array){if($.length<2)throw new U0("Input too short");let{headerLen:J}=P0($.length>=16?$:Uint8Array.from($));if($.length<J)throw new U0("Incomplete header");return $.slice(0,J)}throw new S0("Unsupported input type")}static async readAsUint8(U){if(typeof U==="string")return O0(U);if(U instanceof Blob){let $=U.slice(0,64);return new Uint8Array(await $.arrayBuffer())}return U}}import{webcrypto as EQ,randomFillSync as OQ}from"node:crypto";var d$={subtle:EQ.subtle,getRandomValues(U){return OQ(U),U},isNode:!0};function b0(U){return new i(d$,U)}import{dirname as fQ,resolve as i$,sep as bQ,isAbsolute as xQ}from"node:path";import{Readable as CQ,Writable as kQ}from"node:stream";function _U(U){return CQ.toWeb(U)}function wU(U){return kQ.toWeb(U)}import{promises as AU}from"fs";import*as o$ from"os";import*as jU from"path";var hQ="0.2.14",gQ=process.cwd();async function e0(){if(!n.isTTY)throw new Error("STDIN not a TTY; use --pass");d.write("Passphrase: "),n.setRawMode?.(!0),n.resume(),n.setEncoding("utf8");let U="";return new Promise(($)=>{function J(){n.setRawMode?.(!1),n.pause(),d.write(`
`),n.off("data",Q),$(U)}function Q(Y){if(Y==="\x03")s(130);if(Y==="\r"||Y===`
`)return J();if(Y==="\b"||Y===""){U=U.slice(0,-1);return}U+=Y}n.on("data",Q)})}function s$(U,$=gQ){if(U==="-")return;let J=p$($),Q=xQ(U)?i$(U):i$(J,U),Y=fQ(Q);if(!p$(Y).startsWith(J+bQ))throw new A0("Refusing to write outside of root directory.");if(!EU(Y))throw new A0(`Output directory does not exist: ${Y}`);try{vQ(Y,yQ.W_OK)}catch{throw new A0("Output directory is not writeable")}return Q}async function r$(){let U=[];for await(let $ of n)U.push($);return Buffer.concat(U).toString("utf8")}var t=new rU;t.name("cryptit").version(hQ).description(`Text and File Encryption Utility
Scheme 0: AES-GCM (Native) / Argon2id (Single Thread)
Scheme 1: XChaCha20-Poly1305 (JS Engine) / Argon2id (Parallel)`).addOption(new K0("-S, --scheme <0-1>","encryption scheme version").argParser((U)=>{let $=Number(U);if(!Number.isInteger($)||$<0||$>7)throw new Error("Version size must be a integer between 0 and 7");return $}).default(0,"0")).addOption(new K0("-p, --pass <passphrase>","passphrase (prompt if omitted)").hideHelp().argParser((U)=>{if(!U.trim())throw new Error("Passphrase cannot be empty");return U})).addOption(new K0("-d, --difficulty <level>","argon2 difficulty").choices(["low","middle","high"]).default("middle","middle")).addOption(new K0("-s, --salt-strength <variant>","salt length variant").choices(["low","high"]).default("high","high")).addOption(new K0("-c, --chunk-size <bytes>","chunk size in bytes").argParser((U)=>{let $=Number(U);if(!Number.isInteger($)||$<=0)throw new Error("Chunk size must be a positive integer");return $}).default(524288,"512*1024")).addOption(new K0("-v, --verbose","increase verbosity (use multiple times)").default(0).argParser((U,$)=>{return $+1}));process.on("uncaughtException",(U)=>{if(U instanceof Error){let $=U.constructor.name,J=U.message;d.write(`Error [${$}]: ${J}
`)}else d.write(`Error [Unknown]: ${String(U)}
`);s(1)});process.on("unhandledRejection",(U)=>{if(U instanceof Error){let $=U.constructor.name,J=U.message;d.write(`Error [${$}]: ${J}
`)}else d.write(`Error [Unknown]: ${String(U)}
`);s(1)});t.command("decode [src]").description("Show Cryptit header information plus payload details; omit arg or use - to read from STDIN").action(async(U)=>{let $=!U||U==="-";async function J(q){if(q.length<2)throw new Error("Input too short for header");let W=q.subarray(0,Math.min(256,q.length)),z=await i.headerDecode(W),T=await i.decodeData(q);if(T.isChunked){let{chunkSize:I,count:M,totalPayload:B}=T.chunks;return{...z,isChunked:!0,chunks:{chunkSize:I,count:M,totalPayload:B}}}let K=Buffer.from(T.params.iv).toString("base64"),H=Buffer.from(T.params.tag).toString("base64");return{...z,isChunked:!1,payloadLength:T.payloadLength,params:{iv:K,tag:H}}}async function Q(q){let W=await q.read(0,Math.min(256,q.length)),z=await i.headerDecode(W),T=await i.decodeData(q);if(T.isChunked){let{chunkSize:I,count:M,totalPayload:B}=T.chunks;return{...z,isChunked:!0,chunks:{chunkSize:I,count:M,totalPayload:B}}}let K=Buffer.from(T.params.iv).toString("base64"),H=Buffer.from(T.params.tag).toString("base64");return{...z,isChunked:!1,payloadLength:T.payloadLength,params:{iv:K,tag:H}}}async function Y(){let q=await AU.mkdtemp(jU.join(o$.tmpdir(),"cryptit-")),W=jU.join(q,"stdin.bin"),z=OU(W);return await new Promise((T,K)=>{process.stdin.pipe(z),z.on("finish",T),z.on("error",K),process.stdin.on("error",K)}),W}if(!$&&U){let q=await C0.open(U);try{let W=await Q(q);W0.write(JSON.stringify(W,null,2)+`
`)}finally{await q.close()}return}if($){let q=await Y(),W=await C0.open(q);try{try{let I=await Q(W);W0.write(JSON.stringify(I,null,2)+`
`);return}catch{}}finally{await W.close()}let z=(await AU.readFile(q,{encoding:"utf8"})).trim();if(await AU.unlink(q),!(/^[A-Za-z0-9+/]+={0,2}$/.test(z)&&z.length%4===0))d.write(`Error: Input neither valid Cryptit binary nor Base-64 text
`),s(1);let K=Buffer.from(z,"base64"),H=await J(new Uint8Array(K));W0.write(JSON.stringify(H,null,2)+`
`);return}let Z=Buffer.from(U,"utf8"),G=Z.toString("utf8").trim(),X=/^[A-Za-z0-9+/]+={0,2}$/.test(G)&&G.length%4===0;try{if(X){let q=Buffer.from(G,"base64"),W=await J(new Uint8Array(q));W0.write(JSON.stringify(W,null,2)+`
`)}else{let q=await J(new Uint8Array(Z));W0.write(JSON.stringify(q,null,2)+`
`)}}catch(q){let W=q instanceof Error?q.message:String(q);d.write(`Error: ${W}
`),s(1)}});t.command("encrypt <src>").description("Encrypt file; use - for STDIN, --out - for STDOUT").option("-o, --out <file>","output file (default STDOUT)","-").action(async(U,$)=>{if(U!=="-"&&!EU(U))d.write(`Error: input file not found: ${U}
`),s(1);let J=t.opts(),Q=b0({difficulty:J.difficulty,saltStrength:J.saltStrength,chunkSize:J.chunkSize,verbose:J.verbose,scheme:J.scheme}),Y=J.pass??(n.isTTY?await e0():(()=>{d.write(`Use --pass when piping via STDIN
`),s(1)})());try{s$($.out)}catch(H){d.write(`Error: ${H.message}
`),s(1)}let Z=U==="-"?n:n$(U),G=$.out==="-"?W0:OU($.out),{header:X,writable:q,readable:W}=await Q.createEncryptionStream(Y),z=_U(Z),T=wU(G),K=T.getWriter();await K.write(X),K.releaseLock(),await Promise.all([z.pipeTo(q),W.pipeTo(T)])});t.command("decrypt <src>").description("Decrypt file; use - for STDIN, --out - for STDOUT").option("-o, --out <file>","output file (default STDOUT)","-").action(async(U,$)=>{if(U!=="-"&&!EU(U))d.write(`Error: input file not found: ${U}
`),s(1);let J=t.opts(),Q=b0({difficulty:J.difficulty,saltStrength:J.saltStrength,chunkSize:J.chunkSize,verbose:J.verbose,scheme:J.scheme});try{s$($.out)}catch(z){d.write(`Error: ${z.message}
`),s(1)}let Y=J.pass??await e0(),Z=U==="-"?n:n$(U),G=$.out==="-"?W0:OU($.out),X=_U(Z),q=wU(G),W=await Q.createDecryptionStream(Y);await Promise.all([X.pipeTo(W.writable),W.readable.pipeTo(q)])});t.command("encrypt-text [text]").description("Encrypt plaintext; omit arg to read from STDIN").action(async(U)=>{let $=t.opts(),J=b0({difficulty:$.difficulty,saltStrength:$.saltStrength,verbose:$.verbose,scheme:$.scheme}),Q=$.pass??(n.isTTY?await e0():(()=>{d.write(`Use --pass when piping via STDIN
`),s(1)})()),Y=U??await r$(),Z=await J.encryptText(Y,Q);W0.write(Z+`
`)});t.command("decrypt-text [b64]").description("Decrypt Base64 ciphertext; omit arg to read from STDIN").action(async(U)=>{let $=t.opts(),J=b0({difficulty:$.difficulty,saltStrength:$.saltStrength,verbose:$.verbose,scheme:$.scheme}),Q=$.pass??await e0(),Y=U??(await r$()).trim();if(!/^[A-Za-z0-9+/]+={0,2}$/.test(Y))d.write(`Error: ciphertext does not look like Base64
`),s(1);let Z=await J.decryptText(Y,Q);W0.write(Z+`
`)});t.parse();

//# debugId=0B41A57A7AE4C30A64756E2164756E21
