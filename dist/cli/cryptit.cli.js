#!/usr/bin/env node
import{createRequire as B$}from"node:module";var R$=Object.create;var{getPrototypeOf:I$,defineProperty:S0,getOwnPropertyNames:N$}=Object;var V$=Object.prototype.hasOwnProperty;var hU=(U,$,q)=>{q=U!=null?R$(I$(U)):{};let J=$||!U||!U.__esModule?S0(q,"default",{value:U,enumerable:!0}):q;for(let Z of N$(U))if(!V$.call(J,Z))S0(J,Z,{get:()=>U[Z],enumerable:!0});return J};var NU=(U,$)=>()=>($||U(($={exports:{}}).exports,$),$.exports);var HU=B$(import.meta.url);var vU=NU((j$)=>{class aU extends Error{constructor(U,$,q){super(q);Error.captureStackTrace(this,this.constructor),this.name=this.constructor.name,this.code=$,this.exitCode=U,this.nestedError=void 0}}class _0 extends aU{constructor(U){super(1,"commander.invalidArgument",U);Error.captureStackTrace(this,this.constructor),this.name=this.constructor.name}}j$.CommanderError=aU;j$.InvalidArgumentError=_0});var mU=NU((w$)=>{var{InvalidArgumentError:_$}=vU();class M0{constructor(U,$){switch(this.description=$||"",this.variadic=!1,this.parseArg=void 0,this.defaultValue=void 0,this.defaultValueDescription=void 0,this.argChoices=void 0,U[0]){case"<":this.required=!0,this._name=U.slice(1,-1);break;case"[":this.required=!1,this._name=U.slice(1,-1);break;default:this.required=!0,this._name=U;break}if(this._name.endsWith("..."))this.variadic=!0,this._name=this._name.slice(0,-3)}name(){return this._name}_collectValue(U,$){if($===this.defaultValue||!Array.isArray($))return[U];return $.push(U),$}default(U,$){return this.defaultValue=U,this.defaultValueDescription=$,this}argParser(U){return this.parseArg=U,this}choices(U){return this.argChoices=U.slice(),this.parseArg=($,q)=>{if(!this.argChoices.includes($))throw new _$(`Allowed choices are ${this.argChoices.join(", ")}.`);if(this.variadic)return this._collectValue($,q);return $},this}argRequired(){return this.required=!0,this}argOptional(){return this.required=!1,this}}function M$(U){let $=U.name()+(U.variadic===!0?"...":"");return U.required?"<"+$+">":"["+$+"]"}w$.Argument=M0;w$.humanReadableArgName=M$});var tU=NU((O$)=>{var{humanReadableArgName:D$}=mU();class w0{constructor(){this.helpWidth=void 0,this.minWidthToWrap=40,this.sortSubcommands=!1,this.sortOptions=!1,this.showGlobalOptions=!1}prepareContext(U){this.helpWidth=this.helpWidth??U.helpWidth??80}visibleCommands(U){let $=U.commands.filter((J)=>!J._hidden),q=U._getHelpCommand();if(q&&!q._hidden)$.push(q);if(this.sortSubcommands)$.sort((J,Z)=>{return J.name().localeCompare(Z.name())});return $}compareOptions(U,$){let q=(J)=>{return J.short?J.short.replace(/^-/,""):J.long.replace(/^--/,"")};return q(U).localeCompare(q($))}visibleOptions(U){let $=U.options.filter((J)=>!J.hidden),q=U._getHelpOption();if(q&&!q.hidden){let J=q.short&&U._findOption(q.short),Z=q.long&&U._findOption(q.long);if(!J&&!Z)$.push(q);else if(q.long&&!Z)$.push(U.createOption(q.long,q.description));else if(q.short&&!J)$.push(U.createOption(q.short,q.description))}if(this.sortOptions)$.sort(this.compareOptions);return $}visibleGlobalOptions(U){if(!this.showGlobalOptions)return[];let $=[];for(let q=U.parent;q;q=q.parent){let J=q.options.filter((Z)=>!Z.hidden);$.push(...J)}if(this.sortOptions)$.sort(this.compareOptions);return $}visibleArguments(U){if(U._argsDescription)U.registeredArguments.forEach(($)=>{$.description=$.description||U._argsDescription[$.name()]||""});if(U.registeredArguments.find(($)=>$.description))return U.registeredArguments;return[]}subcommandTerm(U){let $=U.registeredArguments.map((q)=>D$(q)).join(" ");return U._name+(U._aliases[0]?"|"+U._aliases[0]:"")+(U.options.length?" [options]":"")+($?" "+$:"")}optionTerm(U){return U.flags}argumentTerm(U){return U.name()}longestSubcommandTermLength(U,$){return $.visibleCommands(U).reduce((q,J)=>{return Math.max(q,this.displayWidth($.styleSubcommandTerm($.subcommandTerm(J))))},0)}longestOptionTermLength(U,$){return $.visibleOptions(U).reduce((q,J)=>{return Math.max(q,this.displayWidth($.styleOptionTerm($.optionTerm(J))))},0)}longestGlobalOptionTermLength(U,$){return $.visibleGlobalOptions(U).reduce((q,J)=>{return Math.max(q,this.displayWidth($.styleOptionTerm($.optionTerm(J))))},0)}longestArgumentTermLength(U,$){return $.visibleArguments(U).reduce((q,J)=>{return Math.max(q,this.displayWidth($.styleArgumentTerm($.argumentTerm(J))))},0)}commandUsage(U){let $=U._name;if(U._aliases[0])$=$+"|"+U._aliases[0];let q="";for(let J=U.parent;J;J=J.parent)q=J.name()+" "+q;return q+$+" "+U.usage()}commandDescription(U){return U.description()}subcommandDescription(U){return U.summary()||U.description()}optionDescription(U){let $=[];if(U.argChoices)$.push(`choices: ${U.argChoices.map((q)=>JSON.stringify(q)).join(", ")}`);if(U.defaultValue!==void 0){if(U.required||U.optional||U.isBoolean()&&typeof U.defaultValue==="boolean")$.push(`default: ${U.defaultValueDescription||JSON.stringify(U.defaultValue)}`)}if(U.presetArg!==void 0&&U.optional)$.push(`preset: ${JSON.stringify(U.presetArg)}`);if(U.envVar!==void 0)$.push(`env: ${U.envVar}`);if($.length>0){let q=`(${$.join(", ")})`;if(U.description)return`${U.description} ${q}`;return q}return U.description}argumentDescription(U){let $=[];if(U.argChoices)$.push(`choices: ${U.argChoices.map((q)=>JSON.stringify(q)).join(", ")}`);if(U.defaultValue!==void 0)$.push(`default: ${U.defaultValueDescription||JSON.stringify(U.defaultValue)}`);if($.length>0){let q=`(${$.join(", ")})`;if(U.description)return`${U.description} ${q}`;return q}return U.description}formatItemList(U,$,q){if($.length===0)return[];return[q.styleTitle(U),...$,""]}groupItems(U,$,q){let J=new Map;return U.forEach((Z)=>{let Y=q(Z);if(!J.has(Y))J.set(Y,[])}),$.forEach((Z)=>{let Y=q(Z);if(!J.has(Y))J.set(Y,[]);J.get(Y).push(Z)}),J}formatHelp(U,$){let q=$.padWidth(U,$),J=$.helpWidth??80;function Z(T,K){return $.formatItem(T,q,K,$)}let Y=[`${$.styleTitle("Usage:")} ${$.styleUsage($.commandUsage(U))}`,""],Q=$.commandDescription(U);if(Q.length>0)Y=Y.concat([$.boxWrap($.styleCommandDescription(Q),J),""]);let X=$.visibleArguments(U).map((T)=>{return Z($.styleArgumentTerm($.argumentTerm(T)),$.styleArgumentDescription($.argumentDescription(T)))});if(Y=Y.concat(this.formatItemList("Arguments:",X,$)),this.groupItems(U.options,$.visibleOptions(U),(T)=>T.helpGroupHeading??"Options:").forEach((T,K)=>{let H=T.map((R)=>{return Z($.styleOptionTerm($.optionTerm(R)),$.styleOptionDescription($.optionDescription(R)))});Y=Y.concat(this.formatItemList(K,H,$))}),$.showGlobalOptions){let T=$.visibleGlobalOptions(U).map((K)=>{return Z($.styleOptionTerm($.optionTerm(K)),$.styleOptionDescription($.optionDescription(K)))});Y=Y.concat(this.formatItemList("Global Options:",T,$))}return this.groupItems(U.commands,$.visibleCommands(U),(T)=>T.helpGroup()||"Commands:").forEach((T,K)=>{let H=T.map((R)=>{return Z($.styleSubcommandTerm($.subcommandTerm(R)),$.styleSubcommandDescription($.subcommandDescription(R)))});Y=Y.concat(this.formatItemList(K,H,$))}),Y.join(`
`)}displayWidth(U){return L0(U).length}styleTitle(U){return U}styleUsage(U){return U.split(" ").map(($)=>{if($==="[options]")return this.styleOptionText($);if($==="[command]")return this.styleSubcommandText($);if($[0]==="["||$[0]==="<")return this.styleArgumentText($);return this.styleCommandText($)}).join(" ")}styleCommandDescription(U){return this.styleDescriptionText(U)}styleOptionDescription(U){return this.styleDescriptionText(U)}styleSubcommandDescription(U){return this.styleDescriptionText(U)}styleArgumentDescription(U){return this.styleDescriptionText(U)}styleDescriptionText(U){return U}styleOptionTerm(U){return this.styleOptionText(U)}styleSubcommandTerm(U){return U.split(" ").map(($)=>{if($==="[options]")return this.styleOptionText($);if($[0]==="["||$[0]==="<")return this.styleArgumentText($);return this.styleSubcommandText($)}).join(" ")}styleArgumentTerm(U){return this.styleArgumentText(U)}styleOptionText(U){return U}styleArgumentText(U){return U}styleSubcommandText(U){return U}styleCommandText(U){return U}padWidth(U,$){return Math.max($.longestOptionTermLength(U,$),$.longestGlobalOptionTermLength(U,$),$.longestSubcommandTermLength(U,$),$.longestArgumentTermLength(U,$))}preformatted(U){return/\n[^\S\r\n]/.test(U)}formatItem(U,$,q,J){let Y=" ".repeat(2);if(!q)return Y+U;let Q=U.padEnd($+U.length-J.displayWidth(U)),X=2,G=(this.helpWidth??80)-$-X-2,T;if(G<this.minWidthToWrap||J.preformatted(q))T=q;else T=J.boxWrap(q,G).replace(/\n/g,`
`+" ".repeat($+X));return Y+Q+" ".repeat(X)+T.replace(/\n/g,`
${Y}`)}boxWrap(U,$){if($<this.minWidthToWrap)return U;let q=U.split(/\r\n|\n/),J=/[\s]*[^\s]+/g,Z=[];return q.forEach((Y)=>{let Q=Y.match(J);if(Q===null){Z.push("");return}let X=[Q.shift()],z=this.displayWidth(X[0]);Q.forEach((G)=>{let T=this.displayWidth(G);if(z+T<=$){X.push(G),z+=T;return}Z.push(X.join(""));let K=G.trimStart();X=[K],z=this.displayWidth(K)}),Z.push(X.join(""))}),Z.join(`
`)}}function L0(U){let $=/\x1b\[\d*(;\d*)*m/g;return U.replace($,"")}O$.Help=w0;O$.stripColor=L0});var eU=NU((v$)=>{var{InvalidArgumentError:C$}=vU();class D0{constructor(U,$){this.flags=U,this.description=$||"",this.required=U.includes("<"),this.optional=U.includes("["),this.variadic=/\w\.\.\.[>\]]$/.test(U),this.mandatory=!1;let q=k$(U);if(this.short=q.shortFlag,this.long=q.longFlag,this.negate=!1,this.long)this.negate=this.long.startsWith("--no-");this.defaultValue=void 0,this.defaultValueDescription=void 0,this.presetArg=void 0,this.envVar=void 0,this.parseArg=void 0,this.hidden=!1,this.argChoices=void 0,this.conflictsWith=[],this.implied=void 0,this.helpGroupHeading=void 0}default(U,$){return this.defaultValue=U,this.defaultValueDescription=$,this}preset(U){return this.presetArg=U,this}conflicts(U){return this.conflictsWith=this.conflictsWith.concat(U),this}implies(U){let $=U;if(typeof U==="string")$={[U]:!0};return this.implied=Object.assign(this.implied||{},$),this}env(U){return this.envVar=U,this}argParser(U){return this.parseArg=U,this}makeOptionMandatory(U=!0){return this.mandatory=!!U,this}hideHelp(U=!0){return this.hidden=!!U,this}_collectValue(U,$){if($===this.defaultValue||!Array.isArray($))return[U];return $.push(U),$}choices(U){return this.argChoices=U.slice(),this.parseArg=($,q)=>{if(!this.argChoices.includes($))throw new C$(`Allowed choices are ${this.argChoices.join(", ")}.`);if(this.variadic)return this._collectValue($,q);return $},this}name(){if(this.long)return this.long.replace(/^--/,"");return this.short.replace(/^-/,"")}attributeName(){if(this.negate)return P0(this.name().replace(/^no-/,""));return P0(this.name())}helpGroup(U){return this.helpGroupHeading=U,this}is(U){return this.short===U||this.long===U}isBoolean(){return!this.required&&!this.optional&&!this.negate}}class O0{constructor(U){this.positiveOptions=new Map,this.negativeOptions=new Map,this.dualOptions=new Set,U.forEach(($)=>{if($.negate)this.negativeOptions.set($.attributeName(),$);else this.positiveOptions.set($.attributeName(),$)}),this.negativeOptions.forEach(($,q)=>{if(this.positiveOptions.has(q))this.dualOptions.add(q)})}valueFromOption(U,$){let q=$.attributeName();if(!this.dualOptions.has(q))return!0;let J=this.negativeOptions.get(q).presetArg,Z=J!==void 0?J:!1;return $.negate===(Z===U)}}function P0(U){return U.split("-").reduce(($,q)=>{return $+q[0].toUpperCase()+q.slice(1)})}function k$(U){let $,q,J=/^-[^-]$/,Z=/^--[^-]/,Y=U.split(/[ |,]+/).concat("guard");if(J.test(Y[0]))$=Y.shift();if(Z.test(Y[0]))q=Y.shift();if(!$&&J.test(Y[0]))$=Y.shift();if(!$&&Z.test(Y[0]))$=q,q=Y.shift();if(Y[0].startsWith("-")){let Q=Y[0],X=`option creation failed due to '${Q}' in option flags '${U}'`;if(/^-[^-][^-]/.test(Q))throw Error(`${X}
- a short flag is a single dash and a single character
  - either use a single dash and a single character (for a short flag)
  - or use a double dash for a long option (and can have two, like '--ws, --workspace')`);if(J.test(Q))throw Error(`${X}
- too many short flags`);if(Z.test(Q))throw Error(`${X}
- too many long flags`);throw Error(`${X}
- unrecognised flag format`)}if($===void 0&&q===void 0)throw Error(`option creation failed due to no flags found in '${U}'.`);return{shortFlag:$,longFlag:q}}v$.Option=D0;v$.DualOptions=O0});var E0=NU((g$)=>{function b$(U,$){if(Math.abs(U.length-$.length)>3)return Math.max(U.length,$.length);let q=[];for(let J=0;J<=U.length;J++)q[J]=[J];for(let J=0;J<=$.length;J++)q[0][J]=J;for(let J=1;J<=$.length;J++)for(let Z=1;Z<=U.length;Z++){let Y=1;if(U[Z-1]===$[J-1])Y=0;else Y=1;if(q[Z][J]=Math.min(q[Z-1][J]+1,q[Z][J-1]+1,q[Z-1][J-1]+Y),Z>1&&J>1&&U[Z-1]===$[J-2]&&U[Z-2]===$[J-1])q[Z][J]=Math.min(q[Z][J],q[Z-2][J-2]+1)}return q[U.length][$.length]}function x$(U,$){if(!$||$.length===0)return"";$=Array.from(new Set($));let q=U.startsWith("--");if(q)U=U.slice(2),$=$.map((Q)=>Q.slice(2));let J=[],Z=3,Y=0.4;if($.forEach((Q)=>{if(Q.length<=1)return;let X=b$(U,Q),z=Math.max(U.length,Q.length);if((z-X)/z>Y){if(X<Z)Z=X,J=[Q];else if(X===Z)J.push(Q)}}),J.sort((Q,X)=>Q.localeCompare(X)),q)J=J.map((Q)=>`--${Q}`);if(J.length>1)return`
(Did you mean one of ${J.join(", ")}?)`;if(J.length===1)return`
(Did you mean ${J[0]}?)`;return""}g$.suggestSimilar=x$});var v0=NU((i$)=>{var m$=HU("node:events").EventEmitter,U0=HU("node:child_process"),YU=HU("node:path"),uU=HU("node:fs"),_=HU("node:process"),{Argument:u$,humanReadableArgName:l$}=mU(),{CommanderError:$0}=vU(),{Help:c$,stripColor:p$}=tU(),{Option:A0,DualOptions:d$}=eU(),{suggestSimilar:C0}=E0();class J0 extends m${constructor(U){super();this.commands=[],this.options=[],this.parent=null,this._allowUnknownOption=!1,this._allowExcessArguments=!1,this.registeredArguments=[],this._args=this.registeredArguments,this.args=[],this.rawArgs=[],this.processedArgs=[],this._scriptPath=null,this._name=U||"",this._optionValues={},this._optionValueSources={},this._storeOptionsAsProperties=!1,this._actionHandler=null,this._executableHandler=!1,this._executableFile=null,this._executableDir=null,this._defaultCommandName=null,this._exitCallback=null,this._aliases=[],this._combineFlagAndOptionalValue=!0,this._description="",this._summary="",this._argsDescription=void 0,this._enablePositionalOptions=!1,this._passThroughOptions=!1,this._lifeCycleHooks={},this._showHelpAfterError=!1,this._showSuggestionAfterError=!0,this._savedState=null,this._outputConfiguration={writeOut:($)=>_.stdout.write($),writeErr:($)=>_.stderr.write($),outputError:($,q)=>q($),getOutHelpWidth:()=>_.stdout.isTTY?_.stdout.columns:void 0,getErrHelpWidth:()=>_.stderr.isTTY?_.stderr.columns:void 0,getOutHasColors:()=>q0()??(_.stdout.isTTY&&_.stdout.hasColors?.()),getErrHasColors:()=>q0()??(_.stderr.isTTY&&_.stderr.hasColors?.()),stripColor:($)=>p$($)},this._hidden=!1,this._helpOption=void 0,this._addImplicitHelpCommand=void 0,this._helpCommand=void 0,this._helpConfiguration={},this._helpGroupHeading=void 0,this._defaultCommandGroup=void 0,this._defaultOptionGroup=void 0}copyInheritedSettings(U){return this._outputConfiguration=U._outputConfiguration,this._helpOption=U._helpOption,this._helpCommand=U._helpCommand,this._helpConfiguration=U._helpConfiguration,this._exitCallback=U._exitCallback,this._storeOptionsAsProperties=U._storeOptionsAsProperties,this._combineFlagAndOptionalValue=U._combineFlagAndOptionalValue,this._allowExcessArguments=U._allowExcessArguments,this._enablePositionalOptions=U._enablePositionalOptions,this._showHelpAfterError=U._showHelpAfterError,this._showSuggestionAfterError=U._showSuggestionAfterError,this}_getCommandAndAncestors(){let U=[];for(let $=this;$;$=$.parent)U.push($);return U}command(U,$,q){let J=$,Z=q;if(typeof J==="object"&&J!==null)Z=J,J=null;Z=Z||{};let[,Y,Q]=U.match(/([^ ]+) *(.*)/),X=this.createCommand(Y);if(J)X.description(J),X._executableHandler=!0;if(Z.isDefault)this._defaultCommandName=X._name;if(X._hidden=!!(Z.noHelp||Z.hidden),X._executableFile=Z.executableFile||null,Q)X.arguments(Q);if(this._registerCommand(X),X.parent=this,X.copyInheritedSettings(this),J)return this;return X}createCommand(U){return new J0(U)}createHelp(){return Object.assign(new c$,this.configureHelp())}configureHelp(U){if(U===void 0)return this._helpConfiguration;return this._helpConfiguration=U,this}configureOutput(U){if(U===void 0)return this._outputConfiguration;return this._outputConfiguration={...this._outputConfiguration,...U},this}showHelpAfterError(U=!0){if(typeof U!=="string")U=!!U;return this._showHelpAfterError=U,this}showSuggestionAfterError(U=!0){return this._showSuggestionAfterError=!!U,this}addCommand(U,$){if(!U._name)throw Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);if($=$||{},$.isDefault)this._defaultCommandName=U._name;if($.noHelp||$.hidden)U._hidden=!0;return this._registerCommand(U),U.parent=this,U._checkForBrokenPassThrough(),this}createArgument(U,$){return new u$(U,$)}argument(U,$,q,J){let Z=this.createArgument(U,$);if(typeof q==="function")Z.default(J).argParser(q);else Z.default(q);return this.addArgument(Z),this}arguments(U){return U.trim().split(/ +/).forEach(($)=>{this.argument($)}),this}addArgument(U){let $=this.registeredArguments.slice(-1)[0];if($?.variadic)throw Error(`only the last argument can be variadic '${$.name()}'`);if(U.required&&U.defaultValue!==void 0&&U.parseArg===void 0)throw Error(`a default value for a required argument is never used: '${U.name()}'`);return this.registeredArguments.push(U),this}helpCommand(U,$){if(typeof U==="boolean"){if(this._addImplicitHelpCommand=U,U&&this._defaultCommandGroup)this._initCommandGroup(this._getHelpCommand());return this}let q=U??"help [command]",[,J,Z]=q.match(/([^ ]+) *(.*)/),Y=$??"display help for command",Q=this.createCommand(J);if(Q.helpOption(!1),Z)Q.arguments(Z);if(Y)Q.description(Y);if(this._addImplicitHelpCommand=!0,this._helpCommand=Q,U||$)this._initCommandGroup(Q);return this}addHelpCommand(U,$){if(typeof U!=="object")return this.helpCommand(U,$),this;return this._addImplicitHelpCommand=!0,this._helpCommand=U,this._initCommandGroup(U),this}_getHelpCommand(){if(this._addImplicitHelpCommand??(this.commands.length&&!this._actionHandler&&!this._findCommand("help"))){if(this._helpCommand===void 0)this.helpCommand(void 0,void 0);return this._helpCommand}return null}hook(U,$){let q=["preSubcommand","preAction","postAction"];if(!q.includes(U))throw Error(`Unexpected value for event passed to hook : '${U}'.
Expecting one of '${q.join("', '")}'`);if(this._lifeCycleHooks[U])this._lifeCycleHooks[U].push($);else this._lifeCycleHooks[U]=[$];return this}exitOverride(U){if(U)this._exitCallback=U;else this._exitCallback=($)=>{if($.code!=="commander.executeSubCommandAsync")throw $};return this}_exit(U,$,q){if(this._exitCallback)this._exitCallback(new $0(U,$,q));_.exit(U)}action(U){let $=(q)=>{let J=this.registeredArguments.length,Z=q.slice(0,J);if(this._storeOptionsAsProperties)Z[J]=this;else Z[J]=this.opts();return Z.push(this),U.apply(this,Z)};return this._actionHandler=$,this}createOption(U,$){return new A0(U,$)}_callParseArg(U,$,q,J){try{return U.parseArg($,q)}catch(Z){if(Z.code==="commander.invalidArgument"){let Y=`${J} ${Z.message}`;this.error(Y,{exitCode:Z.exitCode,code:Z.code})}throw Z}}_registerOption(U){let $=U.short&&this._findOption(U.short)||U.long&&this._findOption(U.long);if($){let q=U.long&&this._findOption(U.long)?U.long:U.short;throw Error(`Cannot add option '${U.flags}'${this._name&&` to command '${this._name}'`} due to conflicting flag '${q}'
-  already used by option '${$.flags}'`)}this._initOptionGroup(U),this.options.push(U)}_registerCommand(U){let $=(J)=>{return[J.name()].concat(J.aliases())},q=$(U).find((J)=>this._findCommand(J));if(q){let J=$(this._findCommand(q)).join("|"),Z=$(U).join("|");throw Error(`cannot add command '${Z}' as already have command '${J}'`)}this._initCommandGroup(U),this.commands.push(U)}addOption(U){this._registerOption(U);let $=U.name(),q=U.attributeName();if(U.negate){let Z=U.long.replace(/^--no-/,"--");if(!this._findOption(Z))this.setOptionValueWithSource(q,U.defaultValue===void 0?!0:U.defaultValue,"default")}else if(U.defaultValue!==void 0)this.setOptionValueWithSource(q,U.defaultValue,"default");let J=(Z,Y,Q)=>{if(Z==null&&U.presetArg!==void 0)Z=U.presetArg;let X=this.getOptionValue(q);if(Z!==null&&U.parseArg)Z=this._callParseArg(U,Z,X,Y);else if(Z!==null&&U.variadic)Z=U._collectValue(Z,X);if(Z==null)if(U.negate)Z=!1;else if(U.isBoolean()||U.optional)Z=!0;else Z="";this.setOptionValueWithSource(q,Z,Q)};if(this.on("option:"+$,(Z)=>{let Y=`error: option '${U.flags}' argument '${Z}' is invalid.`;J(Z,Y,"cli")}),U.envVar)this.on("optionEnv:"+$,(Z)=>{let Y=`error: option '${U.flags}' value '${Z}' from env '${U.envVar}' is invalid.`;J(Z,Y,"env")});return this}_optionEx(U,$,q,J,Z){if(typeof $==="object"&&$ instanceof A0)throw Error("To add an Option object use addOption() instead of option() or requiredOption()");let Y=this.createOption($,q);if(Y.makeOptionMandatory(!!U.mandatory),typeof J==="function")Y.default(Z).argParser(J);else if(J instanceof RegExp){let Q=J;J=(X,z)=>{let G=Q.exec(X);return G?G[0]:z},Y.default(Z).argParser(J)}else Y.default(J);return this.addOption(Y)}option(U,$,q,J){return this._optionEx({},U,$,q,J)}requiredOption(U,$,q,J){return this._optionEx({mandatory:!0},U,$,q,J)}combineFlagAndOptionalValue(U=!0){return this._combineFlagAndOptionalValue=!!U,this}allowUnknownOption(U=!0){return this._allowUnknownOption=!!U,this}allowExcessArguments(U=!0){return this._allowExcessArguments=!!U,this}enablePositionalOptions(U=!0){return this._enablePositionalOptions=!!U,this}passThroughOptions(U=!0){return this._passThroughOptions=!!U,this._checkForBrokenPassThrough(),this}_checkForBrokenPassThrough(){if(this.parent&&this._passThroughOptions&&!this.parent._enablePositionalOptions)throw Error(`passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`)}storeOptionsAsProperties(U=!0){if(this.options.length)throw Error("call .storeOptionsAsProperties() before adding options");if(Object.keys(this._optionValues).length)throw Error("call .storeOptionsAsProperties() before setting option values");return this._storeOptionsAsProperties=!!U,this}getOptionValue(U){if(this._storeOptionsAsProperties)return this[U];return this._optionValues[U]}setOptionValue(U,$){return this.setOptionValueWithSource(U,$,void 0)}setOptionValueWithSource(U,$,q){if(this._storeOptionsAsProperties)this[U]=$;else this._optionValues[U]=$;return this._optionValueSources[U]=q,this}getOptionValueSource(U){return this._optionValueSources[U]}getOptionValueSourceWithGlobals(U){let $;return this._getCommandAndAncestors().forEach((q)=>{if(q.getOptionValueSource(U)!==void 0)$=q.getOptionValueSource(U)}),$}_prepareUserArgs(U,$){if(U!==void 0&&!Array.isArray(U))throw Error("first parameter to parse must be array or undefined");if($=$||{},U===void 0&&$.from===void 0){if(_.versions?.electron)$.from="electron";let J=_.execArgv??[];if(J.includes("-e")||J.includes("--eval")||J.includes("-p")||J.includes("--print"))$.from="eval"}if(U===void 0)U=_.argv;this.rawArgs=U.slice();let q;switch($.from){case void 0:case"node":this._scriptPath=U[1],q=U.slice(2);break;case"electron":if(_.defaultApp)this._scriptPath=U[1],q=U.slice(2);else q=U.slice(1);break;case"user":q=U.slice(0);break;case"eval":q=U.slice(1);break;default:throw Error(`unexpected parse option { from: '${$.from}' }`)}if(!this._name&&this._scriptPath)this.nameFromFilename(this._scriptPath);return this._name=this._name||"program",q}parse(U,$){this._prepareForParse();let q=this._prepareUserArgs(U,$);return this._parseCommand([],q),this}async parseAsync(U,$){this._prepareForParse();let q=this._prepareUserArgs(U,$);return await this._parseCommand([],q),this}_prepareForParse(){if(this._savedState===null)this.saveStateBeforeParse();else this.restoreStateBeforeParse()}saveStateBeforeParse(){this._savedState={_name:this._name,_optionValues:{...this._optionValues},_optionValueSources:{...this._optionValueSources}}}restoreStateBeforeParse(){if(this._storeOptionsAsProperties)throw Error(`Can not call parse again when storeOptionsAsProperties is true.
- either make a new Command for each call to parse, or stop storing options as properties`);this._name=this._savedState._name,this._scriptPath=null,this.rawArgs=[],this._optionValues={...this._savedState._optionValues},this._optionValueSources={...this._savedState._optionValueSources},this.args=[],this.processedArgs=[]}_checkForMissingExecutable(U,$,q){if(uU.existsSync(U))return;let J=$?`searched for local subcommand relative to directory '${$}'`:"no directory for search for local subcommand, use .executableDir() to supply a custom directory",Z=`'${U}' does not exist
 - if '${q}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${J}`;throw Error(Z)}_executeSubCommand(U,$){$=$.slice();let q=!1,J=[".js",".ts",".tsx",".mjs",".cjs"];function Z(G,T){let K=YU.resolve(G,T);if(uU.existsSync(K))return K;if(J.includes(YU.extname(T)))return;let H=J.find((R)=>uU.existsSync(`${K}${R}`));if(H)return`${K}${H}`;return}this._checkForMissingMandatoryOptions(),this._checkForConflictingOptions();let Y=U._executableFile||`${this._name}-${U._name}`,Q=this._executableDir||"";if(this._scriptPath){let G;try{G=uU.realpathSync(this._scriptPath)}catch{G=this._scriptPath}Q=YU.resolve(YU.dirname(G),Q)}if(Q){let G=Z(Q,Y);if(!G&&!U._executableFile&&this._scriptPath){let T=YU.basename(this._scriptPath,YU.extname(this._scriptPath));if(T!==this._name)G=Z(Q,`${T}-${U._name}`)}Y=G||Y}q=J.includes(YU.extname(Y));let X;if(_.platform!=="win32")if(q)$.unshift(Y),$=k0(_.execArgv).concat($),X=U0.spawn(_.argv[0],$,{stdio:"inherit"});else X=U0.spawn(Y,$,{stdio:"inherit"});else this._checkForMissingExecutable(Y,Q,U._name),$.unshift(Y),$=k0(_.execArgv).concat($),X=U0.spawn(_.execPath,$,{stdio:"inherit"});if(!X.killed)["SIGUSR1","SIGUSR2","SIGTERM","SIGINT","SIGHUP"].forEach((T)=>{_.on(T,()=>{if(X.killed===!1&&X.exitCode===null)X.kill(T)})});let z=this._exitCallback;X.on("close",(G)=>{if(G=G??1,!z)_.exit(G);else z(new $0(G,"commander.executeSubCommandAsync","(close)"))}),X.on("error",(G)=>{if(G.code==="ENOENT")this._checkForMissingExecutable(Y,Q,U._name);else if(G.code==="EACCES")throw Error(`'${Y}' not executable`);if(!z)_.exit(1);else{let T=new $0(1,"commander.executeSubCommandAsync","(error)");T.nestedError=G,z(T)}}),this.runningCommand=X}_dispatchSubcommand(U,$,q){let J=this._findCommand(U);if(!J)this.help({error:!0});J._prepareForParse();let Z;return Z=this._chainOrCallSubCommandHook(Z,J,"preSubcommand"),Z=this._chainOrCall(Z,()=>{if(J._executableHandler)this._executeSubCommand(J,$.concat(q));else return J._parseCommand($,q)}),Z}_dispatchHelpCommand(U){if(!U)this.help();let $=this._findCommand(U);if($&&!$._executableHandler)$.help();return this._dispatchSubcommand(U,[],[this._getHelpOption()?.long??this._getHelpOption()?.short??"--help"])}_checkNumberOfArguments(){if(this.registeredArguments.forEach((U,$)=>{if(U.required&&this.args[$]==null)this.missingArgument(U.name())}),this.registeredArguments.length>0&&this.registeredArguments[this.registeredArguments.length-1].variadic)return;if(this.args.length>this.registeredArguments.length)this._excessArguments(this.args)}_processArguments(){let U=(q,J,Z)=>{let Y=J;if(J!==null&&q.parseArg){let Q=`error: command-argument value '${J}' is invalid for argument '${q.name()}'.`;Y=this._callParseArg(q,J,Z,Q)}return Y};this._checkNumberOfArguments();let $=[];this.registeredArguments.forEach((q,J)=>{let Z=q.defaultValue;if(q.variadic){if(J<this.args.length){if(Z=this.args.slice(J),q.parseArg)Z=Z.reduce((Y,Q)=>{return U(q,Q,Y)},q.defaultValue)}else if(Z===void 0)Z=[]}else if(J<this.args.length){if(Z=this.args[J],q.parseArg)Z=U(q,Z,q.defaultValue)}$[J]=Z}),this.processedArgs=$}_chainOrCall(U,$){if(U?.then&&typeof U.then==="function")return U.then(()=>$());return $()}_chainOrCallHooks(U,$){let q=U,J=[];if(this._getCommandAndAncestors().reverse().filter((Z)=>Z._lifeCycleHooks[$]!==void 0).forEach((Z)=>{Z._lifeCycleHooks[$].forEach((Y)=>{J.push({hookedCommand:Z,callback:Y})})}),$==="postAction")J.reverse();return J.forEach((Z)=>{q=this._chainOrCall(q,()=>{return Z.callback(Z.hookedCommand,this)})}),q}_chainOrCallSubCommandHook(U,$,q){let J=U;if(this._lifeCycleHooks[q]!==void 0)this._lifeCycleHooks[q].forEach((Z)=>{J=this._chainOrCall(J,()=>{return Z(this,$)})});return J}_parseCommand(U,$){let q=this.parseOptions($);if(this._parseOptionsEnv(),this._parseOptionsImplied(),U=U.concat(q.operands),$=q.unknown,this.args=U.concat($),U&&this._findCommand(U[0]))return this._dispatchSubcommand(U[0],U.slice(1),$);if(this._getHelpCommand()&&U[0]===this._getHelpCommand().name())return this._dispatchHelpCommand(U[1]);if(this._defaultCommandName)return this._outputHelpIfRequested($),this._dispatchSubcommand(this._defaultCommandName,U,$);if(this.commands.length&&this.args.length===0&&!this._actionHandler&&!this._defaultCommandName)this.help({error:!0});this._outputHelpIfRequested(q.unknown),this._checkForMissingMandatoryOptions(),this._checkForConflictingOptions();let J=()=>{if(q.unknown.length>0)this.unknownOption(q.unknown[0])},Z=`command:${this.name()}`;if(this._actionHandler){J(),this._processArguments();let Y;if(Y=this._chainOrCallHooks(Y,"preAction"),Y=this._chainOrCall(Y,()=>this._actionHandler(this.processedArgs)),this.parent)Y=this._chainOrCall(Y,()=>{this.parent.emit(Z,U,$)});return Y=this._chainOrCallHooks(Y,"postAction"),Y}if(this.parent?.listenerCount(Z))J(),this._processArguments(),this.parent.emit(Z,U,$);else if(U.length){if(this._findCommand("*"))return this._dispatchSubcommand("*",U,$);if(this.listenerCount("command:*"))this.emit("command:*",U,$);else if(this.commands.length)this.unknownCommand();else J(),this._processArguments()}else if(this.commands.length)J(),this.help({error:!0});else J(),this._processArguments()}_findCommand(U){if(!U)return;return this.commands.find(($)=>$._name===U||$._aliases.includes(U))}_findOption(U){return this.options.find(($)=>$.is(U))}_checkForMissingMandatoryOptions(){this._getCommandAndAncestors().forEach((U)=>{U.options.forEach(($)=>{if($.mandatory&&U.getOptionValue($.attributeName())===void 0)U.missingMandatoryOptionValue($)})})}_checkForConflictingLocalOptions(){let U=this.options.filter((q)=>{let J=q.attributeName();if(this.getOptionValue(J)===void 0)return!1;return this.getOptionValueSource(J)!=="default"});U.filter((q)=>q.conflictsWith.length>0).forEach((q)=>{let J=U.find((Z)=>q.conflictsWith.includes(Z.attributeName()));if(J)this._conflictingOption(q,J)})}_checkForConflictingOptions(){this._getCommandAndAncestors().forEach((U)=>{U._checkForConflictingLocalOptions()})}parseOptions(U){let $=[],q=[],J=$;function Z(G){return G.length>1&&G[0]==="-"}let Y=(G)=>{if(!/^-\d*\.?\d+(e[+-]?\d+)?$/.test(G))return!1;return!this._getCommandAndAncestors().some((T)=>T.options.map((K)=>K.short).some((K)=>/^-\d$/.test(K)))},Q=null,X=null,z=0;while(z<U.length||X){let G=X??U[z++];if(X=null,G==="--"){if(J===q)J.push(G);J.push(...U.slice(z));break}if(Q&&(!Z(G)||Y(G))){this.emit(`option:${Q.name()}`,G);continue}if(Q=null,Z(G)){let T=this._findOption(G);if(T){if(T.required){let K=U[z++];if(K===void 0)this.optionMissingArgument(T);this.emit(`option:${T.name()}`,K)}else if(T.optional){let K=null;if(z<U.length&&(!Z(U[z])||Y(U[z])))K=U[z++];this.emit(`option:${T.name()}`,K)}else this.emit(`option:${T.name()}`);Q=T.variadic?T:null;continue}}if(G.length>2&&G[0]==="-"&&G[1]!=="-"){let T=this._findOption(`-${G[1]}`);if(T){if(T.required||T.optional&&this._combineFlagAndOptionalValue)this.emit(`option:${T.name()}`,G.slice(2));else this.emit(`option:${T.name()}`),X=`-${G.slice(2)}`;continue}}if(/^--[^=]+=/.test(G)){let T=G.indexOf("="),K=this._findOption(G.slice(0,T));if(K&&(K.required||K.optional)){this.emit(`option:${K.name()}`,G.slice(T+1));continue}}if(J===$&&Z(G)&&!(this.commands.length===0&&Y(G)))J=q;if((this._enablePositionalOptions||this._passThroughOptions)&&$.length===0&&q.length===0){if(this._findCommand(G)){$.push(G),q.push(...U.slice(z));break}else if(this._getHelpCommand()&&G===this._getHelpCommand().name()){$.push(G,...U.slice(z));break}else if(this._defaultCommandName){q.push(G,...U.slice(z));break}}if(this._passThroughOptions){J.push(G,...U.slice(z));break}J.push(G)}return{operands:$,unknown:q}}opts(){if(this._storeOptionsAsProperties){let U={},$=this.options.length;for(let q=0;q<$;q++){let J=this.options[q].attributeName();U[J]=J===this._versionOptionName?this._version:this[J]}return U}return this._optionValues}optsWithGlobals(){return this._getCommandAndAncestors().reduce((U,$)=>Object.assign(U,$.opts()),{})}error(U,$){if(this._outputConfiguration.outputError(`${U}
`,this._outputConfiguration.writeErr),typeof this._showHelpAfterError==="string")this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`);else if(this._showHelpAfterError)this._outputConfiguration.writeErr(`
`),this.outputHelp({error:!0});let q=$||{},J=q.exitCode||1,Z=q.code||"commander.error";this._exit(J,Z,U)}_parseOptionsEnv(){this.options.forEach((U)=>{if(U.envVar&&U.envVar in _.env){let $=U.attributeName();if(this.getOptionValue($)===void 0||["default","config","env"].includes(this.getOptionValueSource($)))if(U.required||U.optional)this.emit(`optionEnv:${U.name()}`,_.env[U.envVar]);else this.emit(`optionEnv:${U.name()}`)}})}_parseOptionsImplied(){let U=new d$(this.options),$=(q)=>{return this.getOptionValue(q)!==void 0&&!["default","implied"].includes(this.getOptionValueSource(q))};this.options.filter((q)=>q.implied!==void 0&&$(q.attributeName())&&U.valueFromOption(this.getOptionValue(q.attributeName()),q)).forEach((q)=>{Object.keys(q.implied).filter((J)=>!$(J)).forEach((J)=>{this.setOptionValueWithSource(J,q.implied[J],"implied")})})}missingArgument(U){let $=`error: missing required argument '${U}'`;this.error($,{code:"commander.missingArgument"})}optionMissingArgument(U){let $=`error: option '${U.flags}' argument missing`;this.error($,{code:"commander.optionMissingArgument"})}missingMandatoryOptionValue(U){let $=`error: required option '${U.flags}' not specified`;this.error($,{code:"commander.missingMandatoryOptionValue"})}_conflictingOption(U,$){let q=(Y)=>{let Q=Y.attributeName(),X=this.getOptionValue(Q),z=this.options.find((T)=>T.negate&&Q===T.attributeName()),G=this.options.find((T)=>!T.negate&&Q===T.attributeName());if(z&&(z.presetArg===void 0&&X===!1||z.presetArg!==void 0&&X===z.presetArg))return z;return G||Y},J=(Y)=>{let Q=q(Y),X=Q.attributeName();if(this.getOptionValueSource(X)==="env")return`environment variable '${Q.envVar}'`;return`option '${Q.flags}'`},Z=`error: ${J(U)} cannot be used with ${J($)}`;this.error(Z,{code:"commander.conflictingOption"})}unknownOption(U){if(this._allowUnknownOption)return;let $="";if(U.startsWith("--")&&this._showSuggestionAfterError){let J=[],Z=this;do{let Y=Z.createHelp().visibleOptions(Z).filter((Q)=>Q.long).map((Q)=>Q.long);J=J.concat(Y),Z=Z.parent}while(Z&&!Z._enablePositionalOptions);$=C0(U,J)}let q=`error: unknown option '${U}'${$}`;this.error(q,{code:"commander.unknownOption"})}_excessArguments(U){if(this._allowExcessArguments)return;let $=this.registeredArguments.length,q=$===1?"":"s",Z=`error: too many arguments${this.parent?` for '${this.name()}'`:""}. Expected ${$} argument${q} but got ${U.length}.`;this.error(Z,{code:"commander.excessArguments"})}unknownCommand(){let U=this.args[0],$="";if(this._showSuggestionAfterError){let J=[];this.createHelp().visibleCommands(this).forEach((Z)=>{if(J.push(Z.name()),Z.alias())J.push(Z.alias())}),$=C0(U,J)}let q=`error: unknown command '${U}'${$}`;this.error(q,{code:"commander.unknownCommand"})}version(U,$,q){if(U===void 0)return this._version;this._version=U,$=$||"-V, --version",q=q||"output the version number";let J=this.createOption($,q);return this._versionOptionName=J.attributeName(),this._registerOption(J),this.on("option:"+J.name(),()=>{this._outputConfiguration.writeOut(`${U}
`),this._exit(0,"commander.version",U)}),this}description(U,$){if(U===void 0&&$===void 0)return this._description;if(this._description=U,$)this._argsDescription=$;return this}summary(U){if(U===void 0)return this._summary;return this._summary=U,this}alias(U){if(U===void 0)return this._aliases[0];let $=this;if(this.commands.length!==0&&this.commands[this.commands.length-1]._executableHandler)$=this.commands[this.commands.length-1];if(U===$._name)throw Error("Command alias can't be the same as its name");let q=this.parent?._findCommand(U);if(q){let J=[q.name()].concat(q.aliases()).join("|");throw Error(`cannot add alias '${U}' to command '${this.name()}' as already have command '${J}'`)}return $._aliases.push(U),this}aliases(U){if(U===void 0)return this._aliases;return U.forEach(($)=>this.alias($)),this}usage(U){if(U===void 0){if(this._usage)return this._usage;let $=this.registeredArguments.map((q)=>{return l$(q)});return[].concat(this.options.length||this._helpOption!==null?"[options]":[],this.commands.length?"[command]":[],this.registeredArguments.length?$:[]).join(" ")}return this._usage=U,this}name(U){if(U===void 0)return this._name;return this._name=U,this}helpGroup(U){if(U===void 0)return this._helpGroupHeading??"";return this._helpGroupHeading=U,this}commandsGroup(U){if(U===void 0)return this._defaultCommandGroup??"";return this._defaultCommandGroup=U,this}optionsGroup(U){if(U===void 0)return this._defaultOptionGroup??"";return this._defaultOptionGroup=U,this}_initOptionGroup(U){if(this._defaultOptionGroup&&!U.helpGroupHeading)U.helpGroup(this._defaultOptionGroup)}_initCommandGroup(U){if(this._defaultCommandGroup&&!U.helpGroup())U.helpGroup(this._defaultCommandGroup)}nameFromFilename(U){return this._name=YU.basename(U,YU.extname(U)),this}executableDir(U){if(U===void 0)return this._executableDir;return this._executableDir=U,this}helpInformation(U){let $=this.createHelp(),q=this._getOutputContext(U);$.prepareContext({error:q.error,helpWidth:q.helpWidth,outputHasColors:q.hasColors});let J=$.formatHelp(this,$);if(q.hasColors)return J;return this._outputConfiguration.stripColor(J)}_getOutputContext(U){U=U||{};let $=!!U.error,q,J,Z;if($)q=(Q)=>this._outputConfiguration.writeErr(Q),J=this._outputConfiguration.getErrHasColors(),Z=this._outputConfiguration.getErrHelpWidth();else q=(Q)=>this._outputConfiguration.writeOut(Q),J=this._outputConfiguration.getOutHasColors(),Z=this._outputConfiguration.getOutHelpWidth();return{error:$,write:(Q)=>{if(!J)Q=this._outputConfiguration.stripColor(Q);return q(Q)},hasColors:J,helpWidth:Z}}outputHelp(U){let $;if(typeof U==="function")$=U,U=void 0;let q=this._getOutputContext(U),J={error:q.error,write:q.write,command:this};this._getCommandAndAncestors().reverse().forEach((Y)=>Y.emit("beforeAllHelp",J)),this.emit("beforeHelp",J);let Z=this.helpInformation({error:q.error});if($){if(Z=$(Z),typeof Z!=="string"&&!Buffer.isBuffer(Z))throw Error("outputHelp callback must return a string or a Buffer")}if(q.write(Z),this._getHelpOption()?.long)this.emit(this._getHelpOption().long);this.emit("afterHelp",J),this._getCommandAndAncestors().forEach((Y)=>Y.emit("afterAllHelp",J))}helpOption(U,$){if(typeof U==="boolean"){if(U){if(this._helpOption===null)this._helpOption=void 0;if(this._defaultOptionGroup)this._initOptionGroup(this._getHelpOption())}else this._helpOption=null;return this}if(this._helpOption=this.createOption(U??"-h, --help",$??"display help for command"),U||$)this._initOptionGroup(this._helpOption);return this}_getHelpOption(){if(this._helpOption===void 0)this.helpOption(void 0,void 0);return this._helpOption}addHelpOption(U){return this._helpOption=U,this._initOptionGroup(U),this}help(U){this.outputHelp(U);let $=Number(_.exitCode??0);if($===0&&U&&typeof U!=="function"&&U.error)$=1;this._exit($,"commander.help","(outputHelp)")}addHelpText(U,$){let q=["beforeAll","before","after","afterAll"];if(!q.includes(U))throw Error(`Unexpected value for position to addHelpText.
Expecting one of '${q.join("', '")}'`);let J=`${U}Help`;return this.on(J,(Z)=>{let Y;if(typeof $==="function")Y=$({error:Z.error,command:Z.command});else Y=$;if(Y)Z.write(`${Y}
`)}),this}_outputHelpIfRequested(U){let $=this._getHelpOption();if($&&U.find((J)=>$.is(J)))this.outputHelp(),this._exit(0,"commander.helpDisplayed","(outputHelp)")}}function k0(U){return U.map(($)=>{if(!$.startsWith("--inspect"))return $;let q,J="127.0.0.1",Z="9229",Y;if((Y=$.match(/^(--inspect(-brk)?)$/))!==null)q=Y[1];else if((Y=$.match(/^(--inspect(-brk|-port)?)=([^:]+)$/))!==null)if(q=Y[1],/^\d+$/.test(Y[3]))Z=Y[3];else J=Y[3];else if((Y=$.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/))!==null)q=Y[1],J=Y[3],Z=Y[4];if(q&&Z!=="0")return`${q}=${J}:${parseInt(Z)+1}`;return $})}function q0(){if(_.env.NO_COLOR||_.env.FORCE_COLOR==="0"||_.env.FORCE_COLOR==="false")return!1;if(_.env.FORCE_COLOR||_.env.CLICOLOR_FORCE!==void 0)return!0;return}i$.Command=J0;i$.useColor=q0});var x0=NU((a$)=>{var{Argument:y0}=mU(),{Command:Z0}=v0(),{CommanderError:o$,InvalidArgumentError:f0}=vU(),{Help:r$}=tU(),{Option:b0}=eU();a$.program=new Z0;a$.createCommand=(U)=>new Z0(U);a$.createOption=(U,$)=>new b0(U,$);a$.createArgument=(U,$)=>new y0(U,$);a$.Command=Z0;a$.Option=b0;a$.Argument=y0;a$.Help=r$;a$.CommanderError=o$;a$.InvalidArgumentError=f0;a$.InvalidOptionArgumentError=f0});var g0=hU(x0(),1),{program:rq,createCommand:aq,createArgument:tq,createOption:eq,CommanderError:UJ,InvalidArgumentError:$J,InvalidOptionArgumentError:qJ,Command:h0,Argument:JJ,Option:VU,Help:ZJ}=g0.default;import{existsSync as B0,accessSync as yq,constants as fq,realpathSync as G$}from"node:fs";import{createReadStream as K$,createWriteStream as j0}from"node:fs";import{stdin as a,stdout as t,stderr as l,exit as n}from"node:process";class e extends Error{constructor(U){super(U);Object.setPrototypeOf(this,new.target.prototype),this.name=new.target.name,this.stack=void 0}}class r extends e{}class LU extends e{}class Y0 extends e{}class lU extends e{}class RU extends e{}class QU extends e{}class UU extends e{}class x extends e{}class PU extends e{}function m0(){return typeof process<"u"&&typeof process.versions==="object"&&!0}function BU(...U){let $=U.reduce((Z,Y)=>Z+Y.byteLength,0),q=new Uint8Array($),J=0;for(let Z of U)q.set(Z,J),J+=Z.byteLength;return q}function DU(...U){try{let $=BU(...U);if(m0())return Buffer.from($).toString("base64");let q="";for(let J=0;J<$.length;J++)q+=String.fromCharCode($[J]);return btoa(q)}catch{throw new Y0("Base64 Encoding Error")}}function yU(U){try{if(!/^[A-Za-z0-9+/]+={0,2}$/.test(U)||U.length%4!==0)throw Error("Invalid Base64");if(m0())return new Uint8Array(Buffer.from(U,"base64"));let $=atob(U),q=new Uint8Array($.length);for(let J=0;J<$.length;J++)q[J]=$.charCodeAt(J);return q}catch{throw new LU(`Invalid Base64: length=${U.length}, content='${U.slice(0,12)}…'`)}}function i(U){let $=U.value.length,q=Array($).fill("\x00").join("");U.value=q}function Q0(U,$,q){if($<0||q<0||$+q>U)throw RangeError("read() slice exceeds data bounds")}import{promises as Gq}from"fs";class X0{src;#U=null;constructor(U){this.src=U}get length(){if(this.src instanceof Uint8Array)return this.src.byteLength;if(this.src instanceof Blob)return this.src.size;return this.ensureUint8().byteLength}async read(U,$){if(Q0(this.length,U,$),this.src instanceof Uint8Array)return this.src.slice(U,U+$);if(this.src instanceof Blob){let q=await this.src.slice(U,U+$).arrayBuffer();return new Uint8Array(q)}return this.ensureUint8().slice(U,U+$)}ensureUint8(){if(!this.#U)this.#U=yU(this.src);return this.#U}}class fU{fd;length;constructor(U,$){this.fd=U;this.length=$}static async open(U){let $=await Gq.open(U,"r"),q=await $.stat();return new fU($,q.size)}async read(U,$){Q0(this.length,U,$);let q=Buffer.allocUnsafe($);return await this.fd.read(q,0,$,U),new Uint8Array(q)}async close(){await this.fd.close()}}class d{static byId=new Map;static register(U){if(this.byId.has(U.id))throw new lU(`Scheme ${U.id} already registered`);this.byId.set(U.id,U)}static get(U){let $=this.byId.get(U);if(!$)throw new lU(`Unknown scheme: ${U}`);return $}static get current(){return this.get(0)}}class XU{p;padding=null;headerAAD=new Uint8Array(0);padAADMode="auto";padAlign=8;allowLegacyAADFallback=!0;legacyFallbackPolicy="auto";tryEmptyAADOnLegacyFallback=!1;setLegacyAADFallback(U={}){if(U.enabled!==void 0)this.allowLegacyAADFallback=!!U.enabled;if(U.policy)this.legacyFallbackPolicy=U.policy;if(U.tryEmptyAAD!==void 0)this.tryEmptyAADOnLegacyFallback=!!U.tryEmptyAAD}static PAD_AAD_MAGIC=new Uint8Array([80,65,68,49]);static PAD_AAD_VER=1;constructor(U){this.p=U}setPaddingScheme(U){this.padding=U}setPaddingAADMode(U){this.padAADMode=U}setPaddingAlign(U){if(!Number.isInteger(U)||U<1||U>255)throw Error("padAlign must be 1..255");this.padAlign=U|0}setAAD(U){this.headerAAD=U&&U.byteLength?new Uint8Array(U):new Uint8Array(0)}async encryptChunk(U){let $=this.resolveMode(),q=U;if($==="require"){if(!this.padding)throw Error("Padding required but no scheme set");let Y=(Q)=>this.p.getRandomValues(new Uint8Array(Q));q=this.padding.pad(U,Y,this.padAlign)}let J=this.composeAAD($),Z=await this.encryptWithAAD(q,J);if(U.fill(0),q!==U)q.fill(0);return Z}async decryptChunk(U){let $=this.resolveMode(),q=this.composeAAD($);try{let J=await this.decryptWithAAD(U,q);return this.enforcePolicyAfterDecrypt(J,$)}catch(J){if(!this.allowLegacyAADFallback)throw J;let Z=[];if(this.headerAAD.length)Z.push(this.headerAAD);if(this.tryEmptyAADOnLegacyFallback)Z.push(new Uint8Array(0));let Y=J;for(let Q of Z)try{let X=await this.decryptWithAAD(U,Q),z=this.legacyFallbackPolicy==="auto"?"auto":this.legacyFallbackPolicy;return this.enforcePolicyAfterDecrypt(X,z)}catch(X){Y=X}throw Y}}enforcePolicyAfterDecrypt(U,$){if(!this.padding){if($==="require")throw new x("Expected padding but no scheme configured");return U}let{used:q,plain:J}=this.padding.tryUnpad(U);if($==="require"){if(!q)throw new x("Expected padding trailer not found");return new Uint8Array(J)}if($==="forbid"){if(q)throw new x("Padding forbidden by policy");return U}return q?new Uint8Array(J):U}resolveMode(){if(this.padAADMode==="auto")return this.padding?"require":"forbid";return this.padAADMode}buildPadAAD(U){let $=U==="require"?0:1,q=new Uint8Array(XU.PAD_AAD_MAGIC.length+1+1+1),J=0;return q.set(XU.PAD_AAD_MAGIC,J),J+=XU.PAD_AAD_MAGIC.length,q[J++]=XU.PAD_AAD_VER&255,q[J++]=$,q[J++]=this.padAlign&255,q}composeAAD(U){let $=this.buildPadAAD(U);if(!this.headerAAD.length)return $;let q=new Uint8Array(this.headerAAD.length+$.length);return q.set(this.headerAAD,0),q.set($,this.headerAAD.length),q}}class $U extends XU{static IV_LENGTH=12;static TAG_LENGTH=16;IV_LENGTH=$U.IV_LENGTH;TAG_LENGTH=$U.TAG_LENGTH;key=null;constructor(U){super(U)}async setKey(U){this.key=U}zeroKey(){this.key=null}async encryptWithAAD(U,$){let q=this.p.getRandomValues(new Uint8Array($U.IV_LENGTH)),J={name:"AES-GCM",iv:q,additionalData:$},Z=await this.p.subtle.encrypt(J,this.requireKey(),U),Y=new Uint8Array(Z),Q=new Uint8Array(q.length+Y.length);return Q.set(q,0),Q.set(Y,q.length),Q}async decryptWithAAD(U,$){if(U.byteLength<$U.IV_LENGTH+$U.TAG_LENGTH)throw new x("Invalid ciphertext: too short.");let q=U.subarray(0,$U.IV_LENGTH),J=U.subarray($U.IV_LENGTH),Z={name:"AES-GCM",iv:q,additionalData:$};try{let Y=await this.p.subtle.decrypt(Z,this.requireKey(),J);return new Uint8Array(Y)}catch{throw new x("Decryption failed: wrong passphrase or corrupted ciphertext")}}requireKey(){if(!this.key)throw Error("Encryption key not set");return this.key}}/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function Tq(U){return U instanceof Uint8Array||ArrayBuffer.isView(U)&&U.constructor.name==="Uint8Array"}function cU(U){if(typeof U!=="boolean")throw Error(`boolean expected, not ${U}`)}function pU(U){if(!Number.isSafeInteger(U)||U<0)throw Error("positive integer expected, got "+U)}function m(U,$,q=""){let J=Tq(U),Z=U?.length,Y=$!==void 0;if(!J||Y&&Z!==$){let Q=q&&`"${q}" `,X=Y?` of length ${$}`:"",z=J?`length=${Z}`:`type=${typeof U}`;throw Error(Q+"expected Uint8Array"+X+", got "+z)}return U}function z0(U,$=!0){if(U.destroyed)throw Error("Hash instance has been destroyed");if($&&U.finished)throw Error("Hash#digest() has already been called")}function u0(U,$){m(U,void 0,"output");let q=$.outputLen;if(U.length<q)throw Error("digestInto() expects output buffer of length at least "+q)}function zU(U){return new Uint32Array(U.buffer,U.byteOffset,Math.floor(U.byteLength/4))}function GU(...U){for(let $=0;$<U.length;$++)U[$].fill(0)}function Kq(U){return new DataView(U.buffer,U.byteOffset,U.byteLength)}var Wq=(()=>new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68)();function l0(U,$){if($==null||typeof $!=="object")throw Error("options must be defined");return Object.assign(U,$)}function c0(U,$){if(U.length!==$.length)return!1;let q=0;for(let J=0;J<U.length;J++)q|=U[J]^$[J];return q===0}var G0=(U,$)=>{function q(J,...Z){if(m(J,void 0,"key"),!Wq)throw Error("Non little-endian hardware is not yet supported");if(U.nonceLength!==void 0){let T=Z[0];m(T,U.varSizeNonce?void 0:U.nonceLength,"nonce")}let Y=U.tagLength;if(Y&&Z[1]!==void 0)m(Z[1],void 0,"AAD");let Q=$(J,...Z),X=(T,K)=>{if(K!==void 0){if(T!==2)throw Error("cipher output not supported");m(K,void 0,"output")}},z=!1;return{encrypt(T,K){if(z)throw Error("cannot encrypt() twice with same key + nonce");return z=!0,m(T),X(Q.encrypt.length,K),Q.encrypt(T,K)},decrypt(T,K){if(m(T),Y&&T.length<Y)throw Error('"ciphertext" expected length bigger than tagLength='+Y);return X(Q.decrypt.length,K),Q.decrypt(T,K)}}}return Object.assign(q,U),q};function T0(U,$,q=!0){if($===void 0)return new Uint8Array(U);if($.length!==U)throw Error('"output" expected Uint8Array of length '+U+", got: "+$.length);if(q&&!Hq($))throw Error("invalid output, must be aligned");return $}function p0(U,$,q){cU(q);let J=new Uint8Array(16),Z=Kq(J);return Z.setBigUint64(0,BigInt($),q),Z.setBigUint64(8,BigInt(U),q),J}function Hq(U){return U.byteOffset%4===0}function OU(U){return Uint8Array.from(U)}var i0=(U)=>Uint8Array.from(U.split(""),($)=>$.charCodeAt(0)),Rq=i0("expand 16-byte k"),Iq=i0("expand 32-byte k"),Nq=zU(Rq),Vq=zU(Iq);function W(U,$){return U<<$|U>>>32-$}function K0(U){return U.byteOffset%4===0}var dU=64,Bq=16,s0=4294967295,d0=Uint32Array.of();function jq(U,$,q,J,Z,Y,Q,X){let z=Z.length,G=new Uint8Array(dU),T=zU(G),K=K0(Z)&&K0(Y),H=K?zU(Z):d0,R=K?zU(Y):d0;for(let I=0;I<z;Q++){if(U($,q,J,T,Q,X),Q>=s0)throw Error("arx: counter overflow");let N=Math.min(dU,z-I);if(K&&N===dU){let B=I/4;if(I%4!==0)throw Error("arx: invalid block position");for(let j=0,S;j<Bq;j++)S=B+j,R[S]=H[S]^T[j];I+=dU;continue}for(let B=0,j;B<N;B++)j=I+B,Y[j]=Z[j]^G[B];I+=N}}function W0(U,$){let{allowShortKeys:q,extendNonceFn:J,counterLength:Z,counterRight:Y,rounds:Q}=l0({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},$);if(typeof U!=="function")throw Error("core must be a function");return pU(Z),pU(Q),cU(Y),cU(q),(X,z,G,T,K=0)=>{m(X,void 0,"key"),m(z,void 0,"nonce"),m(G,void 0,"data");let H=G.length;if(T===void 0)T=new Uint8Array(H);if(m(T,void 0,"output"),pU(K),K<0||K>=s0)throw Error("arx: counter overflow");if(T.length<H)throw Error(`arx: output (${T.length}) is shorter than data (${H})`);let R=[],I=X.length,N,B;if(I===32)R.push(N=OU(X)),B=Vq;else if(I===16&&q)N=new Uint8Array(32),N.set(X),N.set(X,16),B=Nq,R.push(N);else throw m(X,32,"arx key"),Error("invalid key size");if(!K0(z))R.push(z=OU(z));let j=zU(N);if(J){if(z.length!==24)throw Error("arx: extended nonce must be 24 bytes");J(B,j,zU(z.subarray(0,16)),j),z=z.subarray(16)}let S=16-Z;if(S!==z.length)throw Error(`arx: nonce must be ${S} or 16 bytes`);if(S!==12){let g=new Uint8Array(12);g.set(z,Y?0:12-z.length),z=g,R.push(z)}let F=zU(z);return jq(U,B,j,F,G,T,K,Q),GU(...R),T}}function u(U,$){return U[$++]&255|(U[$++]&255)<<8}class n0{blockLen=16;outputLen=16;buffer=new Uint8Array(16);r=new Uint16Array(10);h=new Uint16Array(10);pad=new Uint16Array(8);pos=0;finished=!1;constructor(U){U=OU(m(U,32,"key"));let $=u(U,0),q=u(U,2),J=u(U,4),Z=u(U,6),Y=u(U,8),Q=u(U,10),X=u(U,12),z=u(U,14);this.r[0]=$&8191,this.r[1]=($>>>13|q<<3)&8191,this.r[2]=(q>>>10|J<<6)&7939,this.r[3]=(J>>>7|Z<<9)&8191,this.r[4]=(Z>>>4|Y<<12)&255,this.r[5]=Y>>>1&8190,this.r[6]=(Y>>>14|Q<<2)&8191,this.r[7]=(Q>>>11|X<<5)&8065,this.r[8]=(X>>>8|z<<8)&8191,this.r[9]=z>>>5&127;for(let G=0;G<8;G++)this.pad[G]=u(U,16+2*G)}process(U,$,q=!1){let J=q?0:2048,{h:Z,r:Y}=this,Q=Y[0],X=Y[1],z=Y[2],G=Y[3],T=Y[4],K=Y[5],H=Y[6],R=Y[7],I=Y[8],N=Y[9],B=u(U,$+0),j=u(U,$+2),S=u(U,$+4),F=u(U,$+6),g=u(U,$+8),WU=u(U,$+10),c=u(U,$+12),p=u(U,$+14),M=Z[0]+(B&8191),w=Z[1]+((B>>>13|j<<3)&8191),L=Z[2]+((j>>>10|S<<6)&8191),P=Z[3]+((S>>>7|F<<9)&8191),D=Z[4]+((F>>>4|g<<12)&8191),O=Z[5]+(g>>>1&8191),E=Z[6]+((g>>>14|WU<<2)&8191),A=Z[7]+((WU>>>11|c<<5)&8191),C=Z[8]+((c>>>8|p<<8)&8191),k=Z[9]+(p>>>5|J),V=0,y=V+M*Q+w*(5*N)+L*(5*I)+P*(5*R)+D*(5*H);V=y>>>13,y&=8191,y+=O*(5*K)+E*(5*T)+A*(5*G)+C*(5*z)+k*(5*X),V+=y>>>13,y&=8191;let f=V+M*X+w*Q+L*(5*N)+P*(5*I)+D*(5*R);V=f>>>13,f&=8191,f+=O*(5*H)+E*(5*K)+A*(5*T)+C*(5*G)+k*(5*z),V+=f>>>13,f&=8191;let b=V+M*z+w*X+L*Q+P*(5*N)+D*(5*I);V=b>>>13,b&=8191,b+=O*(5*R)+E*(5*H)+A*(5*K)+C*(5*T)+k*(5*G),V+=b>>>13,b&=8191;let v=V+M*G+w*z+L*X+P*Q+D*(5*N);V=v>>>13,v&=8191,v+=O*(5*I)+E*(5*R)+A*(5*H)+C*(5*K)+k*(5*T),V+=v>>>13,v&=8191;let ZU=V+M*T+w*G+L*z+P*X+D*Q;V=ZU>>>13,ZU&=8191,ZU+=O*(5*N)+E*(5*I)+A*(5*R)+C*(5*H)+k*(5*K),V+=ZU>>>13,ZU&=8191;let FU=V+M*K+w*T+L*G+P*z+D*X;V=FU>>>13,FU&=8191,FU+=O*Q+E*(5*N)+A*(5*I)+C*(5*R)+k*(5*H),V+=FU>>>13,FU&=8191;let SU=V+M*H+w*K+L*T+P*G+D*z;V=SU>>>13,SU&=8191,SU+=O*X+E*Q+A*(5*N)+C*(5*I)+k*(5*R),V+=SU>>>13,SU&=8191;let _U=V+M*R+w*H+L*K+P*T+D*G;V=_U>>>13,_U&=8191,_U+=O*z+E*X+A*Q+C*(5*N)+k*(5*I),V+=_U>>>13,_U&=8191;let MU=V+M*I+w*R+L*H+P*K+D*T;V=MU>>>13,MU&=8191,MU+=O*G+E*z+A*X+C*Q+k*(5*N),V+=MU>>>13,MU&=8191;let wU=V+M*N+w*I+L*R+P*H+D*K;V=wU>>>13,wU&=8191,wU+=O*T+E*G+A*z+C*X+k*Q,V+=wU>>>13,wU&=8191,V=(V<<2)+V|0,V=V+y|0,y=V&8191,V=V>>>13,f+=V,Z[0]=y,Z[1]=f,Z[2]=b,Z[3]=v,Z[4]=ZU,Z[5]=FU,Z[6]=SU,Z[7]=_U,Z[8]=MU,Z[9]=wU}finalize(){let{h:U,pad:$}=this,q=new Uint16Array(10),J=U[1]>>>13;U[1]&=8191;for(let Q=2;Q<10;Q++)U[Q]+=J,J=U[Q]>>>13,U[Q]&=8191;U[0]+=J*5,J=U[0]>>>13,U[0]&=8191,U[1]+=J,J=U[1]>>>13,U[1]&=8191,U[2]+=J,q[0]=U[0]+5,J=q[0]>>>13,q[0]&=8191;for(let Q=1;Q<10;Q++)q[Q]=U[Q]+J,J=q[Q]>>>13,q[Q]&=8191;q[9]-=8192;let Z=(J^1)-1;for(let Q=0;Q<10;Q++)q[Q]&=Z;Z=~Z;for(let Q=0;Q<10;Q++)U[Q]=U[Q]&Z|q[Q];U[0]=(U[0]|U[1]<<13)&65535,U[1]=(U[1]>>>3|U[2]<<10)&65535,U[2]=(U[2]>>>6|U[3]<<7)&65535,U[3]=(U[3]>>>9|U[4]<<4)&65535,U[4]=(U[4]>>>12|U[5]<<1|U[6]<<14)&65535,U[5]=(U[6]>>>2|U[7]<<11)&65535,U[6]=(U[7]>>>5|U[8]<<8)&65535,U[7]=(U[8]>>>8|U[9]<<5)&65535;let Y=U[0]+$[0];U[0]=Y&65535;for(let Q=1;Q<8;Q++)Y=(U[Q]+$[Q]|0)+(Y>>>16)|0,U[Q]=Y&65535;GU(q)}update(U){z0(this),m(U),U=OU(U);let{buffer:$,blockLen:q}=this,J=U.length;for(let Z=0;Z<J;){let Y=Math.min(q-this.pos,J-Z);if(Y===q){for(;q<=J-Z;Z+=q)this.process(U,Z);continue}if($.set(U.subarray(Z,Z+Y),this.pos),this.pos+=Y,Z+=Y,this.pos===q)this.process($,0,!1),this.pos=0}return this}destroy(){GU(this.h,this.r,this.buffer,this.pad)}digestInto(U){z0(this),u0(U,this),this.finished=!0;let{buffer:$,h:q}=this,{pos:J}=this;if(J){$[J++]=1;for(;J<16;J++)$[J]=0;this.process($,0,!0)}this.finalize();let Z=0;for(let Y=0;Y<8;Y++)U[Z++]=q[Y]>>>0,U[Z++]=q[Y]>>>8;return U}digest(){let{buffer:U,outputLen:$}=this;this.digestInto(U);let q=U.slice(0,$);return this.destroy(),q}}function Fq(U){let $=(J,Z)=>U(Z).update(J).digest(),q=U(new Uint8Array(32));return $.outputLen=q.outputLen,$.blockLen=q.blockLen,$.create=(J)=>U(J),$}var o0=(()=>Fq((U)=>new n0(U)))();function t0(U,$,q,J,Z,Y=20){let Q=U[0],X=U[1],z=U[2],G=U[3],T=$[0],K=$[1],H=$[2],R=$[3],I=$[4],N=$[5],B=$[6],j=$[7],S=Z,F=q[0],g=q[1],WU=q[2],c=Q,p=X,M=z,w=G,L=T,P=K,D=H,O=R,E=I,A=N,C=B,k=j,V=S,y=F,f=g,b=WU;for(let ZU=0;ZU<Y;ZU+=2)c=c+L|0,V=W(V^c,16),E=E+V|0,L=W(L^E,12),c=c+L|0,V=W(V^c,8),E=E+V|0,L=W(L^E,7),p=p+P|0,y=W(y^p,16),A=A+y|0,P=W(P^A,12),p=p+P|0,y=W(y^p,8),A=A+y|0,P=W(P^A,7),M=M+D|0,f=W(f^M,16),C=C+f|0,D=W(D^C,12),M=M+D|0,f=W(f^M,8),C=C+f|0,D=W(D^C,7),w=w+O|0,b=W(b^w,16),k=k+b|0,O=W(O^k,12),w=w+O|0,b=W(b^w,8),k=k+b|0,O=W(O^k,7),c=c+P|0,b=W(b^c,16),C=C+b|0,P=W(P^C,12),c=c+P|0,b=W(b^c,8),C=C+b|0,P=W(P^C,7),p=p+D|0,V=W(V^p,16),k=k+V|0,D=W(D^k,12),p=p+D|0,V=W(V^p,8),k=k+V|0,D=W(D^k,7),M=M+O|0,y=W(y^M,16),E=E+y|0,O=W(O^E,12),M=M+O|0,y=W(y^M,8),E=E+y|0,O=W(O^E,7),w=w+L|0,f=W(f^w,16),A=A+f|0,L=W(L^A,12),w=w+L|0,f=W(f^w,8),A=A+f|0,L=W(L^A,7);let v=0;J[v++]=Q+c|0,J[v++]=X+p|0,J[v++]=z+M|0,J[v++]=G+w|0,J[v++]=T+L|0,J[v++]=K+P|0,J[v++]=H+D|0,J[v++]=R+O|0,J[v++]=I+E|0,J[v++]=N+A|0,J[v++]=B+C|0,J[v++]=j+k|0,J[v++]=S+V|0,J[v++]=F+y|0,J[v++]=g+f|0,J[v++]=WU+b|0}function Sq(U,$,q,J){let Z=U[0],Y=U[1],Q=U[2],X=U[3],z=$[0],G=$[1],T=$[2],K=$[3],H=$[4],R=$[5],I=$[6],N=$[7],B=q[0],j=q[1],S=q[2],F=q[3];for(let WU=0;WU<20;WU+=2)Z=Z+z|0,B=W(B^Z,16),H=H+B|0,z=W(z^H,12),Z=Z+z|0,B=W(B^Z,8),H=H+B|0,z=W(z^H,7),Y=Y+G|0,j=W(j^Y,16),R=R+j|0,G=W(G^R,12),Y=Y+G|0,j=W(j^Y,8),R=R+j|0,G=W(G^R,7),Q=Q+T|0,S=W(S^Q,16),I=I+S|0,T=W(T^I,12),Q=Q+T|0,S=W(S^Q,8),I=I+S|0,T=W(T^I,7),X=X+K|0,F=W(F^X,16),N=N+F|0,K=W(K^N,12),X=X+K|0,F=W(F^X,8),N=N+F|0,K=W(K^N,7),Z=Z+G|0,F=W(F^Z,16),I=I+F|0,G=W(G^I,12),Z=Z+G|0,F=W(F^Z,8),I=I+F|0,G=W(G^I,7),Y=Y+T|0,B=W(B^Y,16),N=N+B|0,T=W(T^N,12),Y=Y+T|0,B=W(B^Y,8),N=N+B|0,T=W(T^N,7),Q=Q+K|0,j=W(j^Q,16),H=H+j|0,K=W(K^H,12),Q=Q+K|0,j=W(j^Q,8),H=H+j|0,K=W(K^H,7),X=X+z|0,S=W(S^X,16),R=R+S|0,z=W(z^R,12),X=X+z|0,S=W(S^X,8),R=R+S|0,z=W(z^R,7);let g=0;J[g++]=Z,J[g++]=Y,J[g++]=Q,J[g++]=X,J[g++]=B,J[g++]=j,J[g++]=S,J[g++]=F}var _q=W0(t0,{counterRight:!1,counterLength:4,allowShortKeys:!1}),Mq=W0(t0,{counterRight:!1,counterLength:8,extendNonceFn:Sq,allowShortKeys:!1});var wq=new Uint8Array(16),r0=(U,$)=>{U.update($);let q=$.length%16;if(q)U.update(wq.subarray(q))},Lq=new Uint8Array(32);function a0(U,$,q,J,Z){if(Z!==void 0)m(Z,void 0,"AAD");let Y=U($,q,Lq),Q=p0(J.length,Z?Z.length:0,!0),X=o0.create(Y);if(Z)r0(X,Z);r0(X,J),X.update(Q);let z=X.digest();return GU(Y,Q),z}var e0=(U)=>($,q,J)=>{return{encrypt(Y,Q){let X=Y.length;Q=T0(X+16,Q,!1),Q.set(Y);let z=Q.subarray(0,-16);U($,q,z,z,1);let G=a0(U,$,q,z,J);return Q.set(G,X),GU(G),Q},decrypt(Y,Q){Q=T0(Y.length-16,Q,!1);let X=Y.subarray(0,-16),z=Y.subarray(-16),G=a0(U,$,q,X,J);if(!c0(z,G))throw Error("invalid tag");return Q.set(Y.subarray(0,-16)),U($,q,Q,Q,1),GU(G),Q}}},fJ=G0({blockSize:64,nonceLength:12,tagLength:16},e0(_q)),H0=G0({blockSize:64,nonceLength:24,tagLength:16},e0(Mq));class qU extends XU{static IV_LENGTH=24;static TAG_LENGTH=16;IV_LENGTH=qU.IV_LENGTH;TAG_LENGTH=qU.TAG_LENGTH;key=null;constructor(U){super(U)}async setKey(U){this.key=new Uint8Array(await this.p.subtle.exportKey("raw",U))}zeroKey(){if(this.key)this.key.fill(0);this.key=null}async encryptWithAAD(U,$){let q=this.p.getRandomValues(new Uint8Array(qU.IV_LENGTH)),Z=H0(this.requireRawKey(),q,$).encrypt(U),Y=new Uint8Array(q.length+Z.length);return Y.set(q,0),Y.set(Z,q.length),Y}async decryptWithAAD(U,$){if(U.byteLength<qU.IV_LENGTH+qU.TAG_LENGTH)throw new x("Invalid ciphertext: too short.");let q=U.subarray(0,qU.IV_LENGTH),J=U.subarray(qU.IV_LENGTH),Z=H0(this.requireRawKey(),q,$);try{return Z.decrypt(J)}catch{throw new x("Decryption failed: wrong passphrase or corrupted ciphertext")}}requireRawKey(){if(!this.key)throw Error("Encryption key not set");return this.key}}import*as iU from"argon2-browser";async function Pq(){if(typeof window<"u")return;if(globalThis.loadArgon2WasmModule)return;try{let{createRequire:U}=await import("node:module"),{readFile:$}=await import("node:fs/promises"),q=U(import.meta.url),J=q.resolve("argon2-browser/dist/argon2.js"),Z=q.resolve("argon2-browser/dist/argon2.wasm");globalThis.loadArgon2WasmModule=async()=>{let Y=new Uint8Array(await $(Z));return globalThis.Module={wasmBinary:Y,locateFile:(Q)=>Q==="argon2.wasm"?Z:Q},q(J)}}catch{}}async function U$(U,$,q,J){if(J==="node"){let Z=await import("@node-rs/argon2"),Y=typeof U==="string"?Buffer.from(U,"utf8"):Buffer.from(U),X=(await Z.hash(Y,{salt:$,timeCost:q.time,memoryCost:q.mem,parallelism:q.parallelism,outputLen:32,algorithm:Z.Algorithm.Argon2id})).split("$").pop();if(!X)throw Error("Unexpected argon2 hash format");let z=Buffer.from(X,"base64");return Y.fill(0),{hash:new Uint8Array(z)}}if(J==="browser")return await Pq(),iU.hash({pass:U,salt:$,time:q.time,mem:q.mem,parallelism:q.parallelism,hashLen:32,type:iU.ArgonType.Argon2id}).then((Z)=>{if(!Z||!Z.hash)throw new QU("Failed to produce key derivation");return{hash:Z.hash}}).catch((Z)=>{let Y=Z instanceof Error?Z.message:typeof Z==="string"?Z:"Unknown error";throw new QU(`argon2-browser failure: ${Y}`)});throw Error(`Unsupported environment: ${J}`)}class sU{presets;exportExtractable;name="argon2id";constructor(U,$=!1){this.presets=U;this.exportExtractable=$}async derive(U,$,q,J){let{hash:Z}=await U$(U,$,this.presets[q],J.isNode?"node":"browser");if(this.exportExtractable)return J.subtle.importKey("raw",Z,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]);else return J.subtle.importKey("raw",Z,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}}var $$={low:{time:5,mem:65536,parallelism:1},middle:{time:20,mem:65536,parallelism:1},high:{time:40,mem:65536,parallelism:1}},Dq={id:0,cipher:$U,kdf:new sU($$),saltLengths:{low:12,high:16},difficulties:$$,defaultChunkSize:524288};d.register(Dq);var q$={low:{time:5,mem:65536,parallelism:2},middle:{time:10,mem:98304,parallelism:4},high:{time:20,mem:98304,parallelism:4}},Oq={id:1,cipher:qU,kdf:new sU(q$,!0),saltLengths:{low:12,high:16},difficulties:q$,defaultChunkSize:524288};d.register(Oq);var nU=1;function EU(U,$,q,J,Z){let Y={low:0,middle:1,high:2};if(!($ in Y))throw TypeError(`Unsupported difficulty: ${$}`);let Q=Y[$],X=U<<5|(q==="high"?1:0)<<2|Q,z=BU(new Uint8Array([nU,X]),J);if(Z)Z.setAAD(z);return z}function JU(U,$){if(U[0]!==nU)throw new r("Invalid input format. The input is unknown.");if(U.length<14)throw new r("Invalid input format. Header too short.");try{let q=U[1],J=q>>5,Z=q>>2&1?"high":"low",Y=q&3,Q=["low","middle","high"][Y],X=d.get(J).saltLengths[Z],z=2+X;if(U.length<z)throw new r("Invalid input format. Header truncated.");if($)$.setAAD(U.subarray(0,z));let G=U.slice(2,2+X);return{scheme:J,difficulty:Q,saltStrength:Z,salt:G,headerLen:z}}catch(q){throw new RU(q instanceof Error?q.message:String(q))}}async function oU(U){if(U instanceof Uint8Array)return U;if(U instanceof ArrayBuffer)return new Uint8Array(U);return new Uint8Array(await U.arrayBuffer())}function R0(U){let $=new Uint8Array(4);return new DataView($.buffer).setUint32(0,U,!1),$}function J$(U,$=0){if(U.length-$<4)throw RangeError("Not enough bytes for frame header");return new DataView(U.buffer,U.byteOffset+$,4).getUint32(0,!1)}var TU=4;class bU{engine;chunkSize;buffer=new Uint8Array(0);constructor(U,$=524288){this.engine=U;this.chunkSize=$}toTransformStream(){return new TransformStream({transform:async(U,$)=>{await this.transform(await oU(U),$)},flush:async(U)=>this.flush(U)})}async transform(U,$){if(U.length>Math.min(this.chunkSize*4,67108864))throw RangeError(`Input block (${U.length} B) exceeds maximum allowed ${Math.min(this.chunkSize*4,67108864)} B`);let J=new Uint8Array(this.buffer.length+U.length);J.set(this.buffer),J.set(U,this.buffer.length);let Z=0;while(J.length-Z>=this.chunkSize){let Y=J.slice(Z,Z+this.chunkSize);Z+=this.chunkSize;let Q=await this.engine.encryptChunk(Y),X=new Uint8Array(TU+Q.length);X.set(R0(Q.length)),X.set(Q,TU),$.enqueue(X)}this.buffer=J.slice(Z)}async flush(U){if(!this.buffer.length)return;let $=await this.engine.encryptChunk(this.buffer),q=new Uint8Array(TU+$.length);q.set(R0($.length)),q.set($,TU),U.enqueue(q),this.buffer=new Uint8Array(0),this.engine.zeroKey()}}class AU{engine;chunkSize;buffer=new Uint8Array(0);constructor(U,$=524288){this.engine=U;this.chunkSize=$}toTransformStream(){return new TransformStream({transform:async(U,$)=>{await this.transform(await oU(U),$)},flush:async(U)=>this.flush(U)})}async transform(U,$){let q=new Uint8Array(this.buffer.length+U.length);q.set(this.buffer),q.set(U,this.buffer.length);let J=0;while(!0){if(q.length-J<TU)break;let Z=J$(q,J);if(Z>this.chunkSize*2)throw new x(`Frame length ${Z} exceeds …`);if(q.length-J-TU<Z)break;J+=TU;let Y=q.slice(J,J+Z);J+=Z;try{let Q=await this.engine.decryptChunk(Y);$.enqueue(Q)}catch(Q){throw Q instanceof x?Q:new x("Decryption failed: Wrong passphrase or corrupted ciphertext")}}this.buffer=q.slice(J)}async flush(U){await this.transform(new Uint8Array(0),U),this.buffer=new Uint8Array(0),this.engine.zeroKey()}}async function Z$(U,$){let q=U.getReader(),J=$&&$.length?[$]:[];try{while(!0){let{value:X,done:z}=await q.read();if(z)break;J.push(X)}}finally{q.releaseLock()}let Z=J.reduce((X,z)=>X+z.byteLength,0),Y=new Uint8Array(Z),Q=0;for(let X of J)Y.set(X,Q),Q+=X.byteLength;return Y}class CU{engine;chunkSize;constructor(U,$=524288){this.engine=U;this.chunkSize=$}encryptionStream(){let U=new bU(this.engine,this.chunkSize).toTransformStream();return{writable:U.writable,readable:U.readable}}decryptionStream(U){let $=U,q=new TransformStream({transform(Z,Y){if($===0){Y.enqueue(Z);return}if(Z.byteLength<=$){$-=Z.byteLength;return}Y.enqueue(Z.slice($)),$=0}}),J=new AU(this.engine,this.chunkSize).toTransformStream();return{writable:q.writable,readable:q.readable.pipeThrough(J)}}async collect(U,$,q=null){return Z$(U.pipeThrough($),q??void 0)}getEngine(){return this.engine}}function Y$(U){try{if(U)U.fill(0)}catch{}}function Eq(U){let $="";for(let q=0;q<U.length;q++){let J=U[q].toString(16).padStart(2,"0");$+=J}return $}class KU{bytes;destroyed=!1;static from(U){if(U instanceof KU)return U;if(typeof U==="string")return new KU(new TextEncoder().encode(U));if(U instanceof Uint8Array)return new KU(U);throw TypeError("ConvertibleInput: unsupported input type")}constructor(U){this.bytes=U}toUint8Array(){if(this.destroyed)throw Error("ConvertibleInput: already cleared");return this.bytes}clear(){if(!this.destroyed)Y$(this.bytes),this.bytes=new Uint8Array(0),this.destroyed=!0}}class xU{bytes;destroyed=!1;constructor(U){this.bytes=U}get uint8array(){if(this.destroyed)throw Error("ConvertibleOutput: already cleared");return this.bytes}get base64(){if(this.destroyed)throw Error("ConvertibleOutput: already cleared");return DU(this.bytes)}get hex(){if(this.destroyed)throw Error("ConvertibleOutput: already cleared");return Eq(this.bytes)}get text(){if(this.destroyed)throw Error("ConvertibleOutput: already cleared");return new TextDecoder().decode(this.bytes)}clear(){if(!this.destroyed)Y$(this.bytes),this.bytes=new Uint8Array(0),this.destroyed=!0}toString(){return this.base64}}class gU extends Error{constructor(U="Malformed padding"){super(U)}}class h{static STRUCT_SIZE=8;static MAGIC40=new Uint8Array([227,122,193,93,180]);static VERSION=41;static CRC8_POLY=7;maxPad=h.STRUCT_SIZE+8-1;static ctEqU8(U,$){return(((U|0)^($|0))&255)===0}static ctEqFixedLen(U,$){let q=0,J=U.length;for(let Z=0;Z<J;Z++)q|=U[Z]^$[Z];return q===0}crc8(U){let $=0;for(let q=0;q<U.length;q++){$^=U[q]&255;for(let J=0;J<8;J++)$=$&128?$<<1^h.CRC8_POLY:$<<1,$&=255}return $&255}computeK(U,$){let q=h.STRUCT_SIZE;if(!Number.isInteger($)||$<1)throw new gU("align must be a positive integer");if(q+$-1>255)throw new gU("align too large for 1-byte LEN");let J=q+$-1,Z=($-U%$)%$;if(Z===0)Z=$;while(Z<q)Z+=$;if(Z>J)throw new gU("Cannot satisfy alignment within 1-byte LEN");return Z}pad(U,$,q=8){let J=h.STRUCT_SIZE,Z=this.computeK(U.length,q),Y=Z-J,Q=new Uint8Array(U.length+Z);if(Q.set(U,0),Y>0){let G=$(Y);if(!G||G.length!==Y)throw new gU("rng returned wrong length");Q.set(G,U.length)}let X=U.length+Y;Q.set(h.MAGIC40,X+0),Q[X+5]=h.VERSION&255,Q[X+6]=Z&255;let z=new Uint8Array(7);return z.set(h.MAGIC40,0),z[5]=h.VERSION&255,z[6]=Z&255,Q[X+7]=this.crc8(z),Q}tryUnpad(U){let $=h.STRUCT_SIZE,q=()=>({used:!1,plain:U});if(U.length<$)return q();let J=U.length,Z=U[J-1]&255,Y=U[J-2]&255,Q=U[J-3]&255;if(Y<$||Y>U.length)return q();let X=J-$,z=U.subarray(X,X+5);if(!h.ctEqFixedLen(z,h.MAGIC40))return q();if(!h.ctEqU8(Q,h.VERSION&255))return q();let T=new Uint8Array(7);T.set(h.MAGIC40,0),T[5]=Q,T[6]=Y;let K=this.crc8(T);if(!h.ctEqU8(K,Z))return q();return{used:!0,plain:U.subarray(0,J-Y)}}}function Q$(U=0,$=console.info){return{level:U,log(q,J){if(q<=U)$(`${q}| ${J}`)}}}var X$=new WeakMap;class IU{static getEngine(U,$){let q=X$.get(U);if(!q)q=new Map,X$.set(U,q);let J=q.get($);if(J)return J;let Z=d.get($);return J={desc:Z,cipher:new Z.cipher(U),kdf:Z.kdf,chunkSize:Z.defaultChunkSize,provider:U},q.set($,J),J}static async deriveKey(U,$,q,J){try{let Z=await U.kdf.derive($.value,q,J,U.provider);await U.cipher.setKey(Z)}catch(Z){let Y=Z instanceof Error?Z.message:String(Z);throw new QU(Y)}finally{i($)}}}class s{provider;v;cipher;kdf;chunkSize;stream;acceptUnauthenticatedHeader;difficulty;saltStrength;engines=new Map;log;constructor(U,$={}){this.provider=U;this.v=d.get($.scheme??d.current.id),this.cipher=new this.v.cipher(U),this.kdf=this.v.kdf,this.chunkSize=this.setChunkSize($.chunkSize??this.v.defaultChunkSize),this.stream=new CU(this.cipher,this.chunkSize),this.difficulty=$.difficulty??"middle",this.saltStrength=$.saltStrength??"high",this.acceptUnauthenticatedHeader=$.acceptUnauthenticatedHeader??!1,this.log=Q$($.verbose??0,$.logger)}static async isEncrypted(U){try{return await s.peekHeader(U),!0}catch{return!1}}static async decodeHeader(U){let $=await s.peekHeader(U),q=JU($);return{scheme:q.scheme,difficulty:q.difficulty,salt:DU(q.salt),saltBytes:q.salt,saltLength:q.salt.byteLength}}static async headerDecode(U){return this.decodeHeader(U)}static isRandomAccessSource(U){return typeof U==="object"&&U!==null&&typeof U.read==="function"}static async decodeData(U){let $=s.isRandomAccessSource(U)?U:new X0(U),q=await $.read(0,Math.min(256,$.length)),J=await s.peekHeader(q),{scheme:Z,headerLen:Y}=JU(J),Q=$.length,X=Q-Y;if(X<=0)throw new r("Payload is empty");let z=await $.read(Y,4),G=new DataView(z.buffer,z.byteOffset,4).getUint32(0,!1);if(G+4<=X&&G>=28){let I=G,N=Y,B=0,j=0;while(N+4<=Q){let S=await $.read(N,4),F=new DataView(S.buffer,S.byteOffset,4).getUint32(0,!1);if(F===0||N+4+F>Q)break;B++,j+=F,N+=4+F}return{isChunked:!0,chunks:{chunkSize:I,count:B,totalPayload:j}}}let K=await $.read(Y,X),H=d.get(Z).cipher.IV_LENGTH,R=d.get(Z).cipher.TAG_LENGTH;if(K.length<H+R)throw new r("Ciphertext too short for IV & tag");return{isChunked:!1,payloadLength:X-H-R,params:{iv:K.slice(0,H),ivLength:H,tag:K.slice(K.length-R),tagLength:R}}}setDifficulty(U){this.difficulty=U}getDifficulty(){return this.difficulty}setScheme(U){this.v=d.get(U),this.cipher=new this.v.cipher(this.provider),this.kdf=this.v.kdf,this.stream=new CU(this.cipher,this.chunkSize)}getScheme(){return this.v.id}setSaltDifficulty(U){this.saltStrength=U}getSaltDifficulty(){return this.saltStrength}setChunkSize(U){let q=U,J;if(q==null)J=this.v.defaultChunkSize;else{if(J=Number(q),!Number.isInteger(J)||J<1)throw Error(`Invalid chunkSize: ${q}. Must be a positive integer.`);if(J>134217728)throw RangeError("chunkSize cannot exceed 134217728 bytes.")}if(this.chunkSize=J,this.stream)this.stream=new CU(this.cipher,this.chunkSize);return J}getChunkSize(){return this.chunkSize}setVerbose(U){this.log.level=U}getVerbose(){return this.log.level}async encryptText(U,$){if($===null)throw new UU("Password can't be null");let q={value:$};try{if($==="")this.log.log(0,"Empty passphrase provided to encryptText");this.log.log(1,`Start text encryption, scheme: ${this.getScheme()}`);let J=KU.from(U),Z=J.toUint8Array();this.log.log(2,"Deriving key for text encryption");let Y=this.genSalt();await this.deriveKey(q,Y),i(q),$=null,this.log.log(3,`Salt generated: ${DU(Y)}, KDF difficulty: ${this.difficulty}`),this.log.log(3,"Encoding header");let Q=EU(this.v.id,this.difficulty,this.saltStrength,Y,this.cipher);this.cipher.setPaddingScheme(new h),this.cipher.setPaddingAlign(8),this.cipher.setPaddingAADMode("require"),this.log.log(2,"Encrypting text data");let X=await this.cipher.encryptChunk(Z);this.cipher.zeroKey();try{J.clear()}catch{}let z=BU(Q,X);return this.log.log(1,"Encryption finished"),new xU(z)}catch(J){throw new UU(J instanceof Error?J.message:String(J))}}async decryptText(U,$){if($===null)throw new UU("Password can't be null");let q={value:$};try{if($==="")this.log.log(0,"Empty passphrase provided to decryptText");this.log.log(1,`Start text decryption, Version ${this.getScheme()}`);let J;if(typeof U==="string")this.log.log(3,"Decoding Base64 ciphertext"),J=yU(U);else if(U instanceof Uint8Array)J=U;else if(U instanceof KU)J=U.toUint8Array();else throw new LU("Unsupported ciphertext input type");this.log.log(3,"Start header decoding");let Z=JU(J);this.log.log(3,"Selecting decryption engine");let Y=IU.getEngine(this.provider,Z.scheme);this.log.log(2,`Deriving key via engine for scheme: ${Z.scheme}`),this.log.log(3,`Salt use: ${DU(Z.salt)}, KDF difficulty: ${Z.difficulty}`);try{await IU.deriveKey(Y,q,Z.salt,Z.difficulty)}finally{i(q),$=null}Y.cipher.setPaddingScheme(new h),Y.cipher.setPaddingAlign(8),Y.cipher.setPaddingAADMode("require"),Y.cipher.setLegacyAADFallback({enabled:!0,policy:"auto",tryEmptyAAD:this.acceptUnauthenticatedHeader?!0:!1}),this.log.log(2,"Decrypting text data"),JU(J,Y.cipher);let Q=await Y.cipher.decryptChunk(J.slice(Z.headerLen));if(Y.cipher.zeroKey(),U instanceof KU)try{U.clear()}catch{}return this.log.log(1,"Decryption finished"),new xU(Q)}catch(J){if(J instanceof x||J instanceof r||J instanceof RU||J instanceof LU||J instanceof QU)throw J;throw new x("Decryption failed: wrong passphrase or corrupted ciphertext")}}async encryptFile(U,$){if($===null)throw new UU("Password can't be null");let q={value:$};try{if(U.size===0){let Q=this.genSalt();await this.deriveKey(q,Q),i(q),$=null;let X=EU(this.v.id,this.difficulty,this.saltStrength,Q);return new Blob([X],{type:"application/octet-stream"})}this.log.log(2,"Deriving key for file encryption");let J=this.genSalt();await this.deriveKey(q,J),i(q),$=null;let Z=EU(this.v.id,this.difficulty,this.saltStrength,J,this.stream.getEngine());this.stream.getEngine().setPaddingAADMode("forbid");let Y=await this.stream.collect(U.stream(),new bU(this.cipher,this.chunkSize).toTransformStream(),Z);return new Blob([Y],{type:"application/octet-stream"})}catch(J){throw new UU(J instanceof Error?J.message:String(J))}}async decryptFile(U,$){if($===null)throw new UU("Password can't be null");let q={value:$};try{let J=await s.peekHeader(U),Z=JU(J),Y=IU.getEngine(this.provider,Z.scheme);try{await IU.deriveKey(Y,q,Z.salt,Z.difficulty)}finally{i(q),$=null}if(U.size===Z.headerLen)return new Blob([],{type:"application/octet-stream"});this.log.log(2,"Decrypting file data");let Q=new CU(Y.cipher,Y.chunkSize);JU(J,Q.getEngine()),Y.cipher.setPaddingAADMode("forbid"),Y.cipher.setLegacyAADFallback({enabled:!0,policy:"auto",tryEmptyAAD:this.acceptUnauthenticatedHeader?!0:!1});let X=await Q.collect(U.slice(Z.headerLen).stream(),new AU(Y.cipher,Y.chunkSize).toTransformStream());return new Blob([X],{type:"application/octet-stream"})}catch(J){if(J instanceof x)throw J;throw new x(J instanceof Error?J.message:String(J))}}async createEncryptionStream(U){if(U===null)throw new UU("Password can't be null");let $={value:U};this.log.log(2,"Deriving key for stream encryption");let q=this.genSalt();await this.deriveKey($,q),i($),U=null;let J=EU(this.v.id,this.difficulty,this.saltStrength,q,this.stream.getEngine());this.stream.getEngine().setPaddingAADMode("forbid");let Z=this.stream.encryptionStream();return{header:J,writable:Z.writable,readable:Z.readable}}async createDecryptionStream(U){if(U===null)throw new UU("Password can't be null");let $=this.provider,q={value:U},J=new Uint8Array(0),Z=null,Y=65536,Q=14,X=async(z,G)=>{let T=z.getReader();while(!0){let{value:K,done:H}=await T.read();if(H)break;G.enqueue(K)}};return new TransformStream({transform:async(z,G)=>{if(!Z){if(z&&z.byteLength){if(J.byteLength+z.byteLength>Y){i(q),G.error(new r(`Header not found within ${Y} bytes`));return}J=BU(J,z)}if(J.byteLength<Q)return;let K=J[1],H=K>>5,R=K>>2&1?"high":"low",I=0;try{I=2+d.get(H).saltLengths[R]}catch(F){i(q),G.error(new RU(F instanceof Error?F.message:String(F)));return}if(J.byteLength<I)return;let N=J.subarray(0,I),B;try{B=JU(N)}catch(F){i(q),G.error(F instanceof Error?F:new RU("Invalid header"));return}let j=IU.getEngine($,B.scheme);try{await IU.deriveKey(j,q,B.salt,B.difficulty)}finally{i(q),U=null}JU(N,j.cipher),j.cipher.setPaddingAADMode("forbid"),j.cipher.setLegacyAADFallback({enabled:!0,policy:"auto",tryEmptyAAD:this.acceptUnauthenticatedHeader?!0:!1}),Z=new AU(j.cipher,j.chunkSize).toTransformStream(),X(Z.readable,G).catch((F)=>G.error(F));let S=J.subarray(I);if(J=new Uint8Array(0),S.byteLength){let F=Z.writable.getWriter();await F.write(S),F.releaseLock()}return}let T=Z.writable.getWriter();await T.write(z),T.releaseLock()},flush:async()=>{if(!Z)throw i(q),new r("Header not found before end of stream");let z=Z.writable.getWriter();await z.close(),z.releaseLock()}})}generateFakeData(U=0){if(!Number.isInteger(U)||U<0)throw RangeError("payloadLength must be a non-negative integer.");let $=this.genSalt(),q=EU(this.v.id,this.difficulty,this.saltStrength,$,this.cipher),J=U>0?this.provider.getRandomValues(new Uint8Array(U)):new Uint8Array(0);return BU(q,J)}async deriveKey(U,$,q=this.difficulty){let J=performance.now();try{let Z=await this.kdf.derive(U.value,$,q,this.provider);i(U),await this.cipher.setKey(Z),this.log.log(3,`Key derivation completed in ${(performance.now()-J).toFixed(1)} ms`)}catch(Z){throw new QU(Z instanceof Error?Z.message:String(Z))}}genSalt(U=this.saltStrength){let $=this.v.saltLengths[U];return this.provider.getRandomValues(new Uint8Array($))}static async peekHeader(U){let $=await this.readAsUint8(U);if($ instanceof Uint8Array){if($.length<2)throw new r("Input too short");let{headerLen:q}=JU($.length>=16?$:Uint8Array.from($));if($.length<q)throw new r("Incomplete header");return $.slice(0,q)}throw new RU("Unsupported input type")}static async readAsUint8(U){if(typeof U==="string")return yU(U);if(U instanceof Blob){let $=U.slice(0,64);return new Uint8Array(await $.arrayBuffer())}return U}}import{webcrypto as Aq,randomFillSync as Cq}from"node:crypto";var z$={subtle:Aq.subtle,getRandomValues(U){return Cq(U),U},isNode:!0};function kU(U){return new s(z$,U)}import{dirname as bq,resolve as T$,sep as xq,isAbsolute as gq}from"node:path";import{Readable as kq,Writable as vq}from"node:stream";function I0(U){return kq.toWeb(U)}function N0(U){return vq.toWeb(U)}import{promises as jU}from"fs";import*as H$ from"os";import*as V0 from"path";var hq="2.2.0",mq=process.cwd();async function rU(){if(!a.isTTY)throw Error("STDIN not a TTY; use --pass");l.write("Passphrase: "),a.setRawMode?.(!0),a.resume(),a.setEncoding("utf8");let U="";return new Promise(($)=>{function q(){a.setRawMode?.(!1),a.pause(),l.write(`
`),a.off("data",J),$(U)}function J(Z){if(Z==="\x03")n(130);if(Z==="\r"||Z===`
`)return q();if(Z==="\b"||Z===""){U=U.slice(0,-1);return}U+=Z}a.on("data",J)})}function F0(U,$=mq){if(U==="-")return;let q=G$($),J=gq(U)?T$(U):T$(q,U),Z=bq(J);if(!G$(Z).startsWith(q+xq))throw new PU("Refusing to write outside of root directory.");if(!B0(Z))throw new PU(`Output directory does not exist: ${Z}`);try{yq(Z,fq.W_OK)}catch{throw new PU("Output directory is not writeable")}return J}async function W$(){let U=[];for await(let $ of a)U.push($);return Buffer.concat(U).toString("utf8")}var o=new h0;o.name("cryptit").version(hq).description(`Text and File Encryption Utility
Scheme 0: AES-GCM (Native) / Argon2id (Single Thread)
Scheme 1: XChaCha20-Poly1305 (JS Engine) / Argon2id (Parallel)`).showHelpAfterError().showSuggestionAfterError().addOption(new VU("-S, --scheme <0-1>","encryption scheme version").argParser((U)=>{let $=Number(U);if(!Number.isInteger($)||$<0||$>7)throw Error("Version size must be a integer between 0 and 7");return $}).default(0,"0")).addOption(new VU("-p, --pass <passphrase>","passphrase (prompt if omitted)").hideHelp().argParser((U)=>{if(!U.trim())throw Error("Passphrase cannot be empty");return U})).addOption(new VU("-d, --difficulty <level>","argon2 difficulty").choices(["low","middle","high"]).default("middle","middle")).addOption(new VU("-s, --salt-strength <variant>","salt length variant").choices(["low","high"]).default("high","high")).addOption(new VU("-c, --chunk-size <bytes>","chunk size in bytes").argParser((U)=>{let $=Number(U);if(!Number.isInteger($)||$<=0)throw Error("Chunk size must be a positive integer");return $}).default(524288,"512*1024")).addOption(new VU("-v, --verbose","increase verbosity (use multiple times)").default(0).argParser((U,$)=>{return $+1}));process.on("uncaughtException",(U)=>{if(U instanceof Error){let $=U.constructor.name,q=U.message;l.write(`Error [${$}]: ${q}
`)}else l.write(`Error [Unknown]: ${String(U)}
`);n(1)});process.on("unhandledRejection",(U)=>{if(U instanceof Error){let $=U.constructor.name,q=U.message;l.write(`Error [${$}]: ${q}
`)}else l.write(`Error [Unknown]: ${String(U)}
`);n(1)});o.command("decode [src]").description("Show Cryptit header information plus payload details; omit arg or use - to read from STDIN").action(async(U)=>{let $=!U||U==="-";async function q(z){if(z.length<2)throw Error("Input too short for header");let G=z.subarray(0,Math.min(256,z.length)),T=await s.decodeHeader(G),K=await s.decodeData(z);if(delete T.saltBytes,K.isChunked){let{chunkSize:I,count:N,totalPayload:B}=K.chunks;return{...T,isChunked:!0,chunks:{chunkSize:I,count:N,totalPayload:B}}}let H=Buffer.from(K.params.iv).toString("base64"),R=Buffer.from(K.params.tag).toString("base64");return{...T,isChunked:!1,payloadLength:K.payloadLength,params:{iv:H,ivLength:K.params.ivLength,tag:R,tagLength:K.params.tagLength}}}async function J(z){let G=await z.read(0,Math.min(256,z.length)),T=await s.decodeHeader(G),K=await s.decodeData(z);if(delete T.saltBytes,K.isChunked){let{chunkSize:I,count:N,totalPayload:B}=K.chunks;return{...T,isChunked:!0,chunks:{chunkSize:I,count:N,totalPayload:B}}}let H=Buffer.from(K.params.iv).toString("base64"),R=Buffer.from(K.params.tag).toString("base64");return{...T,isChunked:!1,payloadLength:K.payloadLength,params:{iv:H,tag:R}}}async function Z(){let z=Number(process.env.CRYPTIT_STDIN_MAX_BYTES),G=Number.isFinite(z)&&z>0?Math.floor(z):10073741824,T=await jU.mkdtemp(V0.join(H$.tmpdir(),"cryptit-")),K=V0.join(T,"stdin.bin"),H=j0(K,{flags:"w"}),R=0;try{for await(let I of process.stdin){let N=Buffer.isBuffer(I)?I:Buffer.from(I);if(R+=N.length,R>G)throw H.destroy(),await jU.rm(T,{recursive:!0,force:!0}).catch(()=>{}),new PU(`STDIN exceeds maximum allowed size (${G} bytes). Aborting.`);if(!H.write(N))await new Promise((B)=>H.once("drain",B))}return await new Promise((I,N)=>{H.end(()=>I()),H.on("error",N)}),K}catch(I){throw H.destroy(),await jU.rm(T,{recursive:!0,force:!0}).catch(()=>{}),I}}if(!$&&U){let z=await fU.open(U);try{let G=await J(z);t.write(JSON.stringify(G,null,2)+`
`)}finally{await z.close()}return}if($){let z=await Z(),G=await fU.open(z);try{try{let I=await J(G);t.write(JSON.stringify(I,null,2)+`
`);return}catch{}}finally{await G.close()}let T=(await jU.readFile(z,{encoding:"utf8"})).trim();if(await jU.unlink(z),!(/^[A-Za-z0-9+/]+={0,2}$/.test(T)&&T.length%4===0))l.write(`Error: Input neither valid Cryptit binary nor Base-64 text
`),n(1);let H=Buffer.from(T,"base64"),R=await q(new Uint8Array(H));t.write(JSON.stringify(R,null,2)+`
`);return}let Y=Buffer.from(U,"utf8"),Q=Y.toString("utf8").trim(),X=/^[A-Za-z0-9+/]+={0,2}$/.test(Q)&&Q.length%4===0;try{if(X){let z=Buffer.from(Q,"base64"),G=await q(new Uint8Array(z));t.write(JSON.stringify(G,null,2)+`
`)}else{let z=await q(new Uint8Array(Y));t.write(JSON.stringify(z,null,2)+`
`)}}catch(z){let G=z instanceof Error?z.message:String(z);l.write(`Error: ${G}
`),n(1)}});o.command("encrypt <src>").description("Encrypt file; use - for STDIN, --out - for STDOUT").option("-p, --pass <passphrase>","passphrase (prompt if omitted)").option("-o, --out <file>","output file (default STDOUT)","-").action(async(U,$)=>{if(U!=="-"&&!B0(U))l.write(`Error: input file not found: ${U}
`),n(1);let q=o.opts(),J=kU({difficulty:q.difficulty,saltStrength:q.saltStrength,chunkSize:q.chunkSize,verbose:q.verbose,scheme:q.scheme}),Z=q.pass??(a.isTTY?await rU():(()=>{l.write(`Use --pass when piping via STDIN
`),n(1)})());try{F0($.out)}catch(R){l.write(`Error: ${R.message}
`),n(1)}let Y=U==="-"?a:K$(U),Q=$.out==="-"?t:j0($.out),{header:X,writable:z,readable:G}=await J.createEncryptionStream(Z),T=I0(Y),K=N0(Q),H=K.getWriter();await H.write(X),H.releaseLock(),await Promise.all([T.pipeTo(z),G.pipeTo(K)])});o.command("decrypt <src>").description("Decrypt file; use - for STDIN, --out - for STDOUT").option("-p, --pass <passphrase>","passphrase (prompt if omitted)").option("-o, --out <file>","output file (default STDOUT)","-").option("--legacy","Enable text decryption of version < 1.0.0",!1).action(async(U,$)=>{if(U!=="-"&&!B0(U))l.write(`Error: input file not found: ${U}
`),n(1);let q=o.opts(),J=kU({difficulty:q.difficulty,saltStrength:q.saltStrength,chunkSize:q.chunkSize,verbose:q.verbose,scheme:q.scheme,acceptUnauthenticatedHeader:$.legacy});try{F0($.out)}catch(T){l.write(`Error: ${T.message}
`),n(1)}let Z=q.pass??await rU(),Y=U==="-"?a:K$(U),Q=$.out==="-"?t:j0($.out),X=I0(Y),z=N0(Q),G=await J.createDecryptionStream(Z);await Promise.all([X.pipeTo(G.writable),G.readable.pipeTo(z)])});o.command("encrypt-text [text]").description("Encrypt plaintext; omit arg to read from STDIN").option("-p, --pass <passphrase>","passphrase (prompt if omitted)").action(async(U)=>{let $=o.opts(),q=kU({difficulty:$.difficulty,saltStrength:$.saltStrength,verbose:$.verbose,scheme:$.scheme}),J=$.pass??(a.isTTY?await rU():(()=>{l.write(`Use --pass when piping via STDIN
`),n(1)})()),Z=U??await W$(),Y=await q.encryptText(Z,J);t.write(Y.base64+`
`)});o.command("decrypt-text [b64]").description("Decrypt Base64 ciphertext; omit arg to read from STDIN").option("-p, --pass <passphrase>","passphrase (prompt if omitted)").option("--legacy","Enable text decryption of version < 1.0.0",!1).action(async(U,$)=>{let q=o.opts(),J=kU({difficulty:q.difficulty,saltStrength:q.saltStrength,verbose:q.verbose,scheme:q.scheme,acceptUnauthenticatedHeader:$.legacy}),Z=q.pass??await rU(),Y=U??(await W$()).trim();if(!/^[A-Za-z0-9+/]+={0,2}$/.test(Y))l.write(`Error: ciphertext does not look like Base64
`),n(1);let Q=await J.decryptText(Y,Z);t.write(Q.text+`
`)});o.command("fake-data <length>").description("Emit a valid Cryptit header followed by <length> random bytes").option("-o, --out <file>","output file (default STDOUT)","-").option("--base64","encode output as Base64 text (adds trailing newline)").action(async(U,$)=>{let q=Number(U);if(!Number.isInteger(q)||q<0)l.write(`Error: <length> must be a non-negative integer
`),n(1);let J=o.opts(),Z=kU({difficulty:J.difficulty,saltStrength:J.saltStrength,chunkSize:J.chunkSize,verbose:J.verbose,scheme:J.scheme});try{F0($.out)}catch(X){l.write(`Error: ${X.message}
`),n(1)}let Y=Z.generateFakeData(q),Q=Buffer.from(Y);if($.base64){let X=Q.toString("base64")+`
`;if($.out==="-")t.write(X);else await jU.writeFile($.out,X,{encoding:"utf8"});return}if($.out==="-")t.write(Q);else await jU.writeFile($.out,Q)});if(process.argv.length<=2)o.outputHelp(),process.exit(1);o.parse();

//# debugId=86143B30E363311664756E2164756E21
