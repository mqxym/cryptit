#!/usr/bin/env node
import{createRequire as j$}from"node:module";var V$=Object.create;var{getPrototypeOf:N$,defineProperty:F0,getOwnPropertyNames:I$}=Object;var B$=Object.prototype.hasOwnProperty;var hU=(U,$,q)=>{q=U!=null?V$(N$(U)):{};let J=$||!U||!U.__esModule?F0(q,"default",{value:U,enumerable:!0}):q;for(let Z of I$(U))if(!B$.call(J,Z))F0(J,Z,{get:()=>U[Z],enumerable:!0});return J};var IU=(U,$)=>()=>($||U(($={exports:{}}).exports,$),$.exports);var HU=j$(import.meta.url);var vU=IU((S$)=>{class tU extends Error{constructor(U,$,q){super(q);Error.captureStackTrace(this,this.constructor),this.name=this.constructor.name,this.code=$,this.exitCode=U,this.nestedError=void 0}}class _0 extends tU{constructor(U){super(1,"commander.invalidArgument",U);Error.captureStackTrace(this,this.constructor),this.name=this.constructor.name}}S$.CommanderError=tU;S$.InvalidArgumentError=_0});var mU=IU((P$)=>{var{InvalidArgumentError:M$}=vU();class M0{constructor(U,$){switch(this.description=$||"",this.variadic=!1,this.parseArg=void 0,this.defaultValue=void 0,this.defaultValueDescription=void 0,this.argChoices=void 0,U[0]){case"<":this.required=!0,this._name=U.slice(1,-1);break;case"[":this.required=!1,this._name=U.slice(1,-1);break;default:this.required=!0,this._name=U;break}if(this._name.endsWith("..."))this.variadic=!0,this._name=this._name.slice(0,-3)}name(){return this._name}_collectValue(U,$){if($===this.defaultValue||!Array.isArray($))return[U];return $.push(U),$}default(U,$){return this.defaultValue=U,this.defaultValueDescription=$,this}argParser(U){return this.parseArg=U,this}choices(U){return this.argChoices=U.slice(),this.parseArg=($,q)=>{if(!this.argChoices.includes($))throw new M$(`Allowed choices are ${this.argChoices.join(", ")}.`);if(this.variadic)return this._collectValue($,q);return $},this}argRequired(){return this.required=!0,this}argOptional(){return this.required=!1,this}}function w$(U){let $=U.name()+(U.variadic===!0?"...":"");return U.required?"<"+$+">":"["+$+"]"}P$.Argument=M0;P$.humanReadableArgName=w$});var eU=IU((E$)=>{var{humanReadableArgName:O$}=mU();class w0{constructor(){this.helpWidth=void 0,this.minWidthToWrap=40,this.sortSubcommands=!1,this.sortOptions=!1,this.showGlobalOptions=!1}prepareContext(U){this.helpWidth=this.helpWidth??U.helpWidth??80}visibleCommands(U){let $=U.commands.filter((J)=>!J._hidden),q=U._getHelpCommand();if(q&&!q._hidden)$.push(q);if(this.sortSubcommands)$.sort((J,Z)=>{return J.name().localeCompare(Z.name())});return $}compareOptions(U,$){let q=(J)=>{return J.short?J.short.replace(/^-/,""):J.long.replace(/^--/,"")};return q(U).localeCompare(q($))}visibleOptions(U){let $=U.options.filter((J)=>!J.hidden),q=U._getHelpOption();if(q&&!q.hidden){let J=q.short&&U._findOption(q.short),Z=q.long&&U._findOption(q.long);if(!J&&!Z)$.push(q);else if(q.long&&!Z)$.push(U.createOption(q.long,q.description));else if(q.short&&!J)$.push(U.createOption(q.short,q.description))}if(this.sortOptions)$.sort(this.compareOptions);return $}visibleGlobalOptions(U){if(!this.showGlobalOptions)return[];let $=[];for(let q=U.parent;q;q=q.parent){let J=q.options.filter((Z)=>!Z.hidden);$.push(...J)}if(this.sortOptions)$.sort(this.compareOptions);return $}visibleArguments(U){if(U._argsDescription)U.registeredArguments.forEach(($)=>{$.description=$.description||U._argsDescription[$.name()]||""});if(U.registeredArguments.find(($)=>$.description))return U.registeredArguments;return[]}subcommandTerm(U){let $=U.registeredArguments.map((q)=>O$(q)).join(" ");return U._name+(U._aliases[0]?"|"+U._aliases[0]:"")+(U.options.length?" [options]":"")+($?" "+$:"")}optionTerm(U){return U.flags}argumentTerm(U){return U.name()}longestSubcommandTermLength(U,$){return $.visibleCommands(U).reduce((q,J)=>{return Math.max(q,this.displayWidth($.styleSubcommandTerm($.subcommandTerm(J))))},0)}longestOptionTermLength(U,$){return $.visibleOptions(U).reduce((q,J)=>{return Math.max(q,this.displayWidth($.styleOptionTerm($.optionTerm(J))))},0)}longestGlobalOptionTermLength(U,$){return $.visibleGlobalOptions(U).reduce((q,J)=>{return Math.max(q,this.displayWidth($.styleOptionTerm($.optionTerm(J))))},0)}longestArgumentTermLength(U,$){return $.visibleArguments(U).reduce((q,J)=>{return Math.max(q,this.displayWidth($.styleArgumentTerm($.argumentTerm(J))))},0)}commandUsage(U){let $=U._name;if(U._aliases[0])$=$+"|"+U._aliases[0];let q="";for(let J=U.parent;J;J=J.parent)q=J.name()+" "+q;return q+$+" "+U.usage()}commandDescription(U){return U.description()}subcommandDescription(U){return U.summary()||U.description()}optionDescription(U){let $=[];if(U.argChoices)$.push(`choices: ${U.argChoices.map((q)=>JSON.stringify(q)).join(", ")}`);if(U.defaultValue!==void 0){if(U.required||U.optional||U.isBoolean()&&typeof U.defaultValue==="boolean")$.push(`default: ${U.defaultValueDescription||JSON.stringify(U.defaultValue)}`)}if(U.presetArg!==void 0&&U.optional)$.push(`preset: ${JSON.stringify(U.presetArg)}`);if(U.envVar!==void 0)$.push(`env: ${U.envVar}`);if($.length>0){let q=`(${$.join(", ")})`;if(U.description)return`${U.description} ${q}`;return q}return U.description}argumentDescription(U){let $=[];if(U.argChoices)$.push(`choices: ${U.argChoices.map((q)=>JSON.stringify(q)).join(", ")}`);if(U.defaultValue!==void 0)$.push(`default: ${U.defaultValueDescription||JSON.stringify(U.defaultValue)}`);if($.length>0){let q=`(${$.join(", ")})`;if(U.description)return`${U.description} ${q}`;return q}return U.description}formatItemList(U,$,q){if($.length===0)return[];return[q.styleTitle(U),...$,""]}groupItems(U,$,q){let J=new Map;return U.forEach((Z)=>{let Y=q(Z);if(!J.has(Y))J.set(Y,[])}),$.forEach((Z)=>{let Y=q(Z);if(!J.has(Y))J.set(Y,[]);J.get(Y).push(Z)}),J}formatHelp(U,$){let q=$.padWidth(U,$),J=$.helpWidth??80;function Z(K,T){return $.formatItem(K,q,T,$)}let Y=[`${$.styleTitle("Usage:")} ${$.styleUsage($.commandUsage(U))}`,""],Q=$.commandDescription(U);if(Q.length>0)Y=Y.concat([$.boxWrap($.styleCommandDescription(Q),J),""]);let z=$.visibleArguments(U).map((K)=>{return Z($.styleArgumentTerm($.argumentTerm(K)),$.styleArgumentDescription($.argumentDescription(K)))});if(Y=Y.concat(this.formatItemList("Arguments:",z,$)),this.groupItems(U.options,$.visibleOptions(U),(K)=>K.helpGroupHeading??"Options:").forEach((K,T)=>{let R=K.map((H)=>{return Z($.styleOptionTerm($.optionTerm(H)),$.styleOptionDescription($.optionDescription(H)))});Y=Y.concat(this.formatItemList(T,R,$))}),$.showGlobalOptions){let K=$.visibleGlobalOptions(U).map((T)=>{return Z($.styleOptionTerm($.optionTerm(T)),$.styleOptionDescription($.optionDescription(T)))});Y=Y.concat(this.formatItemList("Global Options:",K,$))}return this.groupItems(U.commands,$.visibleCommands(U),(K)=>K.helpGroup()||"Commands:").forEach((K,T)=>{let R=K.map((H)=>{return Z($.styleSubcommandTerm($.subcommandTerm(H)),$.styleSubcommandDescription($.subcommandDescription(H)))});Y=Y.concat(this.formatItemList(T,R,$))}),Y.join(`
`)}displayWidth(U){return P0(U).length}styleTitle(U){return U}styleUsage(U){return U.split(" ").map(($)=>{if($==="[options]")return this.styleOptionText($);if($==="[command]")return this.styleSubcommandText($);if($[0]==="["||$[0]==="<")return this.styleArgumentText($);return this.styleCommandText($)}).join(" ")}styleCommandDescription(U){return this.styleDescriptionText(U)}styleOptionDescription(U){return this.styleDescriptionText(U)}styleSubcommandDescription(U){return this.styleDescriptionText(U)}styleArgumentDescription(U){return this.styleDescriptionText(U)}styleDescriptionText(U){return U}styleOptionTerm(U){return this.styleOptionText(U)}styleSubcommandTerm(U){return U.split(" ").map(($)=>{if($==="[options]")return this.styleOptionText($);if($[0]==="["||$[0]==="<")return this.styleArgumentText($);return this.styleSubcommandText($)}).join(" ")}styleArgumentTerm(U){return this.styleArgumentText(U)}styleOptionText(U){return U}styleArgumentText(U){return U}styleSubcommandText(U){return U}styleCommandText(U){return U}padWidth(U,$){return Math.max($.longestOptionTermLength(U,$),$.longestGlobalOptionTermLength(U,$),$.longestSubcommandTermLength(U,$),$.longestArgumentTermLength(U,$))}preformatted(U){return/\n[^\S\r\n]/.test(U)}formatItem(U,$,q,J){let Y=" ".repeat(2);if(!q)return Y+U;let Q=U.padEnd($+U.length-J.displayWidth(U)),z=2,G=(this.helpWidth??80)-$-z-2,K;if(G<this.minWidthToWrap||J.preformatted(q))K=q;else K=J.boxWrap(q,G).replace(/\n/g,`
`+" ".repeat($+z));return Y+Q+" ".repeat(z)+K.replace(/\n/g,`
${Y}`)}boxWrap(U,$){if($<this.minWidthToWrap)return U;let q=U.split(/\r\n|\n/),J=/[\s]*[^\s]+/g,Z=[];return q.forEach((Y)=>{let Q=Y.match(J);if(Q===null){Z.push("");return}let z=[Q.shift()],X=this.displayWidth(z[0]);Q.forEach((G)=>{let K=this.displayWidth(G);if(X+K<=$){z.push(G),X+=K;return}Z.push(z.join(""));let T=G.trimStart();z=[T],X=this.displayWidth(T)}),Z.push(z.join(""))}),Z.join(`
`)}}function P0(U){let $=/\x1b\[\d*(;\d*)*m/g;return U.replace($,"")}E$.Help=w0;E$.stripColor=P0});var U0=IU((y$)=>{var{InvalidArgumentError:k$}=vU();class D0{constructor(U,$){this.flags=U,this.description=$||"",this.required=U.includes("<"),this.optional=U.includes("["),this.variadic=/\w\.\.\.[>\]]$/.test(U),this.mandatory=!1;let q=v$(U);if(this.short=q.shortFlag,this.long=q.longFlag,this.negate=!1,this.long)this.negate=this.long.startsWith("--no-");this.defaultValue=void 0,this.defaultValueDescription=void 0,this.presetArg=void 0,this.envVar=void 0,this.parseArg=void 0,this.hidden=!1,this.argChoices=void 0,this.conflictsWith=[],this.implied=void 0,this.helpGroupHeading=void 0}default(U,$){return this.defaultValue=U,this.defaultValueDescription=$,this}preset(U){return this.presetArg=U,this}conflicts(U){return this.conflictsWith=this.conflictsWith.concat(U),this}implies(U){let $=U;if(typeof U==="string")$={[U]:!0};return this.implied=Object.assign(this.implied||{},$),this}env(U){return this.envVar=U,this}argParser(U){return this.parseArg=U,this}makeOptionMandatory(U=!0){return this.mandatory=!!U,this}hideHelp(U=!0){return this.hidden=!!U,this}_collectValue(U,$){if($===this.defaultValue||!Array.isArray($))return[U];return $.push(U),$}choices(U){return this.argChoices=U.slice(),this.parseArg=($,q)=>{if(!this.argChoices.includes($))throw new k$(`Allowed choices are ${this.argChoices.join(", ")}.`);if(this.variadic)return this._collectValue($,q);return $},this}name(){if(this.long)return this.long.replace(/^--/,"");return this.short.replace(/^-/,"")}attributeName(){if(this.negate)return L0(this.name().replace(/^no-/,""));return L0(this.name())}helpGroup(U){return this.helpGroupHeading=U,this}is(U){return this.short===U||this.long===U}isBoolean(){return!this.required&&!this.optional&&!this.negate}}class O0{constructor(U){this.positiveOptions=new Map,this.negativeOptions=new Map,this.dualOptions=new Set,U.forEach(($)=>{if($.negate)this.negativeOptions.set($.attributeName(),$);else this.positiveOptions.set($.attributeName(),$)}),this.negativeOptions.forEach(($,q)=>{if(this.positiveOptions.has(q))this.dualOptions.add(q)})}valueFromOption(U,$){let q=$.attributeName();if(!this.dualOptions.has(q))return!0;let J=this.negativeOptions.get(q).presetArg,Z=J!==void 0?J:!1;return $.negate===(Z===U)}}function L0(U){return U.split("-").reduce(($,q)=>{return $+q[0].toUpperCase()+q.slice(1)})}function v$(U){let $,q,J=/^-[^-]$/,Z=/^--[^-]/,Y=U.split(/[ |,]+/).concat("guard");if(J.test(Y[0]))$=Y.shift();if(Z.test(Y[0]))q=Y.shift();if(!$&&J.test(Y[0]))$=Y.shift();if(!$&&Z.test(Y[0]))$=q,q=Y.shift();if(Y[0].startsWith("-")){let Q=Y[0],z=`option creation failed due to '${Q}' in option flags '${U}'`;if(/^-[^-][^-]/.test(Q))throw Error(`${z}
- a short flag is a single dash and a single character
  - either use a single dash and a single character (for a short flag)
  - or use a double dash for a long option (and can have two, like '--ws, --workspace')`);if(J.test(Q))throw Error(`${z}
- too many short flags`);if(Z.test(Q))throw Error(`${z}
- too many long flags`);throw Error(`${z}
- unrecognised flag format`)}if($===void 0&&q===void 0)throw Error(`option creation failed due to no flags found in '${U}'.`);return{shortFlag:$,longFlag:q}}y$.Option=D0;y$.DualOptions=O0});var E0=IU((h$)=>{function x$(U,$){if(Math.abs(U.length-$.length)>3)return Math.max(U.length,$.length);let q=[];for(let J=0;J<=U.length;J++)q[J]=[J];for(let J=0;J<=$.length;J++)q[0][J]=J;for(let J=1;J<=$.length;J++)for(let Z=1;Z<=U.length;Z++){let Y=1;if(U[Z-1]===$[J-1])Y=0;else Y=1;if(q[Z][J]=Math.min(q[Z-1][J]+1,q[Z][J-1]+1,q[Z-1][J-1]+Y),Z>1&&J>1&&U[Z-1]===$[J-2]&&U[Z-2]===$[J-1])q[Z][J]=Math.min(q[Z][J],q[Z-2][J-2]+1)}return q[U.length][$.length]}function g$(U,$){if(!$||$.length===0)return"";$=Array.from(new Set($));let q=U.startsWith("--");if(q)U=U.slice(2),$=$.map((Q)=>Q.slice(2));let J=[],Z=3,Y=0.4;if($.forEach((Q)=>{if(Q.length<=1)return;let z=x$(U,Q),X=Math.max(U.length,Q.length);if((X-z)/X>Y){if(z<Z)Z=z,J=[Q];else if(z===Z)J.push(Q)}}),J.sort((Q,z)=>Q.localeCompare(z)),q)J=J.map((Q)=>`--${Q}`);if(J.length>1)return`
(Did you mean one of ${J.join(", ")}?)`;if(J.length===1)return`
(Did you mean ${J[0]}?)`;return""}h$.suggestSimilar=g$});var v0=IU((s$)=>{var u$=HU("node:events").EventEmitter,$0=HU("node:child_process"),QU=HU("node:path"),uU=HU("node:fs"),_=HU("node:process"),{Argument:l$,humanReadableArgName:c$}=mU(),{CommanderError:q0}=vU(),{Help:p$,stripColor:d$}=eU(),{Option:A0,DualOptions:i$}=U0(),{suggestSimilar:C0}=E0();class Z0 extends u${constructor(U){super();this.commands=[],this.options=[],this.parent=null,this._allowUnknownOption=!1,this._allowExcessArguments=!1,this.registeredArguments=[],this._args=this.registeredArguments,this.args=[],this.rawArgs=[],this.processedArgs=[],this._scriptPath=null,this._name=U||"",this._optionValues={},this._optionValueSources={},this._storeOptionsAsProperties=!1,this._actionHandler=null,this._executableHandler=!1,this._executableFile=null,this._executableDir=null,this._defaultCommandName=null,this._exitCallback=null,this._aliases=[],this._combineFlagAndOptionalValue=!0,this._description="",this._summary="",this._argsDescription=void 0,this._enablePositionalOptions=!1,this._passThroughOptions=!1,this._lifeCycleHooks={},this._showHelpAfterError=!1,this._showSuggestionAfterError=!0,this._savedState=null,this._outputConfiguration={writeOut:($)=>_.stdout.write($),writeErr:($)=>_.stderr.write($),outputError:($,q)=>q($),getOutHelpWidth:()=>_.stdout.isTTY?_.stdout.columns:void 0,getErrHelpWidth:()=>_.stderr.isTTY?_.stderr.columns:void 0,getOutHasColors:()=>J0()??(_.stdout.isTTY&&_.stdout.hasColors?.()),getErrHasColors:()=>J0()??(_.stderr.isTTY&&_.stderr.hasColors?.()),stripColor:($)=>d$($)},this._hidden=!1,this._helpOption=void 0,this._addImplicitHelpCommand=void 0,this._helpCommand=void 0,this._helpConfiguration={},this._helpGroupHeading=void 0,this._defaultCommandGroup=void 0,this._defaultOptionGroup=void 0}copyInheritedSettings(U){return this._outputConfiguration=U._outputConfiguration,this._helpOption=U._helpOption,this._helpCommand=U._helpCommand,this._helpConfiguration=U._helpConfiguration,this._exitCallback=U._exitCallback,this._storeOptionsAsProperties=U._storeOptionsAsProperties,this._combineFlagAndOptionalValue=U._combineFlagAndOptionalValue,this._allowExcessArguments=U._allowExcessArguments,this._enablePositionalOptions=U._enablePositionalOptions,this._showHelpAfterError=U._showHelpAfterError,this._showSuggestionAfterError=U._showSuggestionAfterError,this}_getCommandAndAncestors(){let U=[];for(let $=this;$;$=$.parent)U.push($);return U}command(U,$,q){let J=$,Z=q;if(typeof J==="object"&&J!==null)Z=J,J=null;Z=Z||{};let[,Y,Q]=U.match(/([^ ]+) *(.*)/),z=this.createCommand(Y);if(J)z.description(J),z._executableHandler=!0;if(Z.isDefault)this._defaultCommandName=z._name;if(z._hidden=!!(Z.noHelp||Z.hidden),z._executableFile=Z.executableFile||null,Q)z.arguments(Q);if(this._registerCommand(z),z.parent=this,z.copyInheritedSettings(this),J)return this;return z}createCommand(U){return new Z0(U)}createHelp(){return Object.assign(new p$,this.configureHelp())}configureHelp(U){if(U===void 0)return this._helpConfiguration;return this._helpConfiguration=U,this}configureOutput(U){if(U===void 0)return this._outputConfiguration;return this._outputConfiguration={...this._outputConfiguration,...U},this}showHelpAfterError(U=!0){if(typeof U!=="string")U=!!U;return this._showHelpAfterError=U,this}showSuggestionAfterError(U=!0){return this._showSuggestionAfterError=!!U,this}addCommand(U,$){if(!U._name)throw Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);if($=$||{},$.isDefault)this._defaultCommandName=U._name;if($.noHelp||$.hidden)U._hidden=!0;return this._registerCommand(U),U.parent=this,U._checkForBrokenPassThrough(),this}createArgument(U,$){return new l$(U,$)}argument(U,$,q,J){let Z=this.createArgument(U,$);if(typeof q==="function")Z.default(J).argParser(q);else Z.default(q);return this.addArgument(Z),this}arguments(U){return U.trim().split(/ +/).forEach(($)=>{this.argument($)}),this}addArgument(U){let $=this.registeredArguments.slice(-1)[0];if($?.variadic)throw Error(`only the last argument can be variadic '${$.name()}'`);if(U.required&&U.defaultValue!==void 0&&U.parseArg===void 0)throw Error(`a default value for a required argument is never used: '${U.name()}'`);return this.registeredArguments.push(U),this}helpCommand(U,$){if(typeof U==="boolean"){if(this._addImplicitHelpCommand=U,U&&this._defaultCommandGroup)this._initCommandGroup(this._getHelpCommand());return this}let q=U??"help [command]",[,J,Z]=q.match(/([^ ]+) *(.*)/),Y=$??"display help for command",Q=this.createCommand(J);if(Q.helpOption(!1),Z)Q.arguments(Z);if(Y)Q.description(Y);if(this._addImplicitHelpCommand=!0,this._helpCommand=Q,U||$)this._initCommandGroup(Q);return this}addHelpCommand(U,$){if(typeof U!=="object")return this.helpCommand(U,$),this;return this._addImplicitHelpCommand=!0,this._helpCommand=U,this._initCommandGroup(U),this}_getHelpCommand(){if(this._addImplicitHelpCommand??(this.commands.length&&!this._actionHandler&&!this._findCommand("help"))){if(this._helpCommand===void 0)this.helpCommand(void 0,void 0);return this._helpCommand}return null}hook(U,$){let q=["preSubcommand","preAction","postAction"];if(!q.includes(U))throw Error(`Unexpected value for event passed to hook : '${U}'.
Expecting one of '${q.join("', '")}'`);if(this._lifeCycleHooks[U])this._lifeCycleHooks[U].push($);else this._lifeCycleHooks[U]=[$];return this}exitOverride(U){if(U)this._exitCallback=U;else this._exitCallback=($)=>{if($.code!=="commander.executeSubCommandAsync")throw $};return this}_exit(U,$,q){if(this._exitCallback)this._exitCallback(new q0(U,$,q));_.exit(U)}action(U){let $=(q)=>{let J=this.registeredArguments.length,Z=q.slice(0,J);if(this._storeOptionsAsProperties)Z[J]=this;else Z[J]=this.opts();return Z.push(this),U.apply(this,Z)};return this._actionHandler=$,this}createOption(U,$){return new A0(U,$)}_callParseArg(U,$,q,J){try{return U.parseArg($,q)}catch(Z){if(Z.code==="commander.invalidArgument"){let Y=`${J} ${Z.message}`;this.error(Y,{exitCode:Z.exitCode,code:Z.code})}throw Z}}_registerOption(U){let $=U.short&&this._findOption(U.short)||U.long&&this._findOption(U.long);if($){let q=U.long&&this._findOption(U.long)?U.long:U.short;throw Error(`Cannot add option '${U.flags}'${this._name&&` to command '${this._name}'`} due to conflicting flag '${q}'
-  already used by option '${$.flags}'`)}this._initOptionGroup(U),this.options.push(U)}_registerCommand(U){let $=(J)=>{return[J.name()].concat(J.aliases())},q=$(U).find((J)=>this._findCommand(J));if(q){let J=$(this._findCommand(q)).join("|"),Z=$(U).join("|");throw Error(`cannot add command '${Z}' as already have command '${J}'`)}this._initCommandGroup(U),this.commands.push(U)}addOption(U){this._registerOption(U);let $=U.name(),q=U.attributeName();if(U.negate){let Z=U.long.replace(/^--no-/,"--");if(!this._findOption(Z))this.setOptionValueWithSource(q,U.defaultValue===void 0?!0:U.defaultValue,"default")}else if(U.defaultValue!==void 0)this.setOptionValueWithSource(q,U.defaultValue,"default");let J=(Z,Y,Q)=>{if(Z==null&&U.presetArg!==void 0)Z=U.presetArg;let z=this.getOptionValue(q);if(Z!==null&&U.parseArg)Z=this._callParseArg(U,Z,z,Y);else if(Z!==null&&U.variadic)Z=U._collectValue(Z,z);if(Z==null)if(U.negate)Z=!1;else if(U.isBoolean()||U.optional)Z=!0;else Z="";this.setOptionValueWithSource(q,Z,Q)};if(this.on("option:"+$,(Z)=>{let Y=`error: option '${U.flags}' argument '${Z}' is invalid.`;J(Z,Y,"cli")}),U.envVar)this.on("optionEnv:"+$,(Z)=>{let Y=`error: option '${U.flags}' value '${Z}' from env '${U.envVar}' is invalid.`;J(Z,Y,"env")});return this}_optionEx(U,$,q,J,Z){if(typeof $==="object"&&$ instanceof A0)throw Error("To add an Option object use addOption() instead of option() or requiredOption()");let Y=this.createOption($,q);if(Y.makeOptionMandatory(!!U.mandatory),typeof J==="function")Y.default(Z).argParser(J);else if(J instanceof RegExp){let Q=J;J=(z,X)=>{let G=Q.exec(z);return G?G[0]:X},Y.default(Z).argParser(J)}else Y.default(J);return this.addOption(Y)}option(U,$,q,J){return this._optionEx({},U,$,q,J)}requiredOption(U,$,q,J){return this._optionEx({mandatory:!0},U,$,q,J)}combineFlagAndOptionalValue(U=!0){return this._combineFlagAndOptionalValue=!!U,this}allowUnknownOption(U=!0){return this._allowUnknownOption=!!U,this}allowExcessArguments(U=!0){return this._allowExcessArguments=!!U,this}enablePositionalOptions(U=!0){return this._enablePositionalOptions=!!U,this}passThroughOptions(U=!0){return this._passThroughOptions=!!U,this._checkForBrokenPassThrough(),this}_checkForBrokenPassThrough(){if(this.parent&&this._passThroughOptions&&!this.parent._enablePositionalOptions)throw Error(`passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`)}storeOptionsAsProperties(U=!0){if(this.options.length)throw Error("call .storeOptionsAsProperties() before adding options");if(Object.keys(this._optionValues).length)throw Error("call .storeOptionsAsProperties() before setting option values");return this._storeOptionsAsProperties=!!U,this}getOptionValue(U){if(this._storeOptionsAsProperties)return this[U];return this._optionValues[U]}setOptionValue(U,$){return this.setOptionValueWithSource(U,$,void 0)}setOptionValueWithSource(U,$,q){if(this._storeOptionsAsProperties)this[U]=$;else this._optionValues[U]=$;return this._optionValueSources[U]=q,this}getOptionValueSource(U){return this._optionValueSources[U]}getOptionValueSourceWithGlobals(U){let $;return this._getCommandAndAncestors().forEach((q)=>{if(q.getOptionValueSource(U)!==void 0)$=q.getOptionValueSource(U)}),$}_prepareUserArgs(U,$){if(U!==void 0&&!Array.isArray(U))throw Error("first parameter to parse must be array or undefined");if($=$||{},U===void 0&&$.from===void 0){if(_.versions?.electron)$.from="electron";let J=_.execArgv??[];if(J.includes("-e")||J.includes("--eval")||J.includes("-p")||J.includes("--print"))$.from="eval"}if(U===void 0)U=_.argv;this.rawArgs=U.slice();let q;switch($.from){case void 0:case"node":this._scriptPath=U[1],q=U.slice(2);break;case"electron":if(_.defaultApp)this._scriptPath=U[1],q=U.slice(2);else q=U.slice(1);break;case"user":q=U.slice(0);break;case"eval":q=U.slice(1);break;default:throw Error(`unexpected parse option { from: '${$.from}' }`)}if(!this._name&&this._scriptPath)this.nameFromFilename(this._scriptPath);return this._name=this._name||"program",q}parse(U,$){this._prepareForParse();let q=this._prepareUserArgs(U,$);return this._parseCommand([],q),this}async parseAsync(U,$){this._prepareForParse();let q=this._prepareUserArgs(U,$);return await this._parseCommand([],q),this}_prepareForParse(){if(this._savedState===null)this.saveStateBeforeParse();else this.restoreStateBeforeParse()}saveStateBeforeParse(){this._savedState={_name:this._name,_optionValues:{...this._optionValues},_optionValueSources:{...this._optionValueSources}}}restoreStateBeforeParse(){if(this._storeOptionsAsProperties)throw Error(`Can not call parse again when storeOptionsAsProperties is true.
- either make a new Command for each call to parse, or stop storing options as properties`);this._name=this._savedState._name,this._scriptPath=null,this.rawArgs=[],this._optionValues={...this._savedState._optionValues},this._optionValueSources={...this._savedState._optionValueSources},this.args=[],this.processedArgs=[]}_checkForMissingExecutable(U,$,q){if(uU.existsSync(U))return;let J=$?`searched for local subcommand relative to directory '${$}'`:"no directory for search for local subcommand, use .executableDir() to supply a custom directory",Z=`'${U}' does not exist
 - if '${q}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${J}`;throw Error(Z)}_executeSubCommand(U,$){$=$.slice();let q=!1,J=[".js",".ts",".tsx",".mjs",".cjs"];function Z(G,K){let T=QU.resolve(G,K);if(uU.existsSync(T))return T;if(J.includes(QU.extname(K)))return;let R=J.find((H)=>uU.existsSync(`${T}${H}`));if(R)return`${T}${R}`;return}this._checkForMissingMandatoryOptions(),this._checkForConflictingOptions();let Y=U._executableFile||`${this._name}-${U._name}`,Q=this._executableDir||"";if(this._scriptPath){let G;try{G=uU.realpathSync(this._scriptPath)}catch{G=this._scriptPath}Q=QU.resolve(QU.dirname(G),Q)}if(Q){let G=Z(Q,Y);if(!G&&!U._executableFile&&this._scriptPath){let K=QU.basename(this._scriptPath,QU.extname(this._scriptPath));if(K!==this._name)G=Z(Q,`${K}-${U._name}`)}Y=G||Y}q=J.includes(QU.extname(Y));let z;if(_.platform!=="win32")if(q)$.unshift(Y),$=k0(_.execArgv).concat($),z=$0.spawn(_.argv[0],$,{stdio:"inherit"});else z=$0.spawn(Y,$,{stdio:"inherit"});else this._checkForMissingExecutable(Y,Q,U._name),$.unshift(Y),$=k0(_.execArgv).concat($),z=$0.spawn(_.execPath,$,{stdio:"inherit"});if(!z.killed)["SIGUSR1","SIGUSR2","SIGTERM","SIGINT","SIGHUP"].forEach((K)=>{_.on(K,()=>{if(z.killed===!1&&z.exitCode===null)z.kill(K)})});let X=this._exitCallback;z.on("close",(G)=>{if(G=G??1,!X)_.exit(G);else X(new q0(G,"commander.executeSubCommandAsync","(close)"))}),z.on("error",(G)=>{if(G.code==="ENOENT")this._checkForMissingExecutable(Y,Q,U._name);else if(G.code==="EACCES")throw Error(`'${Y}' not executable`);if(!X)_.exit(1);else{let K=new q0(1,"commander.executeSubCommandAsync","(error)");K.nestedError=G,X(K)}}),this.runningCommand=z}_dispatchSubcommand(U,$,q){let J=this._findCommand(U);if(!J)this.help({error:!0});J._prepareForParse();let Z;return Z=this._chainOrCallSubCommandHook(Z,J,"preSubcommand"),Z=this._chainOrCall(Z,()=>{if(J._executableHandler)this._executeSubCommand(J,$.concat(q));else return J._parseCommand($,q)}),Z}_dispatchHelpCommand(U){if(!U)this.help();let $=this._findCommand(U);if($&&!$._executableHandler)$.help();return this._dispatchSubcommand(U,[],[this._getHelpOption()?.long??this._getHelpOption()?.short??"--help"])}_checkNumberOfArguments(){if(this.registeredArguments.forEach((U,$)=>{if(U.required&&this.args[$]==null)this.missingArgument(U.name())}),this.registeredArguments.length>0&&this.registeredArguments[this.registeredArguments.length-1].variadic)return;if(this.args.length>this.registeredArguments.length)this._excessArguments(this.args)}_processArguments(){let U=(q,J,Z)=>{let Y=J;if(J!==null&&q.parseArg){let Q=`error: command-argument value '${J}' is invalid for argument '${q.name()}'.`;Y=this._callParseArg(q,J,Z,Q)}return Y};this._checkNumberOfArguments();let $=[];this.registeredArguments.forEach((q,J)=>{let Z=q.defaultValue;if(q.variadic){if(J<this.args.length){if(Z=this.args.slice(J),q.parseArg)Z=Z.reduce((Y,Q)=>{return U(q,Q,Y)},q.defaultValue)}else if(Z===void 0)Z=[]}else if(J<this.args.length){if(Z=this.args[J],q.parseArg)Z=U(q,Z,q.defaultValue)}$[J]=Z}),this.processedArgs=$}_chainOrCall(U,$){if(U?.then&&typeof U.then==="function")return U.then(()=>$());return $()}_chainOrCallHooks(U,$){let q=U,J=[];if(this._getCommandAndAncestors().reverse().filter((Z)=>Z._lifeCycleHooks[$]!==void 0).forEach((Z)=>{Z._lifeCycleHooks[$].forEach((Y)=>{J.push({hookedCommand:Z,callback:Y})})}),$==="postAction")J.reverse();return J.forEach((Z)=>{q=this._chainOrCall(q,()=>{return Z.callback(Z.hookedCommand,this)})}),q}_chainOrCallSubCommandHook(U,$,q){let J=U;if(this._lifeCycleHooks[q]!==void 0)this._lifeCycleHooks[q].forEach((Z)=>{J=this._chainOrCall(J,()=>{return Z(this,$)})});return J}_parseCommand(U,$){let q=this.parseOptions($);if(this._parseOptionsEnv(),this._parseOptionsImplied(),U=U.concat(q.operands),$=q.unknown,this.args=U.concat($),U&&this._findCommand(U[0]))return this._dispatchSubcommand(U[0],U.slice(1),$);if(this._getHelpCommand()&&U[0]===this._getHelpCommand().name())return this._dispatchHelpCommand(U[1]);if(this._defaultCommandName)return this._outputHelpIfRequested($),this._dispatchSubcommand(this._defaultCommandName,U,$);if(this.commands.length&&this.args.length===0&&!this._actionHandler&&!this._defaultCommandName)this.help({error:!0});this._outputHelpIfRequested(q.unknown),this._checkForMissingMandatoryOptions(),this._checkForConflictingOptions();let J=()=>{if(q.unknown.length>0)this.unknownOption(q.unknown[0])},Z=`command:${this.name()}`;if(this._actionHandler){J(),this._processArguments();let Y;if(Y=this._chainOrCallHooks(Y,"preAction"),Y=this._chainOrCall(Y,()=>this._actionHandler(this.processedArgs)),this.parent)Y=this._chainOrCall(Y,()=>{this.parent.emit(Z,U,$)});return Y=this._chainOrCallHooks(Y,"postAction"),Y}if(this.parent?.listenerCount(Z))J(),this._processArguments(),this.parent.emit(Z,U,$);else if(U.length){if(this._findCommand("*"))return this._dispatchSubcommand("*",U,$);if(this.listenerCount("command:*"))this.emit("command:*",U,$);else if(this.commands.length)this.unknownCommand();else J(),this._processArguments()}else if(this.commands.length)J(),this.help({error:!0});else J(),this._processArguments()}_findCommand(U){if(!U)return;return this.commands.find(($)=>$._name===U||$._aliases.includes(U))}_findOption(U){return this.options.find(($)=>$.is(U))}_checkForMissingMandatoryOptions(){this._getCommandAndAncestors().forEach((U)=>{U.options.forEach(($)=>{if($.mandatory&&U.getOptionValue($.attributeName())===void 0)U.missingMandatoryOptionValue($)})})}_checkForConflictingLocalOptions(){let U=this.options.filter((q)=>{let J=q.attributeName();if(this.getOptionValue(J)===void 0)return!1;return this.getOptionValueSource(J)!=="default"});U.filter((q)=>q.conflictsWith.length>0).forEach((q)=>{let J=U.find((Z)=>q.conflictsWith.includes(Z.attributeName()));if(J)this._conflictingOption(q,J)})}_checkForConflictingOptions(){this._getCommandAndAncestors().forEach((U)=>{U._checkForConflictingLocalOptions()})}parseOptions(U){let $=[],q=[],J=$;function Z(G){return G.length>1&&G[0]==="-"}let Y=(G)=>{if(!/^-\d*\.?\d+(e[+-]?\d+)?$/.test(G))return!1;return!this._getCommandAndAncestors().some((K)=>K.options.map((T)=>T.short).some((T)=>/^-\d$/.test(T)))},Q=null,z=null,X=0;while(X<U.length||z){let G=z??U[X++];if(z=null,G==="--"){if(J===q)J.push(G);J.push(...U.slice(X));break}if(Q&&(!Z(G)||Y(G))){this.emit(`option:${Q.name()}`,G);continue}if(Q=null,Z(G)){let K=this._findOption(G);if(K){if(K.required){let T=U[X++];if(T===void 0)this.optionMissingArgument(K);this.emit(`option:${K.name()}`,T)}else if(K.optional){let T=null;if(X<U.length&&(!Z(U[X])||Y(U[X])))T=U[X++];this.emit(`option:${K.name()}`,T)}else this.emit(`option:${K.name()}`);Q=K.variadic?K:null;continue}}if(G.length>2&&G[0]==="-"&&G[1]!=="-"){let K=this._findOption(`-${G[1]}`);if(K){if(K.required||K.optional&&this._combineFlagAndOptionalValue)this.emit(`option:${K.name()}`,G.slice(2));else this.emit(`option:${K.name()}`),z=`-${G.slice(2)}`;continue}}if(/^--[^=]+=/.test(G)){let K=G.indexOf("="),T=this._findOption(G.slice(0,K));if(T&&(T.required||T.optional)){this.emit(`option:${T.name()}`,G.slice(K+1));continue}}if(J===$&&Z(G)&&!(this.commands.length===0&&Y(G)))J=q;if((this._enablePositionalOptions||this._passThroughOptions)&&$.length===0&&q.length===0){if(this._findCommand(G)){$.push(G),q.push(...U.slice(X));break}else if(this._getHelpCommand()&&G===this._getHelpCommand().name()){$.push(G,...U.slice(X));break}else if(this._defaultCommandName){q.push(G,...U.slice(X));break}}if(this._passThroughOptions){J.push(G,...U.slice(X));break}J.push(G)}return{operands:$,unknown:q}}opts(){if(this._storeOptionsAsProperties){let U={},$=this.options.length;for(let q=0;q<$;q++){let J=this.options[q].attributeName();U[J]=J===this._versionOptionName?this._version:this[J]}return U}return this._optionValues}optsWithGlobals(){return this._getCommandAndAncestors().reduce((U,$)=>Object.assign(U,$.opts()),{})}error(U,$){if(this._outputConfiguration.outputError(`${U}
`,this._outputConfiguration.writeErr),typeof this._showHelpAfterError==="string")this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`);else if(this._showHelpAfterError)this._outputConfiguration.writeErr(`
`),this.outputHelp({error:!0});let q=$||{},J=q.exitCode||1,Z=q.code||"commander.error";this._exit(J,Z,U)}_parseOptionsEnv(){this.options.forEach((U)=>{if(U.envVar&&U.envVar in _.env){let $=U.attributeName();if(this.getOptionValue($)===void 0||["default","config","env"].includes(this.getOptionValueSource($)))if(U.required||U.optional)this.emit(`optionEnv:${U.name()}`,_.env[U.envVar]);else this.emit(`optionEnv:${U.name()}`)}})}_parseOptionsImplied(){let U=new i$(this.options),$=(q)=>{return this.getOptionValue(q)!==void 0&&!["default","implied"].includes(this.getOptionValueSource(q))};this.options.filter((q)=>q.implied!==void 0&&$(q.attributeName())&&U.valueFromOption(this.getOptionValue(q.attributeName()),q)).forEach((q)=>{Object.keys(q.implied).filter((J)=>!$(J)).forEach((J)=>{this.setOptionValueWithSource(J,q.implied[J],"implied")})})}missingArgument(U){let $=`error: missing required argument '${U}'`;this.error($,{code:"commander.missingArgument"})}optionMissingArgument(U){let $=`error: option '${U.flags}' argument missing`;this.error($,{code:"commander.optionMissingArgument"})}missingMandatoryOptionValue(U){let $=`error: required option '${U.flags}' not specified`;this.error($,{code:"commander.missingMandatoryOptionValue"})}_conflictingOption(U,$){let q=(Y)=>{let Q=Y.attributeName(),z=this.getOptionValue(Q),X=this.options.find((K)=>K.negate&&Q===K.attributeName()),G=this.options.find((K)=>!K.negate&&Q===K.attributeName());if(X&&(X.presetArg===void 0&&z===!1||X.presetArg!==void 0&&z===X.presetArg))return X;return G||Y},J=(Y)=>{let Q=q(Y),z=Q.attributeName();if(this.getOptionValueSource(z)==="env")return`environment variable '${Q.envVar}'`;return`option '${Q.flags}'`},Z=`error: ${J(U)} cannot be used with ${J($)}`;this.error(Z,{code:"commander.conflictingOption"})}unknownOption(U){if(this._allowUnknownOption)return;let $="";if(U.startsWith("--")&&this._showSuggestionAfterError){let J=[],Z=this;do{let Y=Z.createHelp().visibleOptions(Z).filter((Q)=>Q.long).map((Q)=>Q.long);J=J.concat(Y),Z=Z.parent}while(Z&&!Z._enablePositionalOptions);$=C0(U,J)}let q=`error: unknown option '${U}'${$}`;this.error(q,{code:"commander.unknownOption"})}_excessArguments(U){if(this._allowExcessArguments)return;let $=this.registeredArguments.length,q=$===1?"":"s",Z=`error: too many arguments${this.parent?` for '${this.name()}'`:""}. Expected ${$} argument${q} but got ${U.length}.`;this.error(Z,{code:"commander.excessArguments"})}unknownCommand(){let U=this.args[0],$="";if(this._showSuggestionAfterError){let J=[];this.createHelp().visibleCommands(this).forEach((Z)=>{if(J.push(Z.name()),Z.alias())J.push(Z.alias())}),$=C0(U,J)}let q=`error: unknown command '${U}'${$}`;this.error(q,{code:"commander.unknownCommand"})}version(U,$,q){if(U===void 0)return this._version;this._version=U,$=$||"-V, --version",q=q||"output the version number";let J=this.createOption($,q);return this._versionOptionName=J.attributeName(),this._registerOption(J),this.on("option:"+J.name(),()=>{this._outputConfiguration.writeOut(`${U}
`),this._exit(0,"commander.version",U)}),this}description(U,$){if(U===void 0&&$===void 0)return this._description;if(this._description=U,$)this._argsDescription=$;return this}summary(U){if(U===void 0)return this._summary;return this._summary=U,this}alias(U){if(U===void 0)return this._aliases[0];let $=this;if(this.commands.length!==0&&this.commands[this.commands.length-1]._executableHandler)$=this.commands[this.commands.length-1];if(U===$._name)throw Error("Command alias can't be the same as its name");let q=this.parent?._findCommand(U);if(q){let J=[q.name()].concat(q.aliases()).join("|");throw Error(`cannot add alias '${U}' to command '${this.name()}' as already have command '${J}'`)}return $._aliases.push(U),this}aliases(U){if(U===void 0)return this._aliases;return U.forEach(($)=>this.alias($)),this}usage(U){if(U===void 0){if(this._usage)return this._usage;let $=this.registeredArguments.map((q)=>{return c$(q)});return[].concat(this.options.length||this._helpOption!==null?"[options]":[],this.commands.length?"[command]":[],this.registeredArguments.length?$:[]).join(" ")}return this._usage=U,this}name(U){if(U===void 0)return this._name;return this._name=U,this}helpGroup(U){if(U===void 0)return this._helpGroupHeading??"";return this._helpGroupHeading=U,this}commandsGroup(U){if(U===void 0)return this._defaultCommandGroup??"";return this._defaultCommandGroup=U,this}optionsGroup(U){if(U===void 0)return this._defaultOptionGroup??"";return this._defaultOptionGroup=U,this}_initOptionGroup(U){if(this._defaultOptionGroup&&!U.helpGroupHeading)U.helpGroup(this._defaultOptionGroup)}_initCommandGroup(U){if(this._defaultCommandGroup&&!U.helpGroup())U.helpGroup(this._defaultCommandGroup)}nameFromFilename(U){return this._name=QU.basename(U,QU.extname(U)),this}executableDir(U){if(U===void 0)return this._executableDir;return this._executableDir=U,this}helpInformation(U){let $=this.createHelp(),q=this._getOutputContext(U);$.prepareContext({error:q.error,helpWidth:q.helpWidth,outputHasColors:q.hasColors});let J=$.formatHelp(this,$);if(q.hasColors)return J;return this._outputConfiguration.stripColor(J)}_getOutputContext(U){U=U||{};let $=!!U.error,q,J,Z;if($)q=(Q)=>this._outputConfiguration.writeErr(Q),J=this._outputConfiguration.getErrHasColors(),Z=this._outputConfiguration.getErrHelpWidth();else q=(Q)=>this._outputConfiguration.writeOut(Q),J=this._outputConfiguration.getOutHasColors(),Z=this._outputConfiguration.getOutHelpWidth();return{error:$,write:(Q)=>{if(!J)Q=this._outputConfiguration.stripColor(Q);return q(Q)},hasColors:J,helpWidth:Z}}outputHelp(U){let $;if(typeof U==="function")$=U,U=void 0;let q=this._getOutputContext(U),J={error:q.error,write:q.write,command:this};this._getCommandAndAncestors().reverse().forEach((Y)=>Y.emit("beforeAllHelp",J)),this.emit("beforeHelp",J);let Z=this.helpInformation({error:q.error});if($){if(Z=$(Z),typeof Z!=="string"&&!Buffer.isBuffer(Z))throw Error("outputHelp callback must return a string or a Buffer")}if(q.write(Z),this._getHelpOption()?.long)this.emit(this._getHelpOption().long);this.emit("afterHelp",J),this._getCommandAndAncestors().forEach((Y)=>Y.emit("afterAllHelp",J))}helpOption(U,$){if(typeof U==="boolean"){if(U){if(this._helpOption===null)this._helpOption=void 0;if(this._defaultOptionGroup)this._initOptionGroup(this._getHelpOption())}else this._helpOption=null;return this}if(this._helpOption=this.createOption(U??"-h, --help",$??"display help for command"),U||$)this._initOptionGroup(this._helpOption);return this}_getHelpOption(){if(this._helpOption===void 0)this.helpOption(void 0,void 0);return this._helpOption}addHelpOption(U){return this._helpOption=U,this._initOptionGroup(U),this}help(U){this.outputHelp(U);let $=Number(_.exitCode??0);if($===0&&U&&typeof U!=="function"&&U.error)$=1;this._exit($,"commander.help","(outputHelp)")}addHelpText(U,$){let q=["beforeAll","before","after","afterAll"];if(!q.includes(U))throw Error(`Unexpected value for position to addHelpText.
Expecting one of '${q.join("', '")}'`);let J=`${U}Help`;return this.on(J,(Z)=>{let Y;if(typeof $==="function")Y=$({error:Z.error,command:Z.command});else Y=$;if(Y)Z.write(`${Y}
`)}),this}_outputHelpIfRequested(U){let $=this._getHelpOption();if($&&U.find((J)=>$.is(J)))this.outputHelp(),this._exit(0,"commander.helpDisplayed","(outputHelp)")}}function k0(U){return U.map(($)=>{if(!$.startsWith("--inspect"))return $;let q,J="127.0.0.1",Z="9229",Y;if((Y=$.match(/^(--inspect(-brk)?)$/))!==null)q=Y[1];else if((Y=$.match(/^(--inspect(-brk|-port)?)=([^:]+)$/))!==null)if(q=Y[1],/^\d+$/.test(Y[3]))Z=Y[3];else J=Y[3];else if((Y=$.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/))!==null)q=Y[1],J=Y[3],Z=Y[4];if(q&&Z!=="0")return`${q}=${J}:${parseInt(Z)+1}`;return $})}function J0(){if(_.env.NO_COLOR||_.env.FORCE_COLOR==="0"||_.env.FORCE_COLOR==="false")return!1;if(_.env.FORCE_COLOR||_.env.CLICOLOR_FORCE!==void 0)return!0;return}s$.Command=Z0;s$.useColor=J0});var x0=IU((t$)=>{var{Argument:y0}=mU(),{Command:Y0}=v0(),{CommanderError:r$,InvalidArgumentError:f0}=vU(),{Help:a$}=eU(),{Option:b0}=U0();t$.program=new Y0;t$.createCommand=(U)=>new Y0(U);t$.createOption=(U,$)=>new b0(U,$);t$.createArgument=(U,$)=>new y0(U,$);t$.Command=Y0;t$.Option=b0;t$.Argument=y0;t$.Help=a$;t$.CommanderError=r$;t$.InvalidArgumentError=f0;t$.InvalidOptionArgumentError=f0});var g0=hU(x0(),1),{program:rq,createCommand:aq,createArgument:tq,createOption:eq,CommanderError:UJ,InvalidArgumentError:$J,InvalidOptionArgumentError:qJ,Command:h0,Argument:JJ,Option:BU,Help:ZJ}=g0.default;import{existsSync as rU,accessSync as fq,constants as bq,realpathSync as G$}from"node:fs";import{createReadStream as W$,createWriteStream as j0}from"node:fs";import{stdin as t,stdout as e,stderr as c,exit as o}from"node:process";class UU extends Error{constructor(U){super(U);Object.setPrototypeOf(this,new.target.prototype),this.name=new.target.name,this.stack=void 0}}class a extends UU{}class PU extends UU{}class Q0 extends UU{}class lU extends UU{}class RU extends UU{}class zU extends UU{}class $U extends UU{}class x extends UU{}class VU extends UU{}function m0(){return typeof process<"u"&&typeof process.versions==="object"&&!0}function LU(...U){let $=U.reduce((Z,Y)=>Z+Y.byteLength,0),q=new Uint8Array($),J=0;for(let Z of U)q.set(Z,J),J+=Z.byteLength;return q}function DU(...U){try{let $=LU(...U);if(m0())return Buffer.from($).toString("base64");let q="";for(let J=0;J<$.length;J++)q+=String.fromCharCode($[J]);return btoa(q)}catch{throw new Q0("Base64 Encoding Error")}}function yU(U){try{if(!/^[A-Za-z0-9+/]+={0,2}$/.test(U)||U.length%4!==0)throw Error("Invalid Base64");if(m0())return new Uint8Array(Buffer.from(U,"base64"));let $=atob(U),q=new Uint8Array($.length);for(let J=0;J<$.length;J++)q[J]=$.charCodeAt(J);return q}catch{throw new PU(`Invalid Base64: length=${U.length}, content='${U.slice(0,12)}â€¦'`)}}function i(U){let $=U.value.length,q=Array($).fill("\x00").join("");U.value=q}function z0(U,$,q){if($<0||q<0||$+q>U)throw RangeError("read() slice exceeds data bounds")}import{promises as Kq}from"fs";class X0{src;#U=null;constructor(U){this.src=U}get length(){if(this.src instanceof Uint8Array)return this.src.byteLength;if(this.src instanceof Blob)return this.src.size;return this.ensureUint8().byteLength}async read(U,$){if(z0(this.length,U,$),this.src instanceof Uint8Array)return this.src.slice(U,U+$);if(this.src instanceof Blob){let q=await this.src.slice(U,U+$).arrayBuffer();return new Uint8Array(q)}return this.ensureUint8().slice(U,U+$)}ensureUint8(){if(!this.#U)this.#U=yU(this.src);return this.#U}}class fU{fd;length;constructor(U,$){this.fd=U;this.length=$}static async open(U){let $=await Kq.open(U,"r"),q=await $.stat();return new fU($,q.size)}async read(U,$){z0(this.length,U,$);let q=Buffer.allocUnsafe($);return await this.fd.read(q,0,$,U),new Uint8Array(q)}async close(){await this.fd.close()}}class d{static byId=new Map;static register(U){if(this.byId.has(U.id))throw new lU(`Scheme ${U.id} already registered`);this.byId.set(U.id,U)}static get(U){let $=this.byId.get(U);if(!$)throw new lU(`Unknown scheme: ${U}`);return $}static get current(){return this.get(0)}}class XU{p;padding=null;headerAAD=new Uint8Array(0);padAADMode="auto";padAlign=8;allowLegacyAADFallback=!0;legacyFallbackPolicy="auto";tryEmptyAADOnLegacyFallback=!1;setLegacyAADFallback(U={}){if(U.enabled!==void 0)this.allowLegacyAADFallback=!!U.enabled;if(U.policy)this.legacyFallbackPolicy=U.policy;if(U.tryEmptyAAD!==void 0)this.tryEmptyAADOnLegacyFallback=!!U.tryEmptyAAD}static PAD_AAD_MAGIC=new Uint8Array([80,65,68,49]);static PAD_AAD_VER=1;constructor(U){this.p=U}setPaddingScheme(U){this.padding=U}setPaddingAADMode(U){this.padAADMode=U}setPaddingAlign(U){if(!Number.isInteger(U)||U<1||U>255)throw Error("padAlign must be 1..255");this.padAlign=U|0}setAAD(U){this.headerAAD=U&&U.byteLength?new Uint8Array(U):new Uint8Array(0)}async encryptChunk(U){let $=this.resolveMode(),q=U;if($==="require"){if(!this.padding)throw Error("Padding required but no scheme set");let Y=(Q)=>this.p.getRandomValues(new Uint8Array(Q));q=this.padding.pad(U,Y,this.padAlign)}let J=this.composeAAD($),Z=await this.encryptWithAAD(q,J);if(U.fill(0),q!==U)q.fill(0);return Z}async decryptChunk(U){let $=this.resolveMode(),q=this.composeAAD($);try{let J=await this.decryptWithAAD(U,q);return this.enforcePolicyAfterDecrypt(J,$)}catch(J){if(!this.allowLegacyAADFallback)throw J;let Z=[];if(this.headerAAD.length)Z.push(this.headerAAD);if(this.tryEmptyAADOnLegacyFallback)Z.push(new Uint8Array(0));let Y=J;for(let Q of Z)try{let z=await this.decryptWithAAD(U,Q),X=this.legacyFallbackPolicy==="auto"?"auto":this.legacyFallbackPolicy;return this.enforcePolicyAfterDecrypt(z,X)}catch(z){Y=z}throw Y}}enforcePolicyAfterDecrypt(U,$){if(!this.padding){if($==="require")throw new x("Expected padding but no scheme configured");return U}let{used:q,plain:J}=this.padding.tryUnpad(U);if($==="require"){if(!q)throw new x("Expected padding trailer not found");return new Uint8Array(J)}if($==="forbid"){if(q)throw new x("Padding forbidden by policy");return U}return q?new Uint8Array(J):U}resolveMode(){if(this.padAADMode==="auto")return this.padding?"require":"forbid";return this.padAADMode}buildPadAAD(U){let $=U==="require"?0:1,q=new Uint8Array(XU.PAD_AAD_MAGIC.length+1+1+1),J=0;return q.set(XU.PAD_AAD_MAGIC,J),J+=XU.PAD_AAD_MAGIC.length,q[J++]=XU.PAD_AAD_VER&255,q[J++]=$,q[J++]=this.padAlign&255,q}composeAAD(U){let $=this.buildPadAAD(U);if(!this.headerAAD.length)return $;let q=new Uint8Array(this.headerAAD.length+$.length);return q.set(this.headerAAD,0),q.set($,this.headerAAD.length),q}}class qU extends XU{static IV_LENGTH=12;static TAG_LENGTH=16;IV_LENGTH=qU.IV_LENGTH;TAG_LENGTH=qU.TAG_LENGTH;key=null;constructor(U){super(U)}async setKey(U){this.key=U}zeroKey(){this.key=null}async encryptWithAAD(U,$){let q=this.p.getRandomValues(new Uint8Array(qU.IV_LENGTH)),J={name:"AES-GCM",iv:q,additionalData:$},Z=await this.p.subtle.encrypt(J,this.requireKey(),U),Y=new Uint8Array(Z),Q=new Uint8Array(q.length+Y.length);return Q.set(q,0),Q.set(Y,q.length),Q}async decryptWithAAD(U,$){if(U.byteLength<qU.IV_LENGTH+qU.TAG_LENGTH)throw new x("Invalid ciphertext: too short.");let q=U.subarray(0,qU.IV_LENGTH),J=U.subarray(qU.IV_LENGTH),Z={name:"AES-GCM",iv:q,additionalData:$};try{let Y=await this.p.subtle.decrypt(Z,this.requireKey(),J);return new Uint8Array(Y)}catch{throw new x("Decryption failed: wrong passphrase or corrupted ciphertext")}}requireKey(){if(!this.key)throw Error("Encryption key not set");return this.key}}/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function Tq(U){return U instanceof Uint8Array||ArrayBuffer.isView(U)&&U.constructor.name==="Uint8Array"}function cU(U){if(typeof U!=="boolean")throw Error(`boolean expected, not ${U}`)}function pU(U){if(!Number.isSafeInteger(U)||U<0)throw Error("positive integer expected, got "+U)}function u(U,$,q=""){let J=Tq(U),Z=U?.length,Y=$!==void 0;if(!J||Y&&Z!==$){let Q=q&&`"${q}" `,z=Y?` of length ${$}`:"",X=J?`length=${Z}`:`type=${typeof U}`;throw Error(Q+"expected Uint8Array"+z+", got "+X)}return U}function G0(U,$=!0){if(U.destroyed)throw Error("Hash instance has been destroyed");if($&&U.finished)throw Error("Hash#digest() has already been called")}function u0(U,$){u(U,void 0,"output");let q=$.outputLen;if(U.length<q)throw Error("digestInto() expects output buffer of length at least "+q)}function GU(U){return new Uint32Array(U.buffer,U.byteOffset,Math.floor(U.byteLength/4))}function KU(...U){for(let $=0;$<U.length;$++)U[$].fill(0)}function Wq(U){return new DataView(U.buffer,U.byteOffset,U.byteLength)}var Hq=(()=>new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68)();function l0(U,$){if($==null||typeof $!=="object")throw Error("options must be defined");return Object.assign(U,$)}function c0(U,$){if(U.length!==$.length)return!1;let q=0;for(let J=0;J<U.length;J++)q|=U[J]^$[J];return q===0}var K0=(U,$)=>{function q(J,...Z){if(u(J,void 0,"key"),!Hq)throw Error("Non little-endian hardware is not yet supported");if(U.nonceLength!==void 0){let K=Z[0];u(K,U.varSizeNonce?void 0:U.nonceLength,"nonce")}let Y=U.tagLength;if(Y&&Z[1]!==void 0)u(Z[1],void 0,"AAD");let Q=$(J,...Z),z=(K,T)=>{if(T!==void 0){if(K!==2)throw Error("cipher output not supported");u(T,void 0,"output")}},X=!1;return{encrypt(K,T){if(X)throw Error("cannot encrypt() twice with same key + nonce");return X=!0,u(K),z(Q.encrypt.length,T),Q.encrypt(K,T)},decrypt(K,T){if(u(K),Y&&K.length<Y)throw Error('"ciphertext" expected length bigger than tagLength='+Y);return z(Q.decrypt.length,T),Q.decrypt(K,T)}}}return Object.assign(q,U),q};function T0(U,$,q=!0){if($===void 0)return new Uint8Array(U);if($.length!==U)throw Error('"output" expected Uint8Array of length '+U+", got: "+$.length);if(q&&!Rq($))throw Error("invalid output, must be aligned");return $}function p0(U,$,q){cU(q);let J=new Uint8Array(16),Z=Wq(J);return Z.setBigUint64(0,BigInt($),q),Z.setBigUint64(8,BigInt(U),q),J}function Rq(U){return U.byteOffset%4===0}function OU(U){return Uint8Array.from(U)}var i0=(U)=>Uint8Array.from(U.split(""),($)=>$.charCodeAt(0)),Vq=i0("expand 16-byte k"),Nq=i0("expand 32-byte k"),Iq=GU(Vq),Bq=GU(Nq);function W(U,$){return U<<$|U>>>32-$}function W0(U){return U.byteOffset%4===0}var dU=64,jq=16,s0=4294967295,d0=Uint32Array.of();function Sq(U,$,q,J,Z,Y,Q,z){let X=Z.length,G=new Uint8Array(dU),K=GU(G),T=W0(Z)&&W0(Y),R=T?GU(Z):d0,H=T?GU(Y):d0;for(let I=0;I<X;Q++){if(U($,q,J,K,Q,z),Q>=s0)throw Error("arx: counter overflow");let V=Math.min(dU,X-I);if(T&&V===dU){let B=I/4;if(I%4!==0)throw Error("arx: invalid block position");for(let j=0,S;j<jq;j++)S=B+j,H[S]=R[S]^K[j];I+=dU;continue}for(let B=0,j;B<V;B++)j=I+B,Y[j]=Z[j]^G[B];I+=V}}function H0(U,$){let{allowShortKeys:q,extendNonceFn:J,counterLength:Z,counterRight:Y,rounds:Q}=l0({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},$);if(typeof U!=="function")throw Error("core must be a function");return pU(Z),pU(Q),cU(Y),cU(q),(z,X,G,K,T=0)=>{u(z,void 0,"key"),u(X,void 0,"nonce"),u(G,void 0,"data");let R=G.length;if(K===void 0)K=new Uint8Array(R);if(u(K,void 0,"output"),pU(T),T<0||T>=s0)throw Error("arx: counter overflow");if(K.length<R)throw Error(`arx: output (${K.length}) is shorter than data (${R})`);let H=[],I=z.length,V,B;if(I===32)H.push(V=OU(z)),B=Bq;else if(I===16&&q)V=new Uint8Array(32),V.set(z),V.set(z,16),B=Iq,H.push(V);else throw u(z,32,"arx key"),Error("invalid key size");if(!W0(X))H.push(X=OU(X));let j=GU(V);if(J){if(X.length!==24)throw Error("arx: extended nonce must be 24 bytes");J(B,j,GU(X.subarray(0,16)),j),X=X.subarray(16)}let S=16-Z;if(S!==X.length)throw Error(`arx: nonce must be ${S} or 16 bytes`);if(S!==12){let F=new Uint8Array(12);F.set(X,Y?0:12-X.length),X=F,H.push(X)}let M=GU(X);return Sq(U,B,j,M,G,K,T,Q),KU(...H),K}}function l(U,$){return U[$++]&255|(U[$++]&255)<<8}class n0{blockLen=16;outputLen=16;buffer=new Uint8Array(16);r=new Uint16Array(10);h=new Uint16Array(10);pad=new Uint16Array(8);pos=0;finished=!1;constructor(U){U=OU(u(U,32,"key"));let $=l(U,0),q=l(U,2),J=l(U,4),Z=l(U,6),Y=l(U,8),Q=l(U,10),z=l(U,12),X=l(U,14);this.r[0]=$&8191,this.r[1]=($>>>13|q<<3)&8191,this.r[2]=(q>>>10|J<<6)&7939,this.r[3]=(J>>>7|Z<<9)&8191,this.r[4]=(Z>>>4|Y<<12)&255,this.r[5]=Y>>>1&8190,this.r[6]=(Y>>>14|Q<<2)&8191,this.r[7]=(Q>>>11|z<<5)&8065,this.r[8]=(z>>>8|X<<8)&8191,this.r[9]=X>>>5&127;for(let G=0;G<8;G++)this.pad[G]=l(U,16+2*G)}process(U,$,q=!1){let J=q?0:2048,{h:Z,r:Y}=this,Q=Y[0],z=Y[1],X=Y[2],G=Y[3],K=Y[4],T=Y[5],R=Y[6],H=Y[7],I=Y[8],V=Y[9],B=l(U,$+0),j=l(U,$+2),S=l(U,$+4),M=l(U,$+6),F=l(U,$+8),s=l(U,$+10),g=l(U,$+12),p=l(U,$+14),w=Z[0]+(B&8191),P=Z[1]+((B>>>13|j<<3)&8191),L=Z[2]+((j>>>10|S<<6)&8191),D=Z[3]+((S>>>7|M<<9)&8191),O=Z[4]+((M>>>4|F<<12)&8191),E=Z[5]+(F>>>1&8191),A=Z[6]+((F>>>14|s<<2)&8191),C=Z[7]+((s>>>11|g<<5)&8191),k=Z[8]+((g>>>8|p<<8)&8191),v=Z[9]+(p>>>5|J),N=0,f=N+w*Q+P*(5*V)+L*(5*I)+D*(5*H)+O*(5*R);N=f>>>13,f&=8191,f+=E*(5*T)+A*(5*K)+C*(5*G)+k*(5*X)+v*(5*z),N+=f>>>13,f&=8191;let b=N+w*z+P*Q+L*(5*V)+D*(5*I)+O*(5*H);N=b>>>13,b&=8191,b+=E*(5*R)+A*(5*T)+C*(5*K)+k*(5*G)+v*(5*X),N+=b>>>13,b&=8191;let h=N+w*X+P*z+L*Q+D*(5*V)+O*(5*I);N=h>>>13,h&=8191,h+=E*(5*H)+A*(5*R)+C*(5*T)+k*(5*K)+v*(5*G),N+=h>>>13,h&=8191;let y=N+w*G+P*X+L*z+D*Q+O*(5*V);N=y>>>13,y&=8191,y+=E*(5*I)+A*(5*H)+C*(5*R)+k*(5*T)+v*(5*K),N+=y>>>13,y&=8191;let YU=N+w*K+P*G+L*X+D*z+O*Q;N=YU>>>13,YU&=8191,YU+=E*(5*V)+A*(5*I)+C*(5*H)+k*(5*R)+v*(5*T),N+=YU>>>13,YU&=8191;let SU=N+w*T+P*K+L*G+D*X+O*z;N=SU>>>13,SU&=8191,SU+=E*Q+A*(5*V)+C*(5*I)+k*(5*H)+v*(5*R),N+=SU>>>13,SU&=8191;let FU=N+w*R+P*T+L*K+D*G+O*X;N=FU>>>13,FU&=8191,FU+=E*z+A*Q+C*(5*V)+k*(5*I)+v*(5*H),N+=FU>>>13,FU&=8191;let _U=N+w*H+P*R+L*T+D*K+O*G;N=_U>>>13,_U&=8191,_U+=E*X+A*z+C*Q+k*(5*V)+v*(5*I),N+=_U>>>13,_U&=8191;let MU=N+w*I+P*H+L*R+D*T+O*K;N=MU>>>13,MU&=8191,MU+=E*G+A*X+C*z+k*Q+v*(5*V),N+=MU>>>13,MU&=8191;let wU=N+w*V+P*I+L*H+D*R+O*T;N=wU>>>13,wU&=8191,wU+=E*K+A*G+C*X+k*z+v*Q,N+=wU>>>13,wU&=8191,N=(N<<2)+N|0,N=N+f|0,f=N&8191,N=N>>>13,b+=N,Z[0]=f,Z[1]=b,Z[2]=h,Z[3]=y,Z[4]=YU,Z[5]=SU,Z[6]=FU,Z[7]=_U,Z[8]=MU,Z[9]=wU}finalize(){let{h:U,pad:$}=this,q=new Uint16Array(10),J=U[1]>>>13;U[1]&=8191;for(let Q=2;Q<10;Q++)U[Q]+=J,J=U[Q]>>>13,U[Q]&=8191;U[0]+=J*5,J=U[0]>>>13,U[0]&=8191,U[1]+=J,J=U[1]>>>13,U[1]&=8191,U[2]+=J,q[0]=U[0]+5,J=q[0]>>>13,q[0]&=8191;for(let Q=1;Q<10;Q++)q[Q]=U[Q]+J,J=q[Q]>>>13,q[Q]&=8191;q[9]-=8192;let Z=(J^1)-1;for(let Q=0;Q<10;Q++)q[Q]&=Z;Z=~Z;for(let Q=0;Q<10;Q++)U[Q]=U[Q]&Z|q[Q];U[0]=(U[0]|U[1]<<13)&65535,U[1]=(U[1]>>>3|U[2]<<10)&65535,U[2]=(U[2]>>>6|U[3]<<7)&65535,U[3]=(U[3]>>>9|U[4]<<4)&65535,U[4]=(U[4]>>>12|U[5]<<1|U[6]<<14)&65535,U[5]=(U[6]>>>2|U[7]<<11)&65535,U[6]=(U[7]>>>5|U[8]<<8)&65535,U[7]=(U[8]>>>8|U[9]<<5)&65535;let Y=U[0]+$[0];U[0]=Y&65535;for(let Q=1;Q<8;Q++)Y=(U[Q]+$[Q]|0)+(Y>>>16)|0,U[Q]=Y&65535;KU(q)}update(U){G0(this),u(U),U=OU(U);let{buffer:$,blockLen:q}=this,J=U.length;for(let Z=0;Z<J;){let Y=Math.min(q-this.pos,J-Z);if(Y===q){for(;q<=J-Z;Z+=q)this.process(U,Z);continue}if($.set(U.subarray(Z,Z+Y),this.pos),this.pos+=Y,Z+=Y,this.pos===q)this.process($,0,!1),this.pos=0}return this}destroy(){KU(this.h,this.r,this.buffer,this.pad)}digestInto(U){G0(this),u0(U,this),this.finished=!0;let{buffer:$,h:q}=this,{pos:J}=this;if(J){$[J++]=1;for(;J<16;J++)$[J]=0;this.process($,0,!0)}this.finalize();let Z=0;for(let Y=0;Y<8;Y++)U[Z++]=q[Y]>>>0,U[Z++]=q[Y]>>>8;return U}digest(){let{buffer:U,outputLen:$}=this;this.digestInto(U);let q=U.slice(0,$);return this.destroy(),q}}function Fq(U){let $=(J,Z)=>U(Z).update(J).digest(),q=U(new Uint8Array(32));return $.outputLen=q.outputLen,$.blockLen=q.blockLen,$.create=(J)=>U(J),$}var o0=(()=>Fq((U)=>new n0(U)))();function t0(U,$,q,J,Z,Y=20){let Q=U[0],z=U[1],X=U[2],G=U[3],K=$[0],T=$[1],R=$[2],H=$[3],I=$[4],V=$[5],B=$[6],j=$[7],S=Z,M=q[0],F=q[1],s=q[2],g=Q,p=z,w=X,P=G,L=K,D=T,O=R,E=H,A=I,C=V,k=B,v=j,N=S,f=M,b=F,h=s;for(let YU=0;YU<Y;YU+=2)g=g+L|0,N=W(N^g,16),A=A+N|0,L=W(L^A,12),g=g+L|0,N=W(N^g,8),A=A+N|0,L=W(L^A,7),p=p+D|0,f=W(f^p,16),C=C+f|0,D=W(D^C,12),p=p+D|0,f=W(f^p,8),C=C+f|0,D=W(D^C,7),w=w+O|0,b=W(b^w,16),k=k+b|0,O=W(O^k,12),w=w+O|0,b=W(b^w,8),k=k+b|0,O=W(O^k,7),P=P+E|0,h=W(h^P,16),v=v+h|0,E=W(E^v,12),P=P+E|0,h=W(h^P,8),v=v+h|0,E=W(E^v,7),g=g+D|0,h=W(h^g,16),k=k+h|0,D=W(D^k,12),g=g+D|0,h=W(h^g,8),k=k+h|0,D=W(D^k,7),p=p+O|0,N=W(N^p,16),v=v+N|0,O=W(O^v,12),p=p+O|0,N=W(N^p,8),v=v+N|0,O=W(O^v,7),w=w+E|0,f=W(f^w,16),A=A+f|0,E=W(E^A,12),w=w+E|0,f=W(f^w,8),A=A+f|0,E=W(E^A,7),P=P+L|0,b=W(b^P,16),C=C+b|0,L=W(L^C,12),P=P+L|0,b=W(b^P,8),C=C+b|0,L=W(L^C,7);let y=0;J[y++]=Q+g|0,J[y++]=z+p|0,J[y++]=X+w|0,J[y++]=G+P|0,J[y++]=K+L|0,J[y++]=T+D|0,J[y++]=R+O|0,J[y++]=H+E|0,J[y++]=I+A|0,J[y++]=V+C|0,J[y++]=B+k|0,J[y++]=j+v|0,J[y++]=S+N|0,J[y++]=M+f|0,J[y++]=F+b|0,J[y++]=s+h|0}function _q(U,$,q,J){let Z=U[0],Y=U[1],Q=U[2],z=U[3],X=$[0],G=$[1],K=$[2],T=$[3],R=$[4],H=$[5],I=$[6],V=$[7],B=q[0],j=q[1],S=q[2],M=q[3];for(let s=0;s<20;s+=2)Z=Z+X|0,B=W(B^Z,16),R=R+B|0,X=W(X^R,12),Z=Z+X|0,B=W(B^Z,8),R=R+B|0,X=W(X^R,7),Y=Y+G|0,j=W(j^Y,16),H=H+j|0,G=W(G^H,12),Y=Y+G|0,j=W(j^Y,8),H=H+j|0,G=W(G^H,7),Q=Q+K|0,S=W(S^Q,16),I=I+S|0,K=W(K^I,12),Q=Q+K|0,S=W(S^Q,8),I=I+S|0,K=W(K^I,7),z=z+T|0,M=W(M^z,16),V=V+M|0,T=W(T^V,12),z=z+T|0,M=W(M^z,8),V=V+M|0,T=W(T^V,7),Z=Z+G|0,M=W(M^Z,16),I=I+M|0,G=W(G^I,12),Z=Z+G|0,M=W(M^Z,8),I=I+M|0,G=W(G^I,7),Y=Y+K|0,B=W(B^Y,16),V=V+B|0,K=W(K^V,12),Y=Y+K|0,B=W(B^Y,8),V=V+B|0,K=W(K^V,7),Q=Q+T|0,j=W(j^Q,16),R=R+j|0,T=W(T^R,12),Q=Q+T|0,j=W(j^Q,8),R=R+j|0,T=W(T^R,7),z=z+X|0,S=W(S^z,16),H=H+S|0,X=W(X^H,12),z=z+X|0,S=W(S^z,8),H=H+S|0,X=W(X^H,7);let F=0;J[F++]=Z,J[F++]=Y,J[F++]=Q,J[F++]=z,J[F++]=B,J[F++]=j,J[F++]=S,J[F++]=M}var Mq=H0(t0,{counterRight:!1,counterLength:4,allowShortKeys:!1}),wq=H0(t0,{counterRight:!1,counterLength:8,extendNonceFn:_q,allowShortKeys:!1});var Pq=new Uint8Array(16),r0=(U,$)=>{U.update($);let q=$.length%16;if(q)U.update(Pq.subarray(q))},Lq=new Uint8Array(32);function a0(U,$,q,J,Z){if(Z!==void 0)u(Z,void 0,"AAD");let Y=U($,q,Lq),Q=p0(J.length,Z?Z.length:0,!0),z=o0.create(Y);if(Z)r0(z,Z);r0(z,J),z.update(Q);let X=z.digest();return KU(Y,Q),X}var e0=(U)=>($,q,J)=>{return{encrypt(Y,Q){let z=Y.length;Q=T0(z+16,Q,!1),Q.set(Y);let X=Q.subarray(0,-16);U($,q,X,X,1);let G=a0(U,$,q,X,J);return Q.set(G,z),KU(G),Q},decrypt(Y,Q){Q=T0(Y.length-16,Q,!1);let z=Y.subarray(0,-16),X=Y.subarray(-16),G=a0(U,$,q,z,J);if(!c0(X,G))throw Error("invalid tag");return Q.set(Y.subarray(0,-16)),U($,q,Q,Q,1),KU(G),Q}}},fJ=K0({blockSize:64,nonceLength:12,tagLength:16},e0(Mq)),R0=K0({blockSize:64,nonceLength:24,tagLength:16},e0(wq));class JU extends XU{static IV_LENGTH=24;static TAG_LENGTH=16;IV_LENGTH=JU.IV_LENGTH;TAG_LENGTH=JU.TAG_LENGTH;key=null;constructor(U){super(U)}async setKey(U){this.key=new Uint8Array(await this.p.subtle.exportKey("raw",U))}zeroKey(){if(this.key)this.key.fill(0);this.key=null}async encryptWithAAD(U,$){let q=this.p.getRandomValues(new Uint8Array(JU.IV_LENGTH)),Z=R0(this.requireRawKey(),q,$).encrypt(U),Y=new Uint8Array(q.length+Z.length);return Y.set(q,0),Y.set(Z,q.length),Y}async decryptWithAAD(U,$){if(U.byteLength<JU.IV_LENGTH+JU.TAG_LENGTH)throw new x("Invalid ciphertext: too short.");let q=U.subarray(0,JU.IV_LENGTH),J=U.subarray(JU.IV_LENGTH),Z=R0(this.requireRawKey(),q,$);try{return Z.decrypt(J)}catch{throw new x("Decryption failed: wrong passphrase or corrupted ciphertext")}}requireRawKey(){if(!this.key)throw Error("Encryption key not set");return this.key}}import*as iU from"argon2-browser";async function Dq(){if(typeof window<"u")return;if(globalThis.loadArgon2WasmModule)return;try{let{createRequire:U}=await import("node:module"),{readFile:$}=await import("node:fs/promises"),q=U(import.meta.url),J=q.resolve("argon2-browser/dist/argon2.js"),Z=q.resolve("argon2-browser/dist/argon2.wasm");globalThis.loadArgon2WasmModule=async()=>{let Y=new Uint8Array(await $(Z));return globalThis.Module={wasmBinary:Y,locateFile:(Q)=>Q==="argon2.wasm"?Z:Q},q(J)}}catch{}}async function U$(U,$,q,J){if(J==="node"){let Z=await import("@node-rs/argon2"),Y=typeof U==="string"?Buffer.from(U,"utf8"):Buffer.from(U),z=(await Z.hash(Y,{salt:$,timeCost:q.time,memoryCost:q.mem,parallelism:q.parallelism,outputLen:32,algorithm:Z.Algorithm.Argon2id})).split("$").pop();if(!z)throw Error("Unexpected argon2 hash format");let X=Buffer.from(z,"base64");return Y.fill(0),{hash:new Uint8Array(X)}}if(J==="browser")return await Dq(),iU.hash({pass:U,salt:$,time:q.time,mem:q.mem,parallelism:q.parallelism,hashLen:32,type:iU.ArgonType.Argon2id}).then((Z)=>{if(!Z||!Z.hash)throw new zU("Failed to produce key derivation");return{hash:Z.hash}}).catch((Z)=>{let Y=Z instanceof Error?Z.message:typeof Z==="string"?Z:"Unknown error";throw new zU(`argon2-browser failure: ${Y}`)});throw Error(`Unsupported environment: ${J}`)}class sU{presets;exportExtractable;name="argon2id";constructor(U,$=!1){this.presets=U;this.exportExtractable=$}async derive(U,$,q,J){let{hash:Z}=await U$(U,$,this.presets[q],J.isNode?"node":"browser");if(this.exportExtractable)return J.subtle.importKey("raw",Z,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]);else return J.subtle.importKey("raw",Z,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}}var $$={low:{time:5,mem:65536,parallelism:1},middle:{time:20,mem:65536,parallelism:1},high:{time:40,mem:65536,parallelism:1}},Oq={id:0,cipher:qU,kdf:new sU($$),saltLengths:{low:12,high:16},difficulties:$$,defaultChunkSize:524288};d.register(Oq);var q$={low:{time:5,mem:65536,parallelism:2},middle:{time:10,mem:98304,parallelism:4},high:{time:20,mem:98304,parallelism:4}},Eq={id:1,cipher:JU,kdf:new sU(q$,!0),saltLengths:{low:12,high:16},difficulties:q$,defaultChunkSize:524288};d.register(Eq);var nU=1;function EU(U,$,q,J,Z){let Y={low:0,middle:1,high:2};if(!($ in Y))throw TypeError(`Unsupported difficulty: ${$}`);let Q=Y[$],z=U<<5|(q==="high"?1:0)<<2|Q,X=LU(new Uint8Array([nU,z]),J);if(Z)Z.setAAD(X);return X}function ZU(U,$){if(U[0]!==nU)throw new a("Invalid input format. The input is unknown.");if(U.length<14)throw new a("Invalid input format. Header too short.");try{let q=U[1],J=q>>5,Z=q>>2&1?"high":"low",Y=q&3,Q=["low","middle","high"][Y],z=d.get(J).saltLengths[Z],X=2+z;if(U.length<X)throw new a("Invalid input format. Header truncated.");if($)$.setAAD(U.subarray(0,X));let G=U.slice(2,2+z);return{scheme:J,difficulty:Q,saltStrength:Z,salt:G,headerLen:X}}catch(q){throw new RU(q instanceof Error?q.message:String(q))}}async function oU(U){if(U instanceof Uint8Array)return U;if(U instanceof ArrayBuffer)return new Uint8Array(U);return new Uint8Array(await U.arrayBuffer())}function V0(U){let $=new Uint8Array(4);return new DataView($.buffer).setUint32(0,U,!1),$}function J$(U,$=0){if(U.length-$<4)throw RangeError("Not enough bytes for frame header");return new DataView(U.buffer,U.byteOffset+$,4).getUint32(0,!1)}var TU=4;class bU{engine;chunkSize;buffer=new Uint8Array(0);constructor(U,$=524288){this.engine=U;this.chunkSize=$}toTransformStream(){return new TransformStream({transform:async(U,$)=>{await this.transform(await oU(U),$)},flush:async(U)=>this.flush(U)})}async transform(U,$){if(U.length>Math.min(this.chunkSize*4,67108864))throw RangeError(`Input block (${U.length} B) exceeds maximum allowed ${Math.min(this.chunkSize*4,67108864)} B`);let J=new Uint8Array(this.buffer.length+U.length);J.set(this.buffer),J.set(U,this.buffer.length);let Z=0;while(J.length-Z>=this.chunkSize){let Y=J.slice(Z,Z+this.chunkSize);Z+=this.chunkSize;let Q=await this.engine.encryptChunk(Y),z=new Uint8Array(TU+Q.length);z.set(V0(Q.length)),z.set(Q,TU),$.enqueue(z)}this.buffer=J.slice(Z)}async flush(U){if(!this.buffer.length)return;let $=await this.engine.encryptChunk(this.buffer),q=new Uint8Array(TU+$.length);q.set(V0($.length)),q.set($,TU),U.enqueue(q),this.buffer=new Uint8Array(0),this.engine.zeroKey()}}class AU{engine;chunkSize;buffer=new Uint8Array(0);constructor(U,$=524288){this.engine=U;this.chunkSize=$}toTransformStream(){return new TransformStream({transform:async(U,$)=>{await this.transform(await oU(U),$)},flush:async(U)=>this.flush(U)})}async transform(U,$){let q=new Uint8Array(this.buffer.length+U.length);q.set(this.buffer),q.set(U,this.buffer.length);let J=0;while(!0){if(q.length-J<TU)break;let Z=J$(q,J),Y=67108864,Q=this.engine.IV_LENGTH+this.engine.TAG_LENGTH;if(!Number.isInteger(Z)||Z<Q||Z>Y){$.error(new x(`Invalid frame length ${Z} (min=${Q}, max=${Y})`));return}if(q.length-J-TU<Z)break;J+=TU;let z=q.slice(J,J+Z);J+=Z;try{let X=await this.engine.decryptChunk(z);$.enqueue(X)}catch(X){$.error(X instanceof x?X:new x("Decryption failed: Wrong passphrase or corrupted ciphertext"));return}}this.buffer=q.slice(J)}async flush(U){await this.transform(new Uint8Array(0),U);let $=this.buffer.byteLength;if(this.buffer=new Uint8Array(0),this.engine.zeroKey(),$!==0){U.error(new x("Truncated ciphertext: incomplete final frame"));return}}}async function Z$(U,$){let q=U.getReader(),J=$&&$.length?[$]:[];try{while(!0){let{value:z,done:X}=await q.read();if(X)break;J.push(z)}}finally{q.releaseLock()}let Z=J.reduce((z,X)=>z+X.byteLength,0),Y=new Uint8Array(Z),Q=0;for(let z of J)Y.set(z,Q),Q+=z.byteLength;return Y}class CU{engine;chunkSize;constructor(U,$=524288){this.engine=U;this.chunkSize=$}encryptionStream(){let U=new bU(this.engine,this.chunkSize).toTransformStream();return{writable:U.writable,readable:U.readable}}decryptionStream(U){let $=U,q=new TransformStream({transform(Z,Y){if($===0){Y.enqueue(Z);return}if(Z.byteLength<=$){$-=Z.byteLength;return}Y.enqueue(Z.slice($)),$=0}}),J=new AU(this.engine,this.chunkSize).toTransformStream();return{writable:q.writable,readable:q.readable.pipeThrough(J)}}async collect(U,$,q=null){return Z$(U.pipeThrough($),q??void 0)}getEngine(){return this.engine}}function Y$(U){try{if(U)U.fill(0)}catch{}}function Aq(U){let $="";for(let q=0;q<U.length;q++){let J=U[q].toString(16).padStart(2,"0");$+=J}return $}class WU{bytes;destroyed=!1;static from(U){if(U instanceof WU)return U;if(typeof U==="string")return new WU(new TextEncoder().encode(U));if(U instanceof Uint8Array)return new WU(U);throw TypeError("ConvertibleInput: unsupported input type")}constructor(U){this.bytes=U}toUint8Array(){if(this.destroyed)throw Error("ConvertibleInput: already cleared");return this.bytes}clear(){if(!this.destroyed)Y$(this.bytes),this.bytes=new Uint8Array(0),this.destroyed=!0}}class xU{bytes;destroyed=!1;constructor(U){this.bytes=U}get uint8array(){if(this.destroyed)throw Error("ConvertibleOutput: already cleared");return this.bytes}get base64(){if(this.destroyed)throw Error("ConvertibleOutput: already cleared");return DU(this.bytes)}get hex(){if(this.destroyed)throw Error("ConvertibleOutput: already cleared");return Aq(this.bytes)}get text(){if(this.destroyed)throw Error("ConvertibleOutput: already cleared");return new TextDecoder().decode(this.bytes)}clear(){if(!this.destroyed)Y$(this.bytes),this.bytes=new Uint8Array(0),this.destroyed=!0}toString(){return this.base64}}class gU extends Error{constructor(U="Malformed padding"){super(U)}}class m{static STRUCT_SIZE=8;static MAGIC40=new Uint8Array([196,231,155,173,242]);static VERSION=41;static CRC8_POLY=7;maxPad=m.STRUCT_SIZE+8-1;static ctEqU8(U,$){return(((U|0)^($|0))&255)===0}static ctEqFixedLen(U,$){let q=0,J=U.length;for(let Z=0;Z<J;Z++)q|=U[Z]^$[Z];return q===0}crc8(U){let $=0;for(let q=0;q<U.length;q++){$^=U[q]&255;for(let J=0;J<8;J++)$=$&128?$<<1^m.CRC8_POLY:$<<1,$&=255}return $&255}computeK(U,$){let q=m.STRUCT_SIZE;if(!Number.isInteger($)||$<1)throw new gU("align must be a positive integer");if(q+$-1>255)throw new gU("align too large for 1-byte LEN");let J=q+$-1,Z=($-U%$)%$;if(Z===0)Z=$;while(Z<q)Z+=$;if(Z>J)throw new gU("Cannot satisfy alignment within 1-byte LEN");return Z}pad(U,$,q=8){let J=m.STRUCT_SIZE,Z=this.computeK(U.length,q),Y=Z-J,Q=new Uint8Array(U.length+Z);if(Q.set(U,0),Y>0){let G=$(Y);if(!G||G.length!==Y)throw new gU("rng returned wrong length");Q.set(G,U.length)}let z=U.length+Y;Q.set(m.MAGIC40,z+0),Q[z+5]=m.VERSION&255,Q[z+6]=Z&255;let X=new Uint8Array(7);return X.set(m.MAGIC40,0),X[5]=m.VERSION&255,X[6]=Z&255,Q[z+7]=this.crc8(X),Q}tryUnpad(U){let $=m.STRUCT_SIZE,q=()=>({used:!1,plain:U});if(U.length<$)return q();let J=U.length,Z=U[J-1]&255,Y=U[J-2]&255,Q=U[J-3]&255;if(Y<$||Y>U.length)return q();let z=J-$,X=U.subarray(z,z+5);if(!m.ctEqFixedLen(X,m.MAGIC40))return q();if(!m.ctEqU8(Q,m.VERSION&255))return q();let K=new Uint8Array(7);K.set(m.MAGIC40,0),K[5]=Q,K[6]=Y;let T=this.crc8(K);if(!m.ctEqU8(T,Z))return q();return{used:!0,plain:U.subarray(0,J-Y)}}}function Q$(U=0,$=console.info){return{level:U,log(q,J){if(q<=U)$(`${q}| ${J}`)}}}var z$=new WeakMap;class NU{static getEngine(U,$){let q=z$.get(U);if(!q)q=new Map,z$.set(U,q);let J=q.get($);if(J)return J;let Z=d.get($);return J={desc:Z,cipher:new Z.cipher(U),kdf:Z.kdf,chunkSize:Z.defaultChunkSize,provider:U},q.set($,J),J}static async deriveKey(U,$,q,J){try{let Z=await U.kdf.derive($.value,q,J,U.provider);await U.cipher.setKey(Z)}catch(Z){let Y=Z instanceof Error?Z.message:String(Z);throw new zU(Y)}finally{i($)}}}class n{provider;v;cipher;kdf;chunkSize;stream;acceptUnauthenticatedHeader;difficulty;saltStrength;engines=new Map;log;constructor(U,$={}){this.provider=U;this.v=d.get($.scheme??d.current.id),this.cipher=new this.v.cipher(U),this.kdf=this.v.kdf,this.chunkSize=this.setChunkSize($.chunkSize??this.v.defaultChunkSize),this.stream=new CU(this.cipher,this.chunkSize),this.difficulty=$.difficulty??"middle",this.saltStrength=$.saltStrength??"high",this.acceptUnauthenticatedHeader=$.acceptUnauthenticatedHeader??!1,this.log=Q$($.verbose??0,$.logger)}static async isEncrypted(U){try{return await n.peekHeader(U),!0}catch{return!1}}static async decodeHeader(U){let $=await n.peekHeader(U),q=ZU($);return{scheme:q.scheme,difficulty:q.difficulty,salt:DU(q.salt),saltBytes:q.salt,saltLength:q.salt.byteLength}}static async headerDecode(U){return this.decodeHeader(U)}static isRandomAccessSource(U){return typeof U==="object"&&U!==null&&typeof U.read==="function"}static async decodeData(U){let $=n.isRandomAccessSource(U)?U:new X0(U),q=await $.read(0,Math.min(256,$.length)),J=await n.peekHeader(q),{scheme:Z,headerLen:Y}=ZU(J),Q=$.length,z=Q-Y;if(z<0)throw new a("Payload underflow");if(z===0)return{isChunked:!0,chunks:{chunkSize:0,count:0,totalPayload:0}};let X=await $.read(Y,4),G=new DataView(X.buffer,X.byteOffset,4).getUint32(0,!1);if(G+4<=z&&G>=28){let I=G,V=Y,B=0,j=0;while(V+4<=Q){let S=await $.read(V,4),M=new DataView(S.buffer,S.byteOffset,4).getUint32(0,!1);if(M===0||V+4+M>Q)break;B++,j+=M,V+=4+M}return{isChunked:!0,chunks:{chunkSize:I,count:B,totalPayload:j}}}let T=await $.read(Y,z),R=d.get(Z).cipher.IV_LENGTH,H=d.get(Z).cipher.TAG_LENGTH;if(T.length<R+H)throw new a("Ciphertext too short for IV & tag");return{isChunked:!1,payloadLength:z-R-H,params:{iv:T.slice(0,R),ivLength:R,tag:T.slice(T.length-H),tagLength:H}}}setDifficulty(U){this.difficulty=U}getDifficulty(){return this.difficulty}setScheme(U){this.v=d.get(U),this.cipher=new this.v.cipher(this.provider),this.kdf=this.v.kdf,this.stream=new CU(this.cipher,this.chunkSize)}getScheme(){return this.v.id}setSaltDifficulty(U){this.saltStrength=U}getSaltDifficulty(){return this.saltStrength}setChunkSize(U){let q=U,J;if(q==null)J=this.v.defaultChunkSize;else{if(J=Number(q),!Number.isInteger(J)||J<1)throw Error(`Invalid chunkSize: ${q}. Must be a positive integer.`);if(J>134217728)throw RangeError("chunkSize cannot exceed 134217728 bytes.")}if(this.chunkSize=J,this.stream)this.stream=new CU(this.cipher,this.chunkSize);return J}getChunkSize(){return this.chunkSize}setVerbose(U){this.log.level=U}getVerbose(){return this.log.level}async encryptText(U,$){if($===null)throw new $U("Password can't be null");let q={value:$};try{if($==="")this.log.log(0,"Empty passphrase provided to encryptText");this.log.log(1,`Start text encryption, scheme: ${this.getScheme()}`);let J=WU.from(U),Z=J.toUint8Array();this.log.log(2,"Deriving key for text encryption");let Y=this.genSalt();await this.deriveKey(q,Y),i(q),$=null,this.log.log(3,`Salt generated: ${DU(Y)}, KDF difficulty: ${this.difficulty}`),this.log.log(3,"Encoding header");let Q=EU(this.v.id,this.difficulty,this.saltStrength,Y,this.cipher);this.cipher.setPaddingScheme(new m),this.cipher.setPaddingAlign(8),this.cipher.setPaddingAADMode("require"),this.log.log(2,"Encrypting text data");let z=await this.cipher.encryptChunk(Z);this.cipher.zeroKey();try{J.clear()}catch{}let X=LU(Q,z);return this.log.log(1,"Encryption finished"),new xU(X)}catch(J){throw new $U(J instanceof Error?J.message:String(J))}}async decryptText(U,$){if($===null)throw new $U("Password can't be null");let q={value:$};try{if($==="")this.log.log(0,"Empty passphrase provided to decryptText");this.log.log(1,`Start text decryption, Version ${this.getScheme()}`);let J;if(typeof U==="string")this.log.log(3,"Decoding Base64 ciphertext"),J=yU(U);else if(U instanceof Uint8Array)J=U;else if(U instanceof WU)J=U.toUint8Array();else throw new PU("Unsupported ciphertext input type");this.log.log(3,"Start header decoding");let Z=ZU(J);this.log.log(3,"Selecting decryption engine");let Y=NU.getEngine(this.provider,Z.scheme);this.log.log(2,`Deriving key via engine for scheme: ${Z.scheme}`),this.log.log(3,`Salt use: ${DU(Z.salt)}, KDF difficulty: ${Z.difficulty}`);try{await NU.deriveKey(Y,q,Z.salt,Z.difficulty)}finally{i(q),$=null}Y.cipher.setPaddingScheme(new m),Y.cipher.setPaddingAlign(8),Y.cipher.setPaddingAADMode("require"),Y.cipher.setLegacyAADFallback({enabled:!0,policy:"auto",tryEmptyAAD:this.acceptUnauthenticatedHeader?!0:!1}),this.log.log(2,"Decrypting text data"),ZU(J,Y.cipher);let Q=await Y.cipher.decryptChunk(J.slice(Z.headerLen));if(Y.cipher.zeroKey(),U instanceof WU)try{U.clear()}catch{}return this.log.log(1,"Decryption finished"),new xU(Q)}catch(J){if(J instanceof x||J instanceof a||J instanceof RU||J instanceof PU||J instanceof zU)throw J;throw new x("Decryption failed: wrong passphrase or corrupted ciphertext")}}async encryptFile(U,$){if($===null)throw new $U("Password can't be null");let q={value:$};try{if(U.size===0){let Q=this.genSalt();await this.deriveKey(q,Q),i(q),$=null;let z=EU(this.v.id,this.difficulty,this.saltStrength,Q);return new Blob([z],{type:"application/octet-stream"})}this.log.log(2,"Deriving key for file encryption");let J=this.genSalt();await this.deriveKey(q,J),i(q),$=null;let Z=EU(this.v.id,this.difficulty,this.saltStrength,J,this.stream.getEngine());this.stream.getEngine().setPaddingAADMode("forbid");let Y=await this.stream.collect(U.stream(),new bU(this.cipher,this.chunkSize).toTransformStream(),Z);return new Blob([Y],{type:"application/octet-stream"})}catch(J){throw new $U(J instanceof Error?J.message:String(J))}}async decryptFile(U,$){if($===null)throw new $U("Password can't be null");let q={value:$};try{let J=await n.peekHeader(U),Z=ZU(J),Y=NU.getEngine(this.provider,Z.scheme);try{await NU.deriveKey(Y,q,Z.salt,Z.difficulty)}finally{i(q),$=null}if(U.size===Z.headerLen)return new Blob([],{type:"application/octet-stream"});this.log.log(2,"Decrypting file data");let Q=new CU(Y.cipher,Y.chunkSize);ZU(J,Q.getEngine()),Y.cipher.setPaddingAADMode("forbid"),Y.cipher.setLegacyAADFallback({enabled:!0,policy:"auto",tryEmptyAAD:this.acceptUnauthenticatedHeader?!0:!1});let z=await Q.collect(U.slice(Z.headerLen).stream(),new AU(Y.cipher,Y.chunkSize).toTransformStream());return new Blob([z],{type:"application/octet-stream"})}catch(J){if(J instanceof x)throw J;throw new x(J instanceof Error?J.message:String(J))}}async createEncryptionStream(U){if(U===null)throw new $U("Password can't be null");let $={value:U};this.log.log(2,"Deriving key for stream encryption");let q=this.genSalt();await this.deriveKey($,q),i($),U=null;let J=EU(this.v.id,this.difficulty,this.saltStrength,q,this.stream.getEngine());this.stream.getEngine().setPaddingAADMode("forbid");let Z=this.stream.encryptionStream();return{header:J,writable:Z.writable,readable:Z.readable}}async createDecryptionStream(U){if(U===null)throw new $U("Password can't be null");let $=this.provider,q={value:U},J=new Uint8Array(0),Z=null,Y=65536,Q=2,z=async(X,G)=>{let K=X.getReader();while(!0){let{value:T,done:R}=await K.read();if(R)break;G.enqueue(T)}};return new TransformStream({transform:async(X,G)=>{if(!Z){let T=new Uint8Array(0);if(X&&X.byteLength){let F=Math.max(0,Y-J.byteLength),s=F?X.subarray(0,F):new Uint8Array(0);if(T=X.subarray(s.byteLength),s.byteLength){let g=new Uint8Array(J.byteLength+s.byteLength);g.set(J),g.set(s,J.byteLength),J=g}}if(J.byteLength<Q)return;let R=J[1],H=R>>5,I=R>>2&1?"high":"low",V=0;try{V=2+d.get(H).saltLengths[I]}catch(F){i(q),G.error(new RU(F instanceof Error?F.message:String(F)));return}if(J.byteLength<V){if(J.byteLength>=Y)i(q),G.error(new a(`Header not found within ${Y} bytes`));return}let B=J.subarray(0,V),j;try{j=ZU(B)}catch(F){i(q),G.error(F instanceof Error?F:new RU("Invalid header"));return}let S=NU.getEngine($,j.scheme);try{await NU.deriveKey(S,q,j.salt,j.difficulty)}finally{i(q),U=null}ZU(B,S.cipher),S.cipher.setPaddingAADMode("forbid"),S.cipher.setLegacyAADFallback({enabled:!0,policy:"auto",tryEmptyAAD:this.acceptUnauthenticatedHeader?!0:!1}),Z=new AU(S.cipher,S.chunkSize).toTransformStream(),z(Z.readable,G).catch((F)=>G.error(F));let M=J.subarray(V);if(J=new Uint8Array(0),M.byteLength||T.byteLength){let F=Z.writable.getWriter();if(M.byteLength)await F.write(M);if(T.byteLength)await F.write(T);F.releaseLock()}return}let K=Z.writable.getWriter();await K.write(X),K.releaseLock()},flush:async()=>{if(!Z)throw i(q),new a("Header not found before end of stream");let X=Z.writable.getWriter();await X.close(),X.releaseLock()}})}generateFakeData(U=0,$=!1){if(!Number.isInteger(U)||U<0)throw RangeError("payloadLength must be a non-negative integer.");let q=this.genSalt(),J=EU(this.v.id,this.difficulty,this.saltStrength,q,this.cipher),Z=U;if($){let X=Math.max(16,Z);Z=Math.ceil(X/8)*8}let Y=Z>0?this.provider.getRandomValues(new Uint8Array(Z)):new Uint8Array(0);return LU(J,Y)}async deriveKey(U,$,q=this.difficulty){let J=performance.now();try{let Z=await this.kdf.derive(U.value,$,q,this.provider);i(U),await this.cipher.setKey(Z),this.log.log(3,`Key derivation completed in ${(performance.now()-J).toFixed(1)} ms`)}catch(Z){throw new zU(Z instanceof Error?Z.message:String(Z))}}genSalt(U=this.saltStrength){let $=this.v.saltLengths[U];return this.provider.getRandomValues(new Uint8Array($))}static async peekHeader(U){let $=await this.readAsUint8(U);if($.length<2)throw new a("Input too short");let{headerLen:q}=ZU($.length>=32?$:$.slice());if($.length<q)throw new a("Incomplete header");return $.slice(0,q)}static async readAsUint8(U){if(typeof U==="string")return yU(U);if(U instanceof Uint8Array)return U;if(U instanceof Blob){let $=Math.max(32,Math.min(256,U.size)),q=U.slice(0,$);return new Uint8Array(await q.arrayBuffer())}throw new RU("Unsupported input type")}}import{webcrypto as Cq,randomFillSync as kq}from"node:crypto";var X$={subtle:Cq.subtle,getRandomValues(U){return kq(U),U},isNode:!0};function kU(U){return new n(X$,U)}import{dirname as xq,resolve as K$,sep as T$,isAbsolute as gq}from"node:path";import{Readable as vq,Writable as yq}from"node:stream";function N0(U){return vq.toWeb(U)}function I0(U){return yq.toWeb(U)}import{promises as jU}from"fs";import*as R$ from"os";import*as B0 from"path";var hq="2.2.1",mq=process.cwd();async function aU(){if(!t.isTTY)throw Error("STDIN not a TTY; use --pass");c.write("Passphrase: "),t.setRawMode?.(!0),t.resume(),t.setEncoding("utf8");let U="";return new Promise(($)=>{function q(){t.setRawMode?.(!1),t.pause(),c.write(`
`),t.off("data",J),$(U)}function J(Z){if(Z==="\x03")o(130);if(Z==="\r"||Z===`
`)return q();if(Z==="\b"||Z===""){U=U.slice(0,-1);return}U+=Z}t.on("data",J)})}function S0(U,$=mq){if(U==="-")return;let q=G$($),J=gq(U)?K$(U):K$(q,U),Z=xq(J);if(!rU(Z))throw new VU(`Output directory does not exist: ${Z}`);let Y=G$(Z);if(!Y.startsWith(q+T$))throw new VU("Refusing to write outside of root directory.");if(!Y.startsWith(q+T$))throw new VU("Refusing to write outside of root directory.");if(!rU(Z))throw new VU(`Output directory does not exist: ${Z}`);try{fq(Z,bq.W_OK)}catch{throw new VU("Output directory is not writeable")}return J}async function H$(){let U=[];for await(let $ of t)U.push($);return Buffer.concat(U).toString("utf8")}var r=new h0;r.name("cryptit").version(hq).description(`Text and File Encryption Utility
Scheme 0: AES-GCM (Native) / Argon2id (Single Thread)
Scheme 1: XChaCha20-Poly1305 (JS Engine) / Argon2id (Parallel)`).showHelpAfterError().showSuggestionAfterError().addOption(new BU("-S, --scheme <0-1>","encryption scheme version").argParser((U)=>{let $=Number(U);if(!Number.isInteger($)||$<0||$>7)throw Error("Version size must be a integer between 0 and 7");return $}).default(0,"0")).addOption(new BU("-p, --pass <passphrase>","passphrase (prompt if omitted)").hideHelp().argParser((U)=>{if(!U.trim())throw Error("Passphrase cannot be empty");return U})).addOption(new BU("-d, --difficulty <level>","argon2 difficulty").choices(["low","middle","high"]).default("middle","middle")).addOption(new BU("-s, --salt-strength <variant>","salt length variant").choices(["low","high"]).default("high","high")).addOption(new BU("-c, --chunk-size <bytes>","chunk size in bytes").argParser((U)=>{let $=Number(U);if(!Number.isInteger($)||$<=0)throw Error("Chunk size must be a positive integer");return $}).default(524288,"512*1024")).addOption(new BU("-v, --verbose","increase verbosity (use multiple times)").default(0).argParser((U,$)=>{return $+1}));process.on("uncaughtException",(U)=>{if(U instanceof Error){let $=U.constructor.name,q=U.message;c.write(`Error [${$}]: ${q}
`)}else c.write(`Error [Unknown]: ${String(U)}
`);o(1)});process.on("unhandledRejection",(U)=>{if(U instanceof Error){let $=U.constructor.name,q=U.message;c.write(`Error [${$}]: ${q}
`)}else c.write(`Error [Unknown]: ${String(U)}
`);o(1)});r.command("decode [src]").description("Show Cryptit header information plus payload details; omit arg or use - to read from STDIN").action(async(U)=>{let $=!U||U==="-";async function q(X){if(X.length<2)throw Error("Input too short for header");let G=X.subarray(0,Math.min(256,X.length)),K=await n.decodeHeader(G),T=await n.decodeData(X);if(delete K.saltBytes,T.isChunked){let{chunkSize:I,count:V,totalPayload:B}=T.chunks;return{...K,isChunked:!0,chunks:{chunkSize:I,count:V,totalPayload:B}}}let R=Buffer.from(T.params.iv).toString("base64"),H=Buffer.from(T.params.tag).toString("base64");return{...K,isChunked:!1,payloadLength:T.payloadLength,params:{iv:R,ivLength:T.params.ivLength,tag:H,tagLength:T.params.tagLength}}}async function J(X){let G=await X.read(0,Math.min(256,X.length)),K=await n.decodeHeader(G),T=await n.decodeData(X);if(delete K.saltBytes,T.isChunked){let{chunkSize:I,count:V,totalPayload:B}=T.chunks;return{...K,isChunked:!0,chunks:{chunkSize:I,count:V,totalPayload:B}}}let R=Buffer.from(T.params.iv).toString("base64"),H=Buffer.from(T.params.tag).toString("base64");return{...K,isChunked:!1,payloadLength:T.payloadLength,params:{iv:R,tag:H}}}async function Z(){let X=Number(process.env.CRYPTIT_STDIN_MAX_BYTES),G=10737418240,K=Number.isFinite(X)&&X>0?Math.floor(X):10737418240,T=await jU.mkdtemp(B0.join(R$.tmpdir(),"cryptit-")),R=B0.join(T,"stdin.bin"),H=j0(R,{flags:"w"}),I=0;try{for await(let V of process.stdin){let B=Buffer.isBuffer(V)?V:Buffer.from(V);if(I+=B.length,I>K)throw H.destroy(),await jU.rm(T,{recursive:!0,force:!0}).catch(()=>{}),new VU(`STDIN exceeds maximum allowed size (${K} bytes). Aborting.`);if(!H.write(B))await new Promise((j)=>H.once("drain",j))}return await new Promise((V,B)=>{H.end(()=>V()),H.on("error",B)}),R}catch(V){throw H.destroy(),await jU.rm(T,{recursive:!0,force:!0}).catch(()=>{}),V}}if(!$&&U){let X=await fU.open(U);try{let G=await J(X);e.write(JSON.stringify(G,null,2)+`
`)}finally{await X.close()}return}if($){let X=await Z(),G=await fU.open(X);try{try{let I=await J(G);e.write(JSON.stringify(I,null,2)+`
`);return}catch{}}finally{await G.close()}let K=(await jU.readFile(X,{encoding:"utf8"})).trim();if(await jU.unlink(X),!(/^[A-Za-z0-9+/]+={0,2}$/.test(K)&&K.length%4===0))c.write(`Error: Input neither valid Cryptit binary nor Base-64 text
`),o(1);let R=Buffer.from(K,"base64"),H=await q(new Uint8Array(R));e.write(JSON.stringify(H,null,2)+`
`);return}let Y=Buffer.from(U,"utf8"),Q=Y.toString("utf8").trim(),z=/^[A-Za-z0-9+/]+={0,2}$/.test(Q)&&Q.length%4===0;try{if(z){let X=Buffer.from(Q,"base64"),G=await q(new Uint8Array(X));e.write(JSON.stringify(G,null,2)+`
`)}else{let X=await q(new Uint8Array(Y));e.write(JSON.stringify(X,null,2)+`
`)}}catch(X){let G=X instanceof Error?X.message:String(X);c.write(`Error: ${G}
`),o(1)}});r.command("encrypt <src>").description("Encrypt file; use - for STDIN, --out - for STDOUT").option("-p, --pass <passphrase>","passphrase (prompt if omitted)").option("-o, --out <file>","output file (default STDOUT)","-").action(async(U,$)=>{if(U!=="-"&&!rU(U))c.write(`Error: input file not found: ${U}
`),o(1);let q=r.opts(),J=kU({difficulty:q.difficulty,saltStrength:q.saltStrength,chunkSize:q.chunkSize,verbose:q.verbose,scheme:q.scheme}),Z=q.pass??(t.isTTY?await aU():(()=>{c.write(`Use --pass when piping via STDIN
`),o(1)})());try{S0($.out)}catch(H){c.write(`Error: ${H.message}
`),o(1)}let Y=U==="-"?t:W$(U),Q=$.out==="-"?e:j0($.out),{header:z,writable:X,readable:G}=await J.createEncryptionStream(Z),K=N0(Y),T=I0(Q),R=T.getWriter();await R.write(z),R.releaseLock(),await Promise.all([K.pipeTo(X),G.pipeTo(T)])});r.command("decrypt <src>").description("Decrypt file; use - for STDIN, --out - for STDOUT").option("-p, --pass <passphrase>","passphrase (prompt if omitted)").option("-o, --out <file>","output file (default STDOUT)","-").option("--legacy","Enable text decryption of version < 1.0.0",!1).action(async(U,$)=>{if(U!=="-"&&!rU(U))c.write(`Error: input file not found: ${U}
`),o(1);let q=r.opts(),J=kU({difficulty:q.difficulty,saltStrength:q.saltStrength,chunkSize:q.chunkSize,verbose:q.verbose,scheme:q.scheme,acceptUnauthenticatedHeader:$.legacy});try{S0($.out)}catch(K){c.write(`Error: ${K.message}
`),o(1)}let Z=q.pass??await aU(),Y=U==="-"?t:W$(U),Q=$.out==="-"?e:j0($.out),z=N0(Y),X=I0(Q),G=await J.createDecryptionStream(Z);await Promise.all([z.pipeTo(G.writable),G.readable.pipeTo(X)])});r.command("encrypt-text [text]").description("Encrypt plaintext; omit arg to read from STDIN").option("-p, --pass <passphrase>","passphrase (prompt if omitted)").action(async(U)=>{let $=r.opts(),q=kU({difficulty:$.difficulty,saltStrength:$.saltStrength,verbose:$.verbose,scheme:$.scheme}),J=$.pass??(t.isTTY?await aU():(()=>{c.write(`Use --pass when piping via STDIN
`),o(1)})()),Z=U??await H$(),Y=await q.encryptText(Z,J);e.write(Y.base64+`
`)});r.command("decrypt-text [b64]").description("Decrypt Base64 ciphertext; omit arg to read from STDIN").option("-p, --pass <passphrase>","passphrase (prompt if omitted)").option("--legacy","Enable text decryption of version < 1.0.0",!1).action(async(U,$)=>{let q=r.opts(),J=kU({difficulty:q.difficulty,saltStrength:q.saltStrength,verbose:q.verbose,scheme:q.scheme,acceptUnauthenticatedHeader:$.legacy}),Z=q.pass??await aU(),Y=U??(await H$()).trim();if(!/^[A-Za-z0-9+/]+={0,2}$/.test(Y))c.write(`Error: ciphertext does not look like Base64
`),o(1);let Q=await J.decryptText(Y,Z);e.write(Q.text+`
`)});r.command("fake-data <length>").description("Emit a valid Cryptit header followed by <length> random bytes").option("-o, --out <file>","output file (default STDOUT)","-").option("--base64","encode output as Base64 text (adds trailing newline)").option("--use-padding","rounds <length> to the nearest 8 bytes to allow for realistic text-payloads.",!1).action(async(U,$)=>{let q=Number(U);if(!Number.isInteger(q)||q<0)c.write(`Error: <length> must be a non-negative integer
`),o(1);let J=r.opts(),Z=kU({difficulty:J.difficulty,saltStrength:J.saltStrength,chunkSize:J.chunkSize,verbose:J.verbose,scheme:J.scheme});try{S0($.out)}catch(z){c.write(`Error: ${z.message}
`),o(1)}let Y=Z.generateFakeData(q,$.usePadding),Q=Buffer.from(Y);if($.base64){let z=Q.toString("base64")+`
`;if($.out==="-")e.write(z);else await jU.writeFile($.out,z,{encoding:"utf8"});return}if($.out==="-")e.write(Q);else await jU.writeFile($.out,Q)});if(process.argv.length<=2)r.outputHelp(),process.exit(1);r.parse();

//# debugId=04DEB8DCFF68E7D364756E2164756E21
