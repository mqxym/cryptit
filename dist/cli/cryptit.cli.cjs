#!/usr/bin/env node
var B$=Object.create;var{getPrototypeOf:j$,defineProperty:P0,getOwnPropertyNames:F$}=Object;var S$=Object.prototype.hasOwnProperty;var NU=(U,$,q)=>{q=U!=null?B$(j$(U)):{};let J=$||!U||!U.__esModule?P0(q,"default",{value:U,enumerable:!0}):q;for(let Z of F$(U))if(!S$.call(J,Z))P0(J,Z,{get:()=>U[Z],enumerable:!0});return J};var VU=(U,$)=>()=>($||U(($={exports:{}}).exports,$),$.exports);var yU=VU((U0)=>{class eU extends Error{constructor(U,$,q){super(q);Error.captureStackTrace(this,this.constructor),this.name=this.constructor.name,this.code=$,this.exitCode=U,this.nestedError=void 0}}class D0 extends eU{constructor(U){super(1,"commander.invalidArgument",U);Error.captureStackTrace(this,this.constructor),this.name=this.constructor.name}}U0.CommanderError=eU;U0.InvalidArgumentError=D0});var mU=VU(($0)=>{var{InvalidArgumentError:_$}=yU();class O0{constructor(U,$){switch(this.description=$||"",this.variadic=!1,this.parseArg=void 0,this.defaultValue=void 0,this.defaultValueDescription=void 0,this.argChoices=void 0,U[0]){case"<":this.required=!0,this._name=U.slice(1,-1);break;case"[":this.required=!1,this._name=U.slice(1,-1);break;default:this.required=!0,this._name=U;break}if(this._name.endsWith("..."))this.variadic=!0,this._name=this._name.slice(0,-3)}name(){return this._name}_collectValue(U,$){if($===this.defaultValue||!Array.isArray($))return[U];return $.push(U),$}default(U,$){return this.defaultValue=U,this.defaultValueDescription=$,this}argParser(U){return this.parseArg=U,this}choices(U){return this.argChoices=U.slice(),this.parseArg=($,q)=>{if(!this.argChoices.includes($))throw new _$(`Allowed choices are ${this.argChoices.join(", ")}.`);if(this.variadic)return this._collectValue($,q);return $},this}argRequired(){return this.required=!0,this}argOptional(){return this.required=!1,this}}function M$(U){let $=U.name()+(U.variadic===!0?"...":"");return U.required?"<"+$+">":"["+$+"]"}$0.Argument=O0;$0.humanReadableArgName=M$});var J0=VU((q0)=>{var{humanReadableArgName:w$}=mU();class E0{constructor(){this.helpWidth=void 0,this.minWidthToWrap=40,this.sortSubcommands=!1,this.sortOptions=!1,this.showGlobalOptions=!1}prepareContext(U){this.helpWidth=this.helpWidth??U.helpWidth??80}visibleCommands(U){let $=U.commands.filter((J)=>!J._hidden),q=U._getHelpCommand();if(q&&!q._hidden)$.push(q);if(this.sortSubcommands)$.sort((J,Z)=>{return J.name().localeCompare(Z.name())});return $}compareOptions(U,$){let q=(J)=>{return J.short?J.short.replace(/^-/,""):J.long.replace(/^--/,"")};return q(U).localeCompare(q($))}visibleOptions(U){let $=U.options.filter((J)=>!J.hidden),q=U._getHelpOption();if(q&&!q.hidden){let J=q.short&&U._findOption(q.short),Z=q.long&&U._findOption(q.long);if(!J&&!Z)$.push(q);else if(q.long&&!Z)$.push(U.createOption(q.long,q.description));else if(q.short&&!J)$.push(U.createOption(q.short,q.description))}if(this.sortOptions)$.sort(this.compareOptions);return $}visibleGlobalOptions(U){if(!this.showGlobalOptions)return[];let $=[];for(let q=U.parent;q;q=q.parent){let J=q.options.filter((Z)=>!Z.hidden);$.push(...J)}if(this.sortOptions)$.sort(this.compareOptions);return $}visibleArguments(U){if(U._argsDescription)U.registeredArguments.forEach(($)=>{$.description=$.description||U._argsDescription[$.name()]||""});if(U.registeredArguments.find(($)=>$.description))return U.registeredArguments;return[]}subcommandTerm(U){let $=U.registeredArguments.map((q)=>w$(q)).join(" ");return U._name+(U._aliases[0]?"|"+U._aliases[0]:"")+(U.options.length?" [options]":"")+($?" "+$:"")}optionTerm(U){return U.flags}argumentTerm(U){return U.name()}longestSubcommandTermLength(U,$){return $.visibleCommands(U).reduce((q,J)=>{return Math.max(q,this.displayWidth($.styleSubcommandTerm($.subcommandTerm(J))))},0)}longestOptionTermLength(U,$){return $.visibleOptions(U).reduce((q,J)=>{return Math.max(q,this.displayWidth($.styleOptionTerm($.optionTerm(J))))},0)}longestGlobalOptionTermLength(U,$){return $.visibleGlobalOptions(U).reduce((q,J)=>{return Math.max(q,this.displayWidth($.styleOptionTerm($.optionTerm(J))))},0)}longestArgumentTermLength(U,$){return $.visibleArguments(U).reduce((q,J)=>{return Math.max(q,this.displayWidth($.styleArgumentTerm($.argumentTerm(J))))},0)}commandUsage(U){let $=U._name;if(U._aliases[0])$=$+"|"+U._aliases[0];let q="";for(let J=U.parent;J;J=J.parent)q=J.name()+" "+q;return q+$+" "+U.usage()}commandDescription(U){return U.description()}subcommandDescription(U){return U.summary()||U.description()}optionDescription(U){let $=[];if(U.argChoices)$.push(`choices: ${U.argChoices.map((q)=>JSON.stringify(q)).join(", ")}`);if(U.defaultValue!==void 0){if(U.required||U.optional||U.isBoolean()&&typeof U.defaultValue==="boolean")$.push(`default: ${U.defaultValueDescription||JSON.stringify(U.defaultValue)}`)}if(U.presetArg!==void 0&&U.optional)$.push(`preset: ${JSON.stringify(U.presetArg)}`);if(U.envVar!==void 0)$.push(`env: ${U.envVar}`);if($.length>0){let q=`(${$.join(", ")})`;if(U.description)return`${U.description} ${q}`;return q}return U.description}argumentDescription(U){let $=[];if(U.argChoices)$.push(`choices: ${U.argChoices.map((q)=>JSON.stringify(q)).join(", ")}`);if(U.defaultValue!==void 0)$.push(`default: ${U.defaultValueDescription||JSON.stringify(U.defaultValue)}`);if($.length>0){let q=`(${$.join(", ")})`;if(U.description)return`${U.description} ${q}`;return q}return U.description}formatItemList(U,$,q){if($.length===0)return[];return[q.styleTitle(U),...$,""]}groupItems(U,$,q){let J=new Map;return U.forEach((Z)=>{let Y=q(Z);if(!J.has(Y))J.set(Y,[])}),$.forEach((Z)=>{let Y=q(Z);if(!J.has(Y))J.set(Y,[]);J.get(Y).push(Z)}),J}formatHelp(U,$){let q=$.padWidth(U,$),J=$.helpWidth??80;function Z(T,K){return $.formatItem(T,q,K,$)}let Y=[`${$.styleTitle("Usage:")} ${$.styleUsage($.commandUsage(U))}`,""],Q=$.commandDescription(U);if(Q.length>0)Y=Y.concat([$.boxWrap($.styleCommandDescription(Q),J),""]);let X=$.visibleArguments(U).map((T)=>{return Z($.styleArgumentTerm($.argumentTerm(T)),$.styleArgumentDescription($.argumentDescription(T)))});if(Y=Y.concat(this.formatItemList("Arguments:",X,$)),this.groupItems(U.options,$.visibleOptions(U),(T)=>T.helpGroupHeading??"Options:").forEach((T,K)=>{let H=T.map((R)=>{return Z($.styleOptionTerm($.optionTerm(R)),$.styleOptionDescription($.optionDescription(R)))});Y=Y.concat(this.formatItemList(K,H,$))}),$.showGlobalOptions){let T=$.visibleGlobalOptions(U).map((K)=>{return Z($.styleOptionTerm($.optionTerm(K)),$.styleOptionDescription($.optionDescription(K)))});Y=Y.concat(this.formatItemList("Global Options:",T,$))}return this.groupItems(U.commands,$.visibleCommands(U),(T)=>T.helpGroup()||"Commands:").forEach((T,K)=>{let H=T.map((R)=>{return Z($.styleSubcommandTerm($.subcommandTerm(R)),$.styleSubcommandDescription($.subcommandDescription(R)))});Y=Y.concat(this.formatItemList(K,H,$))}),Y.join(`
`)}displayWidth(U){return A0(U).length}styleTitle(U){return U}styleUsage(U){return U.split(" ").map(($)=>{if($==="[options]")return this.styleOptionText($);if($==="[command]")return this.styleSubcommandText($);if($[0]==="["||$[0]==="<")return this.styleArgumentText($);return this.styleCommandText($)}).join(" ")}styleCommandDescription(U){return this.styleDescriptionText(U)}styleOptionDescription(U){return this.styleDescriptionText(U)}styleSubcommandDescription(U){return this.styleDescriptionText(U)}styleArgumentDescription(U){return this.styleDescriptionText(U)}styleDescriptionText(U){return U}styleOptionTerm(U){return this.styleOptionText(U)}styleSubcommandTerm(U){return U.split(" ").map(($)=>{if($==="[options]")return this.styleOptionText($);if($[0]==="["||$[0]==="<")return this.styleArgumentText($);return this.styleSubcommandText($)}).join(" ")}styleArgumentTerm(U){return this.styleArgumentText(U)}styleOptionText(U){return U}styleArgumentText(U){return U}styleSubcommandText(U){return U}styleCommandText(U){return U}padWidth(U,$){return Math.max($.longestOptionTermLength(U,$),$.longestGlobalOptionTermLength(U,$),$.longestSubcommandTermLength(U,$),$.longestArgumentTermLength(U,$))}preformatted(U){return/\n[^\S\r\n]/.test(U)}formatItem(U,$,q,J){let Y=" ".repeat(2);if(!q)return Y+U;let Q=U.padEnd($+U.length-J.displayWidth(U)),X=2,G=(this.helpWidth??80)-$-X-2,T;if(G<this.minWidthToWrap||J.preformatted(q))T=q;else T=J.boxWrap(q,G).replace(/\n/g,`
`+" ".repeat($+X));return Y+Q+" ".repeat(X)+T.replace(/\n/g,`
${Y}`)}boxWrap(U,$){if($<this.minWidthToWrap)return U;let q=U.split(/\r\n|\n/),J=/[\s]*[^\s]+/g,Z=[];return q.forEach((Y)=>{let Q=Y.match(J);if(Q===null){Z.push("");return}let X=[Q.shift()],z=this.displayWidth(X[0]);Q.forEach((G)=>{let T=this.displayWidth(G);if(z+T<=$){X.push(G),z+=T;return}Z.push(X.join(""));let K=G.trimStart();X=[K],z=this.displayWidth(K)}),Z.push(X.join(""))}),Z.join(`
`)}}function A0(U){let $=/\x1b\[\d*(;\d*)*m/g;return U.replace($,"")}q0.Help=E0;q0.stripColor=A0});var Y0=VU((Z0)=>{var{InvalidArgumentError:L$}=yU();class k0{constructor(U,$){this.flags=U,this.description=$||"",this.required=U.includes("<"),this.optional=U.includes("["),this.variadic=/\w\.\.\.[>\]]$/.test(U),this.mandatory=!1;let q=P$(U);if(this.short=q.shortFlag,this.long=q.longFlag,this.negate=!1,this.long)this.negate=this.long.startsWith("--no-");this.defaultValue=void 0,this.defaultValueDescription=void 0,this.presetArg=void 0,this.envVar=void 0,this.parseArg=void 0,this.hidden=!1,this.argChoices=void 0,this.conflictsWith=[],this.implied=void 0,this.helpGroupHeading=void 0}default(U,$){return this.defaultValue=U,this.defaultValueDescription=$,this}preset(U){return this.presetArg=U,this}conflicts(U){return this.conflictsWith=this.conflictsWith.concat(U),this}implies(U){let $=U;if(typeof U==="string")$={[U]:!0};return this.implied=Object.assign(this.implied||{},$),this}env(U){return this.envVar=U,this}argParser(U){return this.parseArg=U,this}makeOptionMandatory(U=!0){return this.mandatory=!!U,this}hideHelp(U=!0){return this.hidden=!!U,this}_collectValue(U,$){if($===this.defaultValue||!Array.isArray($))return[U];return $.push(U),$}choices(U){return this.argChoices=U.slice(),this.parseArg=($,q)=>{if(!this.argChoices.includes($))throw new L$(`Allowed choices are ${this.argChoices.join(", ")}.`);if(this.variadic)return this._collectValue($,q);return $},this}name(){if(this.long)return this.long.replace(/^--/,"");return this.short.replace(/^-/,"")}attributeName(){if(this.negate)return C0(this.name().replace(/^no-/,""));return C0(this.name())}helpGroup(U){return this.helpGroupHeading=U,this}is(U){return this.short===U||this.long===U}isBoolean(){return!this.required&&!this.optional&&!this.negate}}class v0{constructor(U){this.positiveOptions=new Map,this.negativeOptions=new Map,this.dualOptions=new Set,U.forEach(($)=>{if($.negate)this.negativeOptions.set($.attributeName(),$);else this.positiveOptions.set($.attributeName(),$)}),this.negativeOptions.forEach(($,q)=>{if(this.positiveOptions.has(q))this.dualOptions.add(q)})}valueFromOption(U,$){let q=$.attributeName();if(!this.dualOptions.has(q))return!0;let J=this.negativeOptions.get(q).presetArg,Z=J!==void 0?J:!1;return $.negate===(Z===U)}}function C0(U){return U.split("-").reduce(($,q)=>{return $+q[0].toUpperCase()+q.slice(1)})}function P$(U){let $,q,J=/^-[^-]$/,Z=/^--[^-]/,Y=U.split(/[ |,]+/).concat("guard");if(J.test(Y[0]))$=Y.shift();if(Z.test(Y[0]))q=Y.shift();if(!$&&J.test(Y[0]))$=Y.shift();if(!$&&Z.test(Y[0]))$=q,q=Y.shift();if(Y[0].startsWith("-")){let Q=Y[0],X=`option creation failed due to '${Q}' in option flags '${U}'`;if(/^-[^-][^-]/.test(Q))throw Error(`${X}
- a short flag is a single dash and a single character
  - either use a single dash and a single character (for a short flag)
  - or use a double dash for a long option (and can have two, like '--ws, --workspace')`);if(J.test(Q))throw Error(`${X}
- too many short flags`);if(Z.test(Q))throw Error(`${X}
- too many long flags`);throw Error(`${X}
- unrecognised flag format`)}if($===void 0&&q===void 0)throw Error(`option creation failed due to no flags found in '${U}'.`);return{shortFlag:$,longFlag:q}}Z0.Option=k0;Z0.DualOptions=v0});var f0=VU((y0)=>{function D$(U,$){if(Math.abs(U.length-$.length)>3)return Math.max(U.length,$.length);let q=[];for(let J=0;J<=U.length;J++)q[J]=[J];for(let J=0;J<=$.length;J++)q[0][J]=J;for(let J=1;J<=$.length;J++)for(let Z=1;Z<=U.length;Z++){let Y=1;if(U[Z-1]===$[J-1])Y=0;else Y=1;if(q[Z][J]=Math.min(q[Z-1][J]+1,q[Z][J-1]+1,q[Z-1][J-1]+Y),Z>1&&J>1&&U[Z-1]===$[J-2]&&U[Z-2]===$[J-1])q[Z][J]=Math.min(q[Z][J],q[Z-2][J-2]+1)}return q[U.length][$.length]}function O$(U,$){if(!$||$.length===0)return"";$=Array.from(new Set($));let q=U.startsWith("--");if(q)U=U.slice(2),$=$.map((Q)=>Q.slice(2));let J=[],Z=3,Y=0.4;if($.forEach((Q)=>{if(Q.length<=1)return;let X=D$(U,Q),z=Math.max(U.length,Q.length);if((z-X)/z>Y){if(X<Z)Z=X,J=[Q];else if(X===Z)J.push(Q)}}),J.sort((Q,X)=>Q.localeCompare(X)),q)J=J.map((Q)=>`--${Q}`);if(J.length>1)return`
(Did you mean one of ${J.join(", ")}?)`;if(J.length===1)return`
(Did you mean ${J[0]}?)`;return""}y0.suggestSimilar=O$});var h0=VU((T0)=>{var E$=require("node:events").EventEmitter,Q0=require("node:child_process"),ZU=require("node:path"),uU=require("node:fs"),M=require("node:process"),{Argument:A$,humanReadableArgName:C$}=mU(),{CommanderError:X0}=yU(),{Help:k$,stripColor:v$}=J0(),{Option:b0,DualOptions:y$}=Y0(),{suggestSimilar:x0}=f0();class G0 extends E${constructor(U){super();this.commands=[],this.options=[],this.parent=null,this._allowUnknownOption=!1,this._allowExcessArguments=!1,this.registeredArguments=[],this._args=this.registeredArguments,this.args=[],this.rawArgs=[],this.processedArgs=[],this._scriptPath=null,this._name=U||"",this._optionValues={},this._optionValueSources={},this._storeOptionsAsProperties=!1,this._actionHandler=null,this._executableHandler=!1,this._executableFile=null,this._executableDir=null,this._defaultCommandName=null,this._exitCallback=null,this._aliases=[],this._combineFlagAndOptionalValue=!0,this._description="",this._summary="",this._argsDescription=void 0,this._enablePositionalOptions=!1,this._passThroughOptions=!1,this._lifeCycleHooks={},this._showHelpAfterError=!1,this._showSuggestionAfterError=!0,this._savedState=null,this._outputConfiguration={writeOut:($)=>M.stdout.write($),writeErr:($)=>M.stderr.write($),outputError:($,q)=>q($),getOutHelpWidth:()=>M.stdout.isTTY?M.stdout.columns:void 0,getErrHelpWidth:()=>M.stderr.isTTY?M.stderr.columns:void 0,getOutHasColors:()=>z0()??(M.stdout.isTTY&&M.stdout.hasColors?.()),getErrHasColors:()=>z0()??(M.stderr.isTTY&&M.stderr.hasColors?.()),stripColor:($)=>v$($)},this._hidden=!1,this._helpOption=void 0,this._addImplicitHelpCommand=void 0,this._helpCommand=void 0,this._helpConfiguration={},this._helpGroupHeading=void 0,this._defaultCommandGroup=void 0,this._defaultOptionGroup=void 0}copyInheritedSettings(U){return this._outputConfiguration=U._outputConfiguration,this._helpOption=U._helpOption,this._helpCommand=U._helpCommand,this._helpConfiguration=U._helpConfiguration,this._exitCallback=U._exitCallback,this._storeOptionsAsProperties=U._storeOptionsAsProperties,this._combineFlagAndOptionalValue=U._combineFlagAndOptionalValue,this._allowExcessArguments=U._allowExcessArguments,this._enablePositionalOptions=U._enablePositionalOptions,this._showHelpAfterError=U._showHelpAfterError,this._showSuggestionAfterError=U._showSuggestionAfterError,this}_getCommandAndAncestors(){let U=[];for(let $=this;$;$=$.parent)U.push($);return U}command(U,$,q){let J=$,Z=q;if(typeof J==="object"&&J!==null)Z=J,J=null;Z=Z||{};let[,Y,Q]=U.match(/([^ ]+) *(.*)/),X=this.createCommand(Y);if(J)X.description(J),X._executableHandler=!0;if(Z.isDefault)this._defaultCommandName=X._name;if(X._hidden=!!(Z.noHelp||Z.hidden),X._executableFile=Z.executableFile||null,Q)X.arguments(Q);if(this._registerCommand(X),X.parent=this,X.copyInheritedSettings(this),J)return this;return X}createCommand(U){return new G0(U)}createHelp(){return Object.assign(new k$,this.configureHelp())}configureHelp(U){if(U===void 0)return this._helpConfiguration;return this._helpConfiguration=U,this}configureOutput(U){if(U===void 0)return this._outputConfiguration;return this._outputConfiguration={...this._outputConfiguration,...U},this}showHelpAfterError(U=!0){if(typeof U!=="string")U=!!U;return this._showHelpAfterError=U,this}showSuggestionAfterError(U=!0){return this._showSuggestionAfterError=!!U,this}addCommand(U,$){if(!U._name)throw Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);if($=$||{},$.isDefault)this._defaultCommandName=U._name;if($.noHelp||$.hidden)U._hidden=!0;return this._registerCommand(U),U.parent=this,U._checkForBrokenPassThrough(),this}createArgument(U,$){return new A$(U,$)}argument(U,$,q,J){let Z=this.createArgument(U,$);if(typeof q==="function")Z.default(J).argParser(q);else Z.default(q);return this.addArgument(Z),this}arguments(U){return U.trim().split(/ +/).forEach(($)=>{this.argument($)}),this}addArgument(U){let $=this.registeredArguments.slice(-1)[0];if($?.variadic)throw Error(`only the last argument can be variadic '${$.name()}'`);if(U.required&&U.defaultValue!==void 0&&U.parseArg===void 0)throw Error(`a default value for a required argument is never used: '${U.name()}'`);return this.registeredArguments.push(U),this}helpCommand(U,$){if(typeof U==="boolean"){if(this._addImplicitHelpCommand=U,U&&this._defaultCommandGroup)this._initCommandGroup(this._getHelpCommand());return this}let q=U??"help [command]",[,J,Z]=q.match(/([^ ]+) *(.*)/),Y=$??"display help for command",Q=this.createCommand(J);if(Q.helpOption(!1),Z)Q.arguments(Z);if(Y)Q.description(Y);if(this._addImplicitHelpCommand=!0,this._helpCommand=Q,U||$)this._initCommandGroup(Q);return this}addHelpCommand(U,$){if(typeof U!=="object")return this.helpCommand(U,$),this;return this._addImplicitHelpCommand=!0,this._helpCommand=U,this._initCommandGroup(U),this}_getHelpCommand(){if(this._addImplicitHelpCommand??(this.commands.length&&!this._actionHandler&&!this._findCommand("help"))){if(this._helpCommand===void 0)this.helpCommand(void 0,void 0);return this._helpCommand}return null}hook(U,$){let q=["preSubcommand","preAction","postAction"];if(!q.includes(U))throw Error(`Unexpected value for event passed to hook : '${U}'.
Expecting one of '${q.join("', '")}'`);if(this._lifeCycleHooks[U])this._lifeCycleHooks[U].push($);else this._lifeCycleHooks[U]=[$];return this}exitOverride(U){if(U)this._exitCallback=U;else this._exitCallback=($)=>{if($.code!=="commander.executeSubCommandAsync")throw $};return this}_exit(U,$,q){if(this._exitCallback)this._exitCallback(new X0(U,$,q));M.exit(U)}action(U){let $=(q)=>{let J=this.registeredArguments.length,Z=q.slice(0,J);if(this._storeOptionsAsProperties)Z[J]=this;else Z[J]=this.opts();return Z.push(this),U.apply(this,Z)};return this._actionHandler=$,this}createOption(U,$){return new b0(U,$)}_callParseArg(U,$,q,J){try{return U.parseArg($,q)}catch(Z){if(Z.code==="commander.invalidArgument"){let Y=`${J} ${Z.message}`;this.error(Y,{exitCode:Z.exitCode,code:Z.code})}throw Z}}_registerOption(U){let $=U.short&&this._findOption(U.short)||U.long&&this._findOption(U.long);if($){let q=U.long&&this._findOption(U.long)?U.long:U.short;throw Error(`Cannot add option '${U.flags}'${this._name&&` to command '${this._name}'`} due to conflicting flag '${q}'
-  already used by option '${$.flags}'`)}this._initOptionGroup(U),this.options.push(U)}_registerCommand(U){let $=(J)=>{return[J.name()].concat(J.aliases())},q=$(U).find((J)=>this._findCommand(J));if(q){let J=$(this._findCommand(q)).join("|"),Z=$(U).join("|");throw Error(`cannot add command '${Z}' as already have command '${J}'`)}this._initCommandGroup(U),this.commands.push(U)}addOption(U){this._registerOption(U);let $=U.name(),q=U.attributeName();if(U.negate){let Z=U.long.replace(/^--no-/,"--");if(!this._findOption(Z))this.setOptionValueWithSource(q,U.defaultValue===void 0?!0:U.defaultValue,"default")}else if(U.defaultValue!==void 0)this.setOptionValueWithSource(q,U.defaultValue,"default");let J=(Z,Y,Q)=>{if(Z==null&&U.presetArg!==void 0)Z=U.presetArg;let X=this.getOptionValue(q);if(Z!==null&&U.parseArg)Z=this._callParseArg(U,Z,X,Y);else if(Z!==null&&U.variadic)Z=U._collectValue(Z,X);if(Z==null)if(U.negate)Z=!1;else if(U.isBoolean()||U.optional)Z=!0;else Z="";this.setOptionValueWithSource(q,Z,Q)};if(this.on("option:"+$,(Z)=>{let Y=`error: option '${U.flags}' argument '${Z}' is invalid.`;J(Z,Y,"cli")}),U.envVar)this.on("optionEnv:"+$,(Z)=>{let Y=`error: option '${U.flags}' value '${Z}' from env '${U.envVar}' is invalid.`;J(Z,Y,"env")});return this}_optionEx(U,$,q,J,Z){if(typeof $==="object"&&$ instanceof b0)throw Error("To add an Option object use addOption() instead of option() or requiredOption()");let Y=this.createOption($,q);if(Y.makeOptionMandatory(!!U.mandatory),typeof J==="function")Y.default(Z).argParser(J);else if(J instanceof RegExp){let Q=J;J=(X,z)=>{let G=Q.exec(X);return G?G[0]:z},Y.default(Z).argParser(J)}else Y.default(J);return this.addOption(Y)}option(U,$,q,J){return this._optionEx({},U,$,q,J)}requiredOption(U,$,q,J){return this._optionEx({mandatory:!0},U,$,q,J)}combineFlagAndOptionalValue(U=!0){return this._combineFlagAndOptionalValue=!!U,this}allowUnknownOption(U=!0){return this._allowUnknownOption=!!U,this}allowExcessArguments(U=!0){return this._allowExcessArguments=!!U,this}enablePositionalOptions(U=!0){return this._enablePositionalOptions=!!U,this}passThroughOptions(U=!0){return this._passThroughOptions=!!U,this._checkForBrokenPassThrough(),this}_checkForBrokenPassThrough(){if(this.parent&&this._passThroughOptions&&!this.parent._enablePositionalOptions)throw Error(`passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`)}storeOptionsAsProperties(U=!0){if(this.options.length)throw Error("call .storeOptionsAsProperties() before adding options");if(Object.keys(this._optionValues).length)throw Error("call .storeOptionsAsProperties() before setting option values");return this._storeOptionsAsProperties=!!U,this}getOptionValue(U){if(this._storeOptionsAsProperties)return this[U];return this._optionValues[U]}setOptionValue(U,$){return this.setOptionValueWithSource(U,$,void 0)}setOptionValueWithSource(U,$,q){if(this._storeOptionsAsProperties)this[U]=$;else this._optionValues[U]=$;return this._optionValueSources[U]=q,this}getOptionValueSource(U){return this._optionValueSources[U]}getOptionValueSourceWithGlobals(U){let $;return this._getCommandAndAncestors().forEach((q)=>{if(q.getOptionValueSource(U)!==void 0)$=q.getOptionValueSource(U)}),$}_prepareUserArgs(U,$){if(U!==void 0&&!Array.isArray(U))throw Error("first parameter to parse must be array or undefined");if($=$||{},U===void 0&&$.from===void 0){if(M.versions?.electron)$.from="electron";let J=M.execArgv??[];if(J.includes("-e")||J.includes("--eval")||J.includes("-p")||J.includes("--print"))$.from="eval"}if(U===void 0)U=M.argv;this.rawArgs=U.slice();let q;switch($.from){case void 0:case"node":this._scriptPath=U[1],q=U.slice(2);break;case"electron":if(M.defaultApp)this._scriptPath=U[1],q=U.slice(2);else q=U.slice(1);break;case"user":q=U.slice(0);break;case"eval":q=U.slice(1);break;default:throw Error(`unexpected parse option { from: '${$.from}' }`)}if(!this._name&&this._scriptPath)this.nameFromFilename(this._scriptPath);return this._name=this._name||"program",q}parse(U,$){this._prepareForParse();let q=this._prepareUserArgs(U,$);return this._parseCommand([],q),this}async parseAsync(U,$){this._prepareForParse();let q=this._prepareUserArgs(U,$);return await this._parseCommand([],q),this}_prepareForParse(){if(this._savedState===null)this.saveStateBeforeParse();else this.restoreStateBeforeParse()}saveStateBeforeParse(){this._savedState={_name:this._name,_optionValues:{...this._optionValues},_optionValueSources:{...this._optionValueSources}}}restoreStateBeforeParse(){if(this._storeOptionsAsProperties)throw Error(`Can not call parse again when storeOptionsAsProperties is true.
- either make a new Command for each call to parse, or stop storing options as properties`);this._name=this._savedState._name,this._scriptPath=null,this.rawArgs=[],this._optionValues={...this._savedState._optionValues},this._optionValueSources={...this._savedState._optionValueSources},this.args=[],this.processedArgs=[]}_checkForMissingExecutable(U,$,q){if(uU.existsSync(U))return;let J=$?`searched for local subcommand relative to directory '${$}'`:"no directory for search for local subcommand, use .executableDir() to supply a custom directory",Z=`'${U}' does not exist
 - if '${q}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${J}`;throw Error(Z)}_executeSubCommand(U,$){$=$.slice();let q=!1,J=[".js",".ts",".tsx",".mjs",".cjs"];function Z(G,T){let K=ZU.resolve(G,T);if(uU.existsSync(K))return K;if(J.includes(ZU.extname(T)))return;let H=J.find((R)=>uU.existsSync(`${K}${R}`));if(H)return`${K}${H}`;return}this._checkForMissingMandatoryOptions(),this._checkForConflictingOptions();let Y=U._executableFile||`${this._name}-${U._name}`,Q=this._executableDir||"";if(this._scriptPath){let G;try{G=uU.realpathSync(this._scriptPath)}catch{G=this._scriptPath}Q=ZU.resolve(ZU.dirname(G),Q)}if(Q){let G=Z(Q,Y);if(!G&&!U._executableFile&&this._scriptPath){let T=ZU.basename(this._scriptPath,ZU.extname(this._scriptPath));if(T!==this._name)G=Z(Q,`${T}-${U._name}`)}Y=G||Y}q=J.includes(ZU.extname(Y));let X;if(M.platform!=="win32")if(q)$.unshift(Y),$=g0(M.execArgv).concat($),X=Q0.spawn(M.argv[0],$,{stdio:"inherit"});else X=Q0.spawn(Y,$,{stdio:"inherit"});else this._checkForMissingExecutable(Y,Q,U._name),$.unshift(Y),$=g0(M.execArgv).concat($),X=Q0.spawn(M.execPath,$,{stdio:"inherit"});if(!X.killed)["SIGUSR1","SIGUSR2","SIGTERM","SIGINT","SIGHUP"].forEach((T)=>{M.on(T,()=>{if(X.killed===!1&&X.exitCode===null)X.kill(T)})});let z=this._exitCallback;X.on("close",(G)=>{if(G=G??1,!z)M.exit(G);else z(new X0(G,"commander.executeSubCommandAsync","(close)"))}),X.on("error",(G)=>{if(G.code==="ENOENT")this._checkForMissingExecutable(Y,Q,U._name);else if(G.code==="EACCES")throw Error(`'${Y}' not executable`);if(!z)M.exit(1);else{let T=new X0(1,"commander.executeSubCommandAsync","(error)");T.nestedError=G,z(T)}}),this.runningCommand=X}_dispatchSubcommand(U,$,q){let J=this._findCommand(U);if(!J)this.help({error:!0});J._prepareForParse();let Z;return Z=this._chainOrCallSubCommandHook(Z,J,"preSubcommand"),Z=this._chainOrCall(Z,()=>{if(J._executableHandler)this._executeSubCommand(J,$.concat(q));else return J._parseCommand($,q)}),Z}_dispatchHelpCommand(U){if(!U)this.help();let $=this._findCommand(U);if($&&!$._executableHandler)$.help();return this._dispatchSubcommand(U,[],[this._getHelpOption()?.long??this._getHelpOption()?.short??"--help"])}_checkNumberOfArguments(){if(this.registeredArguments.forEach((U,$)=>{if(U.required&&this.args[$]==null)this.missingArgument(U.name())}),this.registeredArguments.length>0&&this.registeredArguments[this.registeredArguments.length-1].variadic)return;if(this.args.length>this.registeredArguments.length)this._excessArguments(this.args)}_processArguments(){let U=(q,J,Z)=>{let Y=J;if(J!==null&&q.parseArg){let Q=`error: command-argument value '${J}' is invalid for argument '${q.name()}'.`;Y=this._callParseArg(q,J,Z,Q)}return Y};this._checkNumberOfArguments();let $=[];this.registeredArguments.forEach((q,J)=>{let Z=q.defaultValue;if(q.variadic){if(J<this.args.length){if(Z=this.args.slice(J),q.parseArg)Z=Z.reduce((Y,Q)=>{return U(q,Q,Y)},q.defaultValue)}else if(Z===void 0)Z=[]}else if(J<this.args.length){if(Z=this.args[J],q.parseArg)Z=U(q,Z,q.defaultValue)}$[J]=Z}),this.processedArgs=$}_chainOrCall(U,$){if(U?.then&&typeof U.then==="function")return U.then(()=>$());return $()}_chainOrCallHooks(U,$){let q=U,J=[];if(this._getCommandAndAncestors().reverse().filter((Z)=>Z._lifeCycleHooks[$]!==void 0).forEach((Z)=>{Z._lifeCycleHooks[$].forEach((Y)=>{J.push({hookedCommand:Z,callback:Y})})}),$==="postAction")J.reverse();return J.forEach((Z)=>{q=this._chainOrCall(q,()=>{return Z.callback(Z.hookedCommand,this)})}),q}_chainOrCallSubCommandHook(U,$,q){let J=U;if(this._lifeCycleHooks[q]!==void 0)this._lifeCycleHooks[q].forEach((Z)=>{J=this._chainOrCall(J,()=>{return Z(this,$)})});return J}_parseCommand(U,$){let q=this.parseOptions($);if(this._parseOptionsEnv(),this._parseOptionsImplied(),U=U.concat(q.operands),$=q.unknown,this.args=U.concat($),U&&this._findCommand(U[0]))return this._dispatchSubcommand(U[0],U.slice(1),$);if(this._getHelpCommand()&&U[0]===this._getHelpCommand().name())return this._dispatchHelpCommand(U[1]);if(this._defaultCommandName)return this._outputHelpIfRequested($),this._dispatchSubcommand(this._defaultCommandName,U,$);if(this.commands.length&&this.args.length===0&&!this._actionHandler&&!this._defaultCommandName)this.help({error:!0});this._outputHelpIfRequested(q.unknown),this._checkForMissingMandatoryOptions(),this._checkForConflictingOptions();let J=()=>{if(q.unknown.length>0)this.unknownOption(q.unknown[0])},Z=`command:${this.name()}`;if(this._actionHandler){J(),this._processArguments();let Y;if(Y=this._chainOrCallHooks(Y,"preAction"),Y=this._chainOrCall(Y,()=>this._actionHandler(this.processedArgs)),this.parent)Y=this._chainOrCall(Y,()=>{this.parent.emit(Z,U,$)});return Y=this._chainOrCallHooks(Y,"postAction"),Y}if(this.parent?.listenerCount(Z))J(),this._processArguments(),this.parent.emit(Z,U,$);else if(U.length){if(this._findCommand("*"))return this._dispatchSubcommand("*",U,$);if(this.listenerCount("command:*"))this.emit("command:*",U,$);else if(this.commands.length)this.unknownCommand();else J(),this._processArguments()}else if(this.commands.length)J(),this.help({error:!0});else J(),this._processArguments()}_findCommand(U){if(!U)return;return this.commands.find(($)=>$._name===U||$._aliases.includes(U))}_findOption(U){return this.options.find(($)=>$.is(U))}_checkForMissingMandatoryOptions(){this._getCommandAndAncestors().forEach((U)=>{U.options.forEach(($)=>{if($.mandatory&&U.getOptionValue($.attributeName())===void 0)U.missingMandatoryOptionValue($)})})}_checkForConflictingLocalOptions(){let U=this.options.filter((q)=>{let J=q.attributeName();if(this.getOptionValue(J)===void 0)return!1;return this.getOptionValueSource(J)!=="default"});U.filter((q)=>q.conflictsWith.length>0).forEach((q)=>{let J=U.find((Z)=>q.conflictsWith.includes(Z.attributeName()));if(J)this._conflictingOption(q,J)})}_checkForConflictingOptions(){this._getCommandAndAncestors().forEach((U)=>{U._checkForConflictingLocalOptions()})}parseOptions(U){let $=[],q=[],J=$;function Z(G){return G.length>1&&G[0]==="-"}let Y=(G)=>{if(!/^-\d*\.?\d+(e[+-]?\d+)?$/.test(G))return!1;return!this._getCommandAndAncestors().some((T)=>T.options.map((K)=>K.short).some((K)=>/^-\d$/.test(K)))},Q=null,X=null,z=0;while(z<U.length||X){let G=X??U[z++];if(X=null,G==="--"){if(J===q)J.push(G);J.push(...U.slice(z));break}if(Q&&(!Z(G)||Y(G))){this.emit(`option:${Q.name()}`,G);continue}if(Q=null,Z(G)){let T=this._findOption(G);if(T){if(T.required){let K=U[z++];if(K===void 0)this.optionMissingArgument(T);this.emit(`option:${T.name()}`,K)}else if(T.optional){let K=null;if(z<U.length&&(!Z(U[z])||Y(U[z])))K=U[z++];this.emit(`option:${T.name()}`,K)}else this.emit(`option:${T.name()}`);Q=T.variadic?T:null;continue}}if(G.length>2&&G[0]==="-"&&G[1]!=="-"){let T=this._findOption(`-${G[1]}`);if(T){if(T.required||T.optional&&this._combineFlagAndOptionalValue)this.emit(`option:${T.name()}`,G.slice(2));else this.emit(`option:${T.name()}`),X=`-${G.slice(2)}`;continue}}if(/^--[^=]+=/.test(G)){let T=G.indexOf("="),K=this._findOption(G.slice(0,T));if(K&&(K.required||K.optional)){this.emit(`option:${K.name()}`,G.slice(T+1));continue}}if(J===$&&Z(G)&&!(this.commands.length===0&&Y(G)))J=q;if((this._enablePositionalOptions||this._passThroughOptions)&&$.length===0&&q.length===0){if(this._findCommand(G)){$.push(G),q.push(...U.slice(z));break}else if(this._getHelpCommand()&&G===this._getHelpCommand().name()){$.push(G,...U.slice(z));break}else if(this._defaultCommandName){q.push(G,...U.slice(z));break}}if(this._passThroughOptions){J.push(G,...U.slice(z));break}J.push(G)}return{operands:$,unknown:q}}opts(){if(this._storeOptionsAsProperties){let U={},$=this.options.length;for(let q=0;q<$;q++){let J=this.options[q].attributeName();U[J]=J===this._versionOptionName?this._version:this[J]}return U}return this._optionValues}optsWithGlobals(){return this._getCommandAndAncestors().reduce((U,$)=>Object.assign(U,$.opts()),{})}error(U,$){if(this._outputConfiguration.outputError(`${U}
`,this._outputConfiguration.writeErr),typeof this._showHelpAfterError==="string")this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`);else if(this._showHelpAfterError)this._outputConfiguration.writeErr(`
`),this.outputHelp({error:!0});let q=$||{},J=q.exitCode||1,Z=q.code||"commander.error";this._exit(J,Z,U)}_parseOptionsEnv(){this.options.forEach((U)=>{if(U.envVar&&U.envVar in M.env){let $=U.attributeName();if(this.getOptionValue($)===void 0||["default","config","env"].includes(this.getOptionValueSource($)))if(U.required||U.optional)this.emit(`optionEnv:${U.name()}`,M.env[U.envVar]);else this.emit(`optionEnv:${U.name()}`)}})}_parseOptionsImplied(){let U=new y$(this.options),$=(q)=>{return this.getOptionValue(q)!==void 0&&!["default","implied"].includes(this.getOptionValueSource(q))};this.options.filter((q)=>q.implied!==void 0&&$(q.attributeName())&&U.valueFromOption(this.getOptionValue(q.attributeName()),q)).forEach((q)=>{Object.keys(q.implied).filter((J)=>!$(J)).forEach((J)=>{this.setOptionValueWithSource(J,q.implied[J],"implied")})})}missingArgument(U){let $=`error: missing required argument '${U}'`;this.error($,{code:"commander.missingArgument"})}optionMissingArgument(U){let $=`error: option '${U.flags}' argument missing`;this.error($,{code:"commander.optionMissingArgument"})}missingMandatoryOptionValue(U){let $=`error: required option '${U.flags}' not specified`;this.error($,{code:"commander.missingMandatoryOptionValue"})}_conflictingOption(U,$){let q=(Y)=>{let Q=Y.attributeName(),X=this.getOptionValue(Q),z=this.options.find((T)=>T.negate&&Q===T.attributeName()),G=this.options.find((T)=>!T.negate&&Q===T.attributeName());if(z&&(z.presetArg===void 0&&X===!1||z.presetArg!==void 0&&X===z.presetArg))return z;return G||Y},J=(Y)=>{let Q=q(Y),X=Q.attributeName();if(this.getOptionValueSource(X)==="env")return`environment variable '${Q.envVar}'`;return`option '${Q.flags}'`},Z=`error: ${J(U)} cannot be used with ${J($)}`;this.error(Z,{code:"commander.conflictingOption"})}unknownOption(U){if(this._allowUnknownOption)return;let $="";if(U.startsWith("--")&&this._showSuggestionAfterError){let J=[],Z=this;do{let Y=Z.createHelp().visibleOptions(Z).filter((Q)=>Q.long).map((Q)=>Q.long);J=J.concat(Y),Z=Z.parent}while(Z&&!Z._enablePositionalOptions);$=x0(U,J)}let q=`error: unknown option '${U}'${$}`;this.error(q,{code:"commander.unknownOption"})}_excessArguments(U){if(this._allowExcessArguments)return;let $=this.registeredArguments.length,q=$===1?"":"s",Z=`error: too many arguments${this.parent?` for '${this.name()}'`:""}. Expected ${$} argument${q} but got ${U.length}.`;this.error(Z,{code:"commander.excessArguments"})}unknownCommand(){let U=this.args[0],$="";if(this._showSuggestionAfterError){let J=[];this.createHelp().visibleCommands(this).forEach((Z)=>{if(J.push(Z.name()),Z.alias())J.push(Z.alias())}),$=x0(U,J)}let q=`error: unknown command '${U}'${$}`;this.error(q,{code:"commander.unknownCommand"})}version(U,$,q){if(U===void 0)return this._version;this._version=U,$=$||"-V, --version",q=q||"output the version number";let J=this.createOption($,q);return this._versionOptionName=J.attributeName(),this._registerOption(J),this.on("option:"+J.name(),()=>{this._outputConfiguration.writeOut(`${U}
`),this._exit(0,"commander.version",U)}),this}description(U,$){if(U===void 0&&$===void 0)return this._description;if(this._description=U,$)this._argsDescription=$;return this}summary(U){if(U===void 0)return this._summary;return this._summary=U,this}alias(U){if(U===void 0)return this._aliases[0];let $=this;if(this.commands.length!==0&&this.commands[this.commands.length-1]._executableHandler)$=this.commands[this.commands.length-1];if(U===$._name)throw Error("Command alias can't be the same as its name");let q=this.parent?._findCommand(U);if(q){let J=[q.name()].concat(q.aliases()).join("|");throw Error(`cannot add alias '${U}' to command '${this.name()}' as already have command '${J}'`)}return $._aliases.push(U),this}aliases(U){if(U===void 0)return this._aliases;return U.forEach(($)=>this.alias($)),this}usage(U){if(U===void 0){if(this._usage)return this._usage;let $=this.registeredArguments.map((q)=>{return C$(q)});return[].concat(this.options.length||this._helpOption!==null?"[options]":[],this.commands.length?"[command]":[],this.registeredArguments.length?$:[]).join(" ")}return this._usage=U,this}name(U){if(U===void 0)return this._name;return this._name=U,this}helpGroup(U){if(U===void 0)return this._helpGroupHeading??"";return this._helpGroupHeading=U,this}commandsGroup(U){if(U===void 0)return this._defaultCommandGroup??"";return this._defaultCommandGroup=U,this}optionsGroup(U){if(U===void 0)return this._defaultOptionGroup??"";return this._defaultOptionGroup=U,this}_initOptionGroup(U){if(this._defaultOptionGroup&&!U.helpGroupHeading)U.helpGroup(this._defaultOptionGroup)}_initCommandGroup(U){if(this._defaultCommandGroup&&!U.helpGroup())U.helpGroup(this._defaultCommandGroup)}nameFromFilename(U){return this._name=ZU.basename(U,ZU.extname(U)),this}executableDir(U){if(U===void 0)return this._executableDir;return this._executableDir=U,this}helpInformation(U){let $=this.createHelp(),q=this._getOutputContext(U);$.prepareContext({error:q.error,helpWidth:q.helpWidth,outputHasColors:q.hasColors});let J=$.formatHelp(this,$);if(q.hasColors)return J;return this._outputConfiguration.stripColor(J)}_getOutputContext(U){U=U||{};let $=!!U.error,q,J,Z;if($)q=(Q)=>this._outputConfiguration.writeErr(Q),J=this._outputConfiguration.getErrHasColors(),Z=this._outputConfiguration.getErrHelpWidth();else q=(Q)=>this._outputConfiguration.writeOut(Q),J=this._outputConfiguration.getOutHasColors(),Z=this._outputConfiguration.getOutHelpWidth();return{error:$,write:(Q)=>{if(!J)Q=this._outputConfiguration.stripColor(Q);return q(Q)},hasColors:J,helpWidth:Z}}outputHelp(U){let $;if(typeof U==="function")$=U,U=void 0;let q=this._getOutputContext(U),J={error:q.error,write:q.write,command:this};this._getCommandAndAncestors().reverse().forEach((Y)=>Y.emit("beforeAllHelp",J)),this.emit("beforeHelp",J);let Z=this.helpInformation({error:q.error});if($){if(Z=$(Z),typeof Z!=="string"&&!Buffer.isBuffer(Z))throw Error("outputHelp callback must return a string or a Buffer")}if(q.write(Z),this._getHelpOption()?.long)this.emit(this._getHelpOption().long);this.emit("afterHelp",J),this._getCommandAndAncestors().forEach((Y)=>Y.emit("afterAllHelp",J))}helpOption(U,$){if(typeof U==="boolean"){if(U){if(this._helpOption===null)this._helpOption=void 0;if(this._defaultOptionGroup)this._initOptionGroup(this._getHelpOption())}else this._helpOption=null;return this}if(this._helpOption=this.createOption(U??"-h, --help",$??"display help for command"),U||$)this._initOptionGroup(this._helpOption);return this}_getHelpOption(){if(this._helpOption===void 0)this.helpOption(void 0,void 0);return this._helpOption}addHelpOption(U){return this._helpOption=U,this._initOptionGroup(U),this}help(U){this.outputHelp(U);let $=Number(M.exitCode??0);if($===0&&U&&typeof U!=="function"&&U.error)$=1;this._exit($,"commander.help","(outputHelp)")}addHelpText(U,$){let q=["beforeAll","before","after","afterAll"];if(!q.includes(U))throw Error(`Unexpected value for position to addHelpText.
Expecting one of '${q.join("', '")}'`);let J=`${U}Help`;return this.on(J,(Z)=>{let Y;if(typeof $==="function")Y=$({error:Z.error,command:Z.command});else Y=$;if(Y)Z.write(`${Y}
`)}),this}_outputHelpIfRequested(U){let $=this._getHelpOption();if($&&U.find((J)=>$.is(J)))this.outputHelp(),this._exit(0,"commander.helpDisplayed","(outputHelp)")}}function g0(U){return U.map(($)=>{if(!$.startsWith("--inspect"))return $;let q,J="127.0.0.1",Z="9229",Y;if((Y=$.match(/^(--inspect(-brk)?)$/))!==null)q=Y[1];else if((Y=$.match(/^(--inspect(-brk|-port)?)=([^:]+)$/))!==null)if(q=Y[1],/^\d+$/.test(Y[3]))Z=Y[3];else J=Y[3];else if((Y=$.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/))!==null)q=Y[1],J=Y[3],Z=Y[4];if(q&&Z!=="0")return`${q}=${J}:${parseInt(Z)+1}`;return $})}function z0(){if(M.env.NO_COLOR||M.env.FORCE_COLOR==="0"||M.env.FORCE_COLOR==="false")return!1;if(M.env.FORCE_COLOR||M.env.CLICOLOR_FORCE!==void 0)return!0;return}T0.Command=G0;T0.useColor=z0});var c0=VU((a)=>{var{Argument:m0}=mU(),{Command:K0}=h0(),{CommanderError:f$,InvalidArgumentError:u0}=yU(),{Help:b$}=J0(),{Option:l0}=Y0();a.program=new K0;a.createCommand=(U)=>new K0(U);a.createOption=(U,$)=>new l0(U,$);a.createArgument=(U,$)=>new m0(U,$);a.Command=K0;a.Option=l0;a.Argument=m0;a.Help=b$;a.CommanderError=f$;a.InvalidArgumentError=u0;a.InvalidOptionArgumentError=u0});var d0=NU(c0()),{program:Hq,createCommand:Rq,createArgument:Iq,createOption:Nq,CommanderError:Vq,InvalidArgumentError:Bq,InvalidOptionArgumentError:jq,Command:p0,Argument:Fq,Option:BU,Help:Sq}=d0.default;var r=require("node:fs"),FU=require("node:fs"),I=require("node:process");class t extends Error{constructor(U){super(U);Object.setPrototypeOf(this,new.target.prototype),this.name=new.target.name,this.stack=void 0}}class o extends t{}class PU extends t{}class W0 extends t{}class lU extends t{}class HU extends t{}class YU extends t{}class e extends t{}class g extends t{}class DU extends t{}function i0(){return typeof process<"u"&&typeof process.versions==="object"&&!0}function jU(...U){let $=U.reduce((Z,Y)=>Z+Y.byteLength,0),q=new Uint8Array($),J=0;for(let Z of U)q.set(Z,J),J+=Z.byteLength;return q}function OU(...U){try{let $=jU(...U);if(i0())return Buffer.from($).toString("base64");let q="";for(let J=0;J<$.length;J++)q+=String.fromCharCode($[J]);return btoa(q)}catch{throw new W0("Base64 Encoding Error")}}function fU(U){try{if(!/^[A-Za-z0-9+/]+={0,2}$/.test(U)||U.length%4!==0)throw Error("Invalid Base64");if(i0())return new Uint8Array(Buffer.from(U,"base64"));let $=atob(U),q=new Uint8Array($.length);for(let J=0;J<$.length;J++)q[J]=$.charCodeAt(J);return q}catch{throw new PU(`Invalid Base64: length=${U.length}, content='${U.slice(0,12)}…'`)}}function i(U){let $=U.value.length,q=Array($).fill("\x00").join("");U.value=q}function H0(U,$,q){if($<0||q<0||$+q>U)throw RangeError("read() slice exceeds data bounds")}var s0=require("fs");class R0{src;#U=null;constructor(U){this.src=U}get length(){if(this.src instanceof Uint8Array)return this.src.byteLength;if(this.src instanceof Blob)return this.src.size;return this.ensureUint8().byteLength}async read(U,$){if(H0(this.length,U,$),this.src instanceof Uint8Array)return this.src.slice(U,U+$);if(this.src instanceof Blob){let q=await this.src.slice(U,U+$).arrayBuffer();return new Uint8Array(q)}return this.ensureUint8().slice(U,U+$)}ensureUint8(){if(!this.#U)this.#U=fU(this.src);return this.#U}}class bU{fd;length;constructor(U,$){this.fd=U;this.length=$}static async open(U){let $=await s0.promises.open(U,"r"),q=await $.stat();return new bU($,q.size)}async read(U,$){H0(this.length,U,$);let q=Buffer.allocUnsafe($);return await this.fd.read(q,0,$,U),new Uint8Array(q)}async close(){await this.fd.close()}}class p{static byId=new Map;static register(U){if(this.byId.has(U.id))throw new lU(`Scheme ${U.id} already registered`);this.byId.set(U.id,U)}static get(U){let $=this.byId.get(U);if(!$)throw new lU(`Unknown scheme: ${U}`);return $}static get current(){return this.get(0)}}class QU{p;padding=null;headerAAD=new Uint8Array(0);padAADMode="auto";padAlign=8;allowLegacyAADFallback=!0;legacyFallbackPolicy="auto";tryEmptyAADOnLegacyFallback=!1;setLegacyAADFallback(U={}){if(U.enabled!==void 0)this.allowLegacyAADFallback=!!U.enabled;if(U.policy)this.legacyFallbackPolicy=U.policy;if(U.tryEmptyAAD!==void 0)this.tryEmptyAADOnLegacyFallback=!!U.tryEmptyAAD}static PAD_AAD_MAGIC=new Uint8Array([80,65,68,49]);static PAD_AAD_VER=1;constructor(U){this.p=U}setPaddingScheme(U){this.padding=U}setPaddingAADMode(U){this.padAADMode=U}setPaddingAlign(U){if(!Number.isInteger(U)||U<1||U>255)throw Error("padAlign must be 1..255");this.padAlign=U|0}setAAD(U){this.headerAAD=U&&U.byteLength?new Uint8Array(U):new Uint8Array(0)}async encryptChunk(U){let $=this.resolveMode(),q=U;if($==="require"){if(!this.padding)throw Error("Padding required but no scheme set");let Y=(Q)=>this.p.getRandomValues(new Uint8Array(Q));q=this.padding.pad(U,Y,this.padAlign)}let J=this.composeAAD($),Z=await this.encryptWithAAD(q,J);if(U.fill(0),q!==U)q.fill(0);return Z}async decryptChunk(U){let $=this.resolveMode(),q=this.composeAAD($);try{let J=await this.decryptWithAAD(U,q);return this.enforcePolicyAfterDecrypt(J,$)}catch(J){if(!this.allowLegacyAADFallback)throw J;let Z=[];if(this.headerAAD.length)Z.push(this.headerAAD);if(this.tryEmptyAADOnLegacyFallback)Z.push(new Uint8Array(0));let Y=J;for(let Q of Z)try{let X=await this.decryptWithAAD(U,Q),z=this.legacyFallbackPolicy==="auto"?"auto":this.legacyFallbackPolicy;return this.enforcePolicyAfterDecrypt(X,z)}catch(X){Y=X}throw Y}}enforcePolicyAfterDecrypt(U,$){if(!this.padding){if($==="require")throw new g("Expected padding but no scheme configured");return U}let{used:q,plain:J}=this.padding.tryUnpad(U);if($==="require"){if(!q)throw new g("Expected padding trailer not found");return new Uint8Array(J)}if($==="forbid"){if(q)throw new g("Padding forbidden by policy");return U}return q?new Uint8Array(J):U}resolveMode(){if(this.padAADMode==="auto")return this.padding?"require":"forbid";return this.padAADMode}buildPadAAD(U){let $=U==="require"?0:1,q=new Uint8Array(QU.PAD_AAD_MAGIC.length+1+1+1),J=0;return q.set(QU.PAD_AAD_MAGIC,J),J+=QU.PAD_AAD_MAGIC.length,q[J++]=QU.PAD_AAD_VER&255,q[J++]=$,q[J++]=this.padAlign&255,q}composeAAD(U){let $=this.buildPadAAD(U);if(!this.headerAAD.length)return $;let q=new Uint8Array(this.headerAAD.length+$.length);return q.set(this.headerAAD,0),q.set($,this.headerAAD.length),q}}class UU extends QU{static IV_LENGTH=12;static TAG_LENGTH=16;IV_LENGTH=UU.IV_LENGTH;TAG_LENGTH=UU.TAG_LENGTH;key=null;constructor(U){super(U)}async setKey(U){this.key=U}zeroKey(){this.key=null}async encryptWithAAD(U,$){let q=this.p.getRandomValues(new Uint8Array(UU.IV_LENGTH)),J={name:"AES-GCM",iv:q,additionalData:$},Z=await this.p.subtle.encrypt(J,this.requireKey(),U),Y=new Uint8Array(Z),Q=new Uint8Array(q.length+Y.length);return Q.set(q,0),Q.set(Y,q.length),Q}async decryptWithAAD(U,$){if(U.byteLength<UU.IV_LENGTH+UU.TAG_LENGTH)throw new g("Invalid ciphertext: too short.");let q=U.subarray(0,UU.IV_LENGTH),J=U.subarray(UU.IV_LENGTH),Z={name:"AES-GCM",iv:q,additionalData:$};try{let Y=await this.p.subtle.decrypt(Z,this.requireKey(),J);return new Uint8Array(Y)}catch{throw new g("Decryption failed: wrong passphrase or corrupted ciphertext")}}requireKey(){if(!this.key)throw Error("Encryption key not set");return this.key}}/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function x$(U){return U instanceof Uint8Array||ArrayBuffer.isView(U)&&U.constructor.name==="Uint8Array"}function cU(U){if(typeof U!=="boolean")throw Error(`boolean expected, not ${U}`)}function dU(U){if(!Number.isSafeInteger(U)||U<0)throw Error("positive integer expected, got "+U)}function u(U,$,q=""){let J=x$(U),Z=U?.length,Y=$!==void 0;if(!J||Y&&Z!==$){let Q=q&&`"${q}" `,X=Y?` of length ${$}`:"",z=J?`length=${Z}`:`type=${typeof U}`;throw Error(Q+"expected Uint8Array"+X+", got "+z)}return U}function I0(U,$=!0){if(U.destroyed)throw Error("Hash instance has been destroyed");if($&&U.finished)throw Error("Hash#digest() has already been called")}function n0(U,$){u(U,void 0,"output");let q=$.outputLen;if(U.length<q)throw Error("digestInto() expects output buffer of length at least "+q)}function XU(U){return new Uint32Array(U.buffer,U.byteOffset,Math.floor(U.byteLength/4))}function zU(...U){for(let $=0;$<U.length;$++)U[$].fill(0)}function g$(U){return new DataView(U.buffer,U.byteOffset,U.byteLength)}var h$=(()=>new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68)();function o0(U,$){if($==null||typeof $!=="object")throw Error("options must be defined");return Object.assign(U,$)}function a0(U,$){if(U.length!==$.length)return!1;let q=0;for(let J=0;J<U.length;J++)q|=U[J]^$[J];return q===0}var N0=(U,$)=>{function q(J,...Z){if(u(J,void 0,"key"),!h$)throw Error("Non little-endian hardware is not yet supported");if(U.nonceLength!==void 0){let T=Z[0];u(T,U.varSizeNonce?void 0:U.nonceLength,"nonce")}let Y=U.tagLength;if(Y&&Z[1]!==void 0)u(Z[1],void 0,"AAD");let Q=$(J,...Z),X=(T,K)=>{if(K!==void 0){if(T!==2)throw Error("cipher output not supported");u(K,void 0,"output")}},z=!1;return{encrypt(T,K){if(z)throw Error("cannot encrypt() twice with same key + nonce");return z=!0,u(T),X(Q.encrypt.length,K),Q.encrypt(T,K)},decrypt(T,K){if(u(T),Y&&T.length<Y)throw Error('"ciphertext" expected length bigger than tagLength='+Y);return X(Q.decrypt.length,K),Q.decrypt(T,K)}}}return Object.assign(q,U),q};function V0(U,$,q=!0){if($===void 0)return new Uint8Array(U);if($.length!==U)throw Error('"output" expected Uint8Array of length '+U+", got: "+$.length);if(q&&!m$($))throw Error("invalid output, must be aligned");return $}function r0(U,$,q){cU(q);let J=new Uint8Array(16),Z=g$(J);return Z.setBigUint64(0,BigInt($),q),Z.setBigUint64(8,BigInt(U),q),J}function m$(U){return U.byteOffset%4===0}function EU(U){return Uint8Array.from(U)}var e0=(U)=>Uint8Array.from(U.split(""),($)=>$.charCodeAt(0)),u$=e0("expand 16-byte k"),l$=e0("expand 32-byte k"),c$=XU(u$),d$=XU(l$);function W(U,$){return U<<$|U>>>32-$}function B0(U){return U.byteOffset%4===0}var pU=64,p$=16,U$=4294967295,t0=Uint32Array.of();function i$(U,$,q,J,Z,Y,Q,X){let z=Z.length,G=new Uint8Array(pU),T=XU(G),K=B0(Z)&&B0(Y),H=K?XU(Z):t0,R=K?XU(Y):t0;for(let N=0;N<z;Q++){if(U($,q,J,T,Q,X),Q>=U$)throw Error("arx: counter overflow");let V=Math.min(pU,z-N);if(K&&V===pU){let j=N/4;if(N%4!==0)throw Error("arx: invalid block position");for(let F=0,_;F<p$;F++)_=j+F,R[_]=H[_]^T[F];N+=pU;continue}for(let j=0,F;j<V;j++)F=N+j,Y[F]=Z[F]^G[j];N+=V}}function j0(U,$){let{allowShortKeys:q,extendNonceFn:J,counterLength:Z,counterRight:Y,rounds:Q}=o0({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},$);if(typeof U!=="function")throw Error("core must be a function");return dU(Z),dU(Q),cU(Y),cU(q),(X,z,G,T,K=0)=>{u(X,void 0,"key"),u(z,void 0,"nonce"),u(G,void 0,"data");let H=G.length;if(T===void 0)T=new Uint8Array(H);if(u(T,void 0,"output"),dU(K),K<0||K>=U$)throw Error("arx: counter overflow");if(T.length<H)throw Error(`arx: output (${T.length}) is shorter than data (${H})`);let R=[],N=X.length,V,j;if(N===32)R.push(V=EU(X)),j=d$;else if(N===16&&q)V=new Uint8Array(32),V.set(X),V.set(X,16),j=c$,R.push(V);else throw u(X,32,"arx key"),Error("invalid key size");if(!B0(z))R.push(z=EU(z));let F=XU(V);if(J){if(z.length!==24)throw Error("arx: extended nonce must be 24 bytes");J(j,F,XU(z.subarray(0,16)),F),z=z.subarray(16)}let _=16-Z;if(_!==z.length)throw Error(`arx: nonce must be ${_} or 16 bytes`);if(_!==12){let h=new Uint8Array(12);h.set(z,Y?0:12-z.length),z=h,R.push(z)}let S=XU(z);return i$(U,j,F,S,G,T,K,Q),zU(...R),T}}function l(U,$){return U[$++]&255|(U[$++]&255)<<8}class $${blockLen=16;outputLen=16;buffer=new Uint8Array(16);r=new Uint16Array(10);h=new Uint16Array(10);pad=new Uint16Array(8);pos=0;finished=!1;constructor(U){U=EU(u(U,32,"key"));let $=l(U,0),q=l(U,2),J=l(U,4),Z=l(U,6),Y=l(U,8),Q=l(U,10),X=l(U,12),z=l(U,14);this.r[0]=$&8191,this.r[1]=($>>>13|q<<3)&8191,this.r[2]=(q>>>10|J<<6)&7939,this.r[3]=(J>>>7|Z<<9)&8191,this.r[4]=(Z>>>4|Y<<12)&255,this.r[5]=Y>>>1&8190,this.r[6]=(Y>>>14|Q<<2)&8191,this.r[7]=(Q>>>11|X<<5)&8065,this.r[8]=(X>>>8|z<<8)&8191,this.r[9]=z>>>5&127;for(let G=0;G<8;G++)this.pad[G]=l(U,16+2*G)}process(U,$,q=!1){let J=q?0:2048,{h:Z,r:Y}=this,Q=Y[0],X=Y[1],z=Y[2],G=Y[3],T=Y[4],K=Y[5],H=Y[6],R=Y[7],N=Y[8],V=Y[9],j=l(U,$+0),F=l(U,$+2),_=l(U,$+4),S=l(U,$+6),h=l(U,$+8),WU=l(U,$+10),c=l(U,$+12),d=l(U,$+14),w=Z[0]+(j&8191),L=Z[1]+((j>>>13|F<<3)&8191),P=Z[2]+((F>>>10|_<<6)&8191),D=Z[3]+((_>>>7|S<<9)&8191),O=Z[4]+((S>>>4|h<<12)&8191),E=Z[5]+(h>>>1&8191),A=Z[6]+((h>>>14|WU<<2)&8191),C=Z[7]+((WU>>>11|c<<5)&8191),k=Z[8]+((c>>>8|d<<8)&8191),v=Z[9]+(d>>>5|J),B=0,f=B+w*Q+L*(5*V)+P*(5*N)+D*(5*R)+O*(5*H);B=f>>>13,f&=8191,f+=E*(5*K)+A*(5*T)+C*(5*G)+k*(5*z)+v*(5*X),B+=f>>>13,f&=8191;let b=B+w*X+L*Q+P*(5*V)+D*(5*N)+O*(5*R);B=b>>>13,b&=8191,b+=E*(5*H)+A*(5*K)+C*(5*T)+k*(5*G)+v*(5*z),B+=b>>>13,b&=8191;let x=B+w*z+L*X+P*Q+D*(5*V)+O*(5*N);B=x>>>13,x&=8191,x+=E*(5*R)+A*(5*H)+C*(5*K)+k*(5*T)+v*(5*G),B+=x>>>13,x&=8191;let y=B+w*G+L*z+P*X+D*Q+O*(5*V);B=y>>>13,y&=8191,y+=E*(5*N)+A*(5*R)+C*(5*H)+k*(5*K)+v*(5*T),B+=y>>>13,y&=8191;let JU=B+w*T+L*G+P*z+D*X+O*Q;B=JU>>>13,JU&=8191,JU+=E*(5*V)+A*(5*N)+C*(5*R)+k*(5*H)+v*(5*K),B+=JU>>>13,JU&=8191;let SU=B+w*K+L*T+P*G+D*z+O*X;B=SU>>>13,SU&=8191,SU+=E*Q+A*(5*V)+C*(5*N)+k*(5*R)+v*(5*H),B+=SU>>>13,SU&=8191;let _U=B+w*H+L*K+P*T+D*G+O*z;B=_U>>>13,_U&=8191,_U+=E*X+A*Q+C*(5*V)+k*(5*N)+v*(5*R),B+=_U>>>13,_U&=8191;let MU=B+w*R+L*H+P*K+D*T+O*G;B=MU>>>13,MU&=8191,MU+=E*z+A*X+C*Q+k*(5*V)+v*(5*N),B+=MU>>>13,MU&=8191;let wU=B+w*N+L*R+P*H+D*K+O*T;B=wU>>>13,wU&=8191,wU+=E*G+A*z+C*X+k*Q+v*(5*V),B+=wU>>>13,wU&=8191;let LU=B+w*V+L*N+P*R+D*H+O*K;B=LU>>>13,LU&=8191,LU+=E*T+A*G+C*z+k*X+v*Q,B+=LU>>>13,LU&=8191,B=(B<<2)+B|0,B=B+f|0,f=B&8191,B=B>>>13,b+=B,Z[0]=f,Z[1]=b,Z[2]=x,Z[3]=y,Z[4]=JU,Z[5]=SU,Z[6]=_U,Z[7]=MU,Z[8]=wU,Z[9]=LU}finalize(){let{h:U,pad:$}=this,q=new Uint16Array(10),J=U[1]>>>13;U[1]&=8191;for(let Q=2;Q<10;Q++)U[Q]+=J,J=U[Q]>>>13,U[Q]&=8191;U[0]+=J*5,J=U[0]>>>13,U[0]&=8191,U[1]+=J,J=U[1]>>>13,U[1]&=8191,U[2]+=J,q[0]=U[0]+5,J=q[0]>>>13,q[0]&=8191;for(let Q=1;Q<10;Q++)q[Q]=U[Q]+J,J=q[Q]>>>13,q[Q]&=8191;q[9]-=8192;let Z=(J^1)-1;for(let Q=0;Q<10;Q++)q[Q]&=Z;Z=~Z;for(let Q=0;Q<10;Q++)U[Q]=U[Q]&Z|q[Q];U[0]=(U[0]|U[1]<<13)&65535,U[1]=(U[1]>>>3|U[2]<<10)&65535,U[2]=(U[2]>>>6|U[3]<<7)&65535,U[3]=(U[3]>>>9|U[4]<<4)&65535,U[4]=(U[4]>>>12|U[5]<<1|U[6]<<14)&65535,U[5]=(U[6]>>>2|U[7]<<11)&65535,U[6]=(U[7]>>>5|U[8]<<8)&65535,U[7]=(U[8]>>>8|U[9]<<5)&65535;let Y=U[0]+$[0];U[0]=Y&65535;for(let Q=1;Q<8;Q++)Y=(U[Q]+$[Q]|0)+(Y>>>16)|0,U[Q]=Y&65535;zU(q)}update(U){I0(this),u(U),U=EU(U);let{buffer:$,blockLen:q}=this,J=U.length;for(let Z=0;Z<J;){let Y=Math.min(q-this.pos,J-Z);if(Y===q){for(;q<=J-Z;Z+=q)this.process(U,Z);continue}if($.set(U.subarray(Z,Z+Y),this.pos),this.pos+=Y,Z+=Y,this.pos===q)this.process($,0,!1),this.pos=0}return this}destroy(){zU(this.h,this.r,this.buffer,this.pad)}digestInto(U){I0(this),n0(U,this),this.finished=!0;let{buffer:$,h:q}=this,{pos:J}=this;if(J){$[J++]=1;for(;J<16;J++)$[J]=0;this.process($,0,!0)}this.finalize();let Z=0;for(let Y=0;Y<8;Y++)U[Z++]=q[Y]>>>0,U[Z++]=q[Y]>>>8;return U}digest(){let{buffer:U,outputLen:$}=this;this.digestInto(U);let q=U.slice(0,$);return this.destroy(),q}}function s$(U){let $=(J,Z)=>U(Z).update(J).digest(),q=U(new Uint8Array(32));return $.outputLen=q.outputLen,$.blockLen=q.blockLen,$.create=(J)=>U(J),$}var q$=(()=>s$((U)=>new $$(U)))();function Y$(U,$,q,J,Z,Y=20){let Q=U[0],X=U[1],z=U[2],G=U[3],T=$[0],K=$[1],H=$[2],R=$[3],N=$[4],V=$[5],j=$[6],F=$[7],_=Z,S=q[0],h=q[1],WU=q[2],c=Q,d=X,w=z,L=G,P=T,D=K,O=H,E=R,A=N,C=V,k=j,v=F,B=_,f=S,b=h,x=WU;for(let JU=0;JU<Y;JU+=2)c=c+P|0,B=W(B^c,16),A=A+B|0,P=W(P^A,12),c=c+P|0,B=W(B^c,8),A=A+B|0,P=W(P^A,7),d=d+D|0,f=W(f^d,16),C=C+f|0,D=W(D^C,12),d=d+D|0,f=W(f^d,8),C=C+f|0,D=W(D^C,7),w=w+O|0,b=W(b^w,16),k=k+b|0,O=W(O^k,12),w=w+O|0,b=W(b^w,8),k=k+b|0,O=W(O^k,7),L=L+E|0,x=W(x^L,16),v=v+x|0,E=W(E^v,12),L=L+E|0,x=W(x^L,8),v=v+x|0,E=W(E^v,7),c=c+D|0,x=W(x^c,16),k=k+x|0,D=W(D^k,12),c=c+D|0,x=W(x^c,8),k=k+x|0,D=W(D^k,7),d=d+O|0,B=W(B^d,16),v=v+B|0,O=W(O^v,12),d=d+O|0,B=W(B^d,8),v=v+B|0,O=W(O^v,7),w=w+E|0,f=W(f^w,16),A=A+f|0,E=W(E^A,12),w=w+E|0,f=W(f^w,8),A=A+f|0,E=W(E^A,7),L=L+P|0,b=W(b^L,16),C=C+b|0,P=W(P^C,12),L=L+P|0,b=W(b^L,8),C=C+b|0,P=W(P^C,7);let y=0;J[y++]=Q+c|0,J[y++]=X+d|0,J[y++]=z+w|0,J[y++]=G+L|0,J[y++]=T+P|0,J[y++]=K+D|0,J[y++]=H+O|0,J[y++]=R+E|0,J[y++]=N+A|0,J[y++]=V+C|0,J[y++]=j+k|0,J[y++]=F+v|0,J[y++]=_+B|0,J[y++]=S+f|0,J[y++]=h+b|0,J[y++]=WU+x|0}function n$(U,$,q,J){let Z=U[0],Y=U[1],Q=U[2],X=U[3],z=$[0],G=$[1],T=$[2],K=$[3],H=$[4],R=$[5],N=$[6],V=$[7],j=q[0],F=q[1],_=q[2],S=q[3];for(let WU=0;WU<20;WU+=2)Z=Z+z|0,j=W(j^Z,16),H=H+j|0,z=W(z^H,12),Z=Z+z|0,j=W(j^Z,8),H=H+j|0,z=W(z^H,7),Y=Y+G|0,F=W(F^Y,16),R=R+F|0,G=W(G^R,12),Y=Y+G|0,F=W(F^Y,8),R=R+F|0,G=W(G^R,7),Q=Q+T|0,_=W(_^Q,16),N=N+_|0,T=W(T^N,12),Q=Q+T|0,_=W(_^Q,8),N=N+_|0,T=W(T^N,7),X=X+K|0,S=W(S^X,16),V=V+S|0,K=W(K^V,12),X=X+K|0,S=W(S^X,8),V=V+S|0,K=W(K^V,7),Z=Z+G|0,S=W(S^Z,16),N=N+S|0,G=W(G^N,12),Z=Z+G|0,S=W(S^Z,8),N=N+S|0,G=W(G^N,7),Y=Y+T|0,j=W(j^Y,16),V=V+j|0,T=W(T^V,12),Y=Y+T|0,j=W(j^Y,8),V=V+j|0,T=W(T^V,7),Q=Q+K|0,F=W(F^Q,16),H=H+F|0,K=W(K^H,12),Q=Q+K|0,F=W(F^Q,8),H=H+F|0,K=W(K^H,7),X=X+z|0,_=W(_^X,16),R=R+_|0,z=W(z^R,12),X=X+z|0,_=W(_^X,8),R=R+_|0,z=W(z^R,7);let h=0;J[h++]=Z,J[h++]=Y,J[h++]=Q,J[h++]=X,J[h++]=j,J[h++]=F,J[h++]=_,J[h++]=S}var o$=j0(Y$,{counterRight:!1,counterLength:4,allowShortKeys:!1}),a$=j0(Y$,{counterRight:!1,counterLength:8,extendNonceFn:n$,allowShortKeys:!1});var r$=new Uint8Array(16),J$=(U,$)=>{U.update($);let q=$.length%16;if(q)U.update(r$.subarray(q))},t$=new Uint8Array(32);function Z$(U,$,q,J,Z){if(Z!==void 0)u(Z,void 0,"AAD");let Y=U($,q,t$),Q=r0(J.length,Z?Z.length:0,!0),X=q$.create(Y);if(Z)J$(X,Z);J$(X,J),X.update(Q);let z=X.digest();return zU(Y,Q),z}var Q$=(U)=>($,q,J)=>{return{encrypt(Y,Q){let X=Y.length;Q=V0(X+16,Q,!1),Q.set(Y);let z=Q.subarray(0,-16);U($,q,z,z,1);let G=Z$(U,$,q,z,J);return Q.set(G,X),zU(G),Q},decrypt(Y,Q){Q=V0(Y.length-16,Q,!1);let X=Y.subarray(0,-16),z=Y.subarray(-16),G=Z$(U,$,q,X,J);if(!a0(z,G))throw Error("invalid tag");return Q.set(Y.subarray(0,-16)),U($,q,Q,Q,1),zU(G),Q}}},rq=N0({blockSize:64,nonceLength:12,tagLength:16},Q$(o$)),F0=N0({blockSize:64,nonceLength:24,tagLength:16},Q$(a$));class $U extends QU{static IV_LENGTH=24;static TAG_LENGTH=16;IV_LENGTH=$U.IV_LENGTH;TAG_LENGTH=$U.TAG_LENGTH;key=null;constructor(U){super(U)}async setKey(U){this.key=new Uint8Array(await this.p.subtle.exportKey("raw",U))}zeroKey(){if(this.key)this.key.fill(0);this.key=null}async encryptWithAAD(U,$){let q=this.p.getRandomValues(new Uint8Array($U.IV_LENGTH)),Z=F0(this.requireRawKey(),q,$).encrypt(U),Y=new Uint8Array(q.length+Z.length);return Y.set(q,0),Y.set(Z,q.length),Y}async decryptWithAAD(U,$){if(U.byteLength<$U.IV_LENGTH+$U.TAG_LENGTH)throw new g("Invalid ciphertext: too short.");let q=U.subarray(0,$U.IV_LENGTH),J=U.subarray($U.IV_LENGTH),Z=F0(this.requireRawKey(),q,$);try{return Z.decrypt(J)}catch{throw new g("Decryption failed: wrong passphrase or corrupted ciphertext")}}requireRawKey(){if(!this.key)throw Error("Encryption key not set");return this.key}}var iU=NU(require("argon2-browser"));async function e$(){if(typeof window<"u")return;if(globalThis.loadArgon2WasmModule)return;try{let{createRequire:U}=await import("node:module"),{readFile:$}=await import("node:fs/promises"),q=U(import.meta.url),J=q.resolve("argon2-browser/dist/argon2.js"),Z=q.resolve("argon2-browser/dist/argon2.wasm");globalThis.loadArgon2WasmModule=async()=>{let Y=new Uint8Array(await $(Z));return globalThis.Module={wasmBinary:Y,locateFile:(Q)=>Q==="argon2.wasm"?Z:Q},q(J)}}catch{}}async function X$(U,$,q,J){if(J==="node"){let Z=await import("@node-rs/argon2"),Y=typeof U==="string"?Buffer.from(U,"utf8"):Buffer.from(U),X=(await Z.hash(Y,{salt:$,timeCost:q.time,memoryCost:q.mem,parallelism:q.parallelism,outputLen:32,algorithm:Z.Algorithm.Argon2id})).split("$").pop();if(!X)throw Error("Unexpected argon2 hash format");let z=Buffer.from(X,"base64");return Y.fill(0),{hash:new Uint8Array(z)}}if(J==="browser")return await e$(),iU.hash({pass:U,salt:$,time:q.time,mem:q.mem,parallelism:q.parallelism,hashLen:32,type:iU.ArgonType.Argon2id}).then((Z)=>{if(!Z||!Z.hash)throw new YU("Failed to produce key derivation");return{hash:Z.hash}}).catch((Z)=>{let Y=Z instanceof Error?Z.message:typeof Z==="string"?Z:"Unknown error";throw new YU(`argon2-browser failure: ${Y}`)});throw Error(`Unsupported environment: ${J}`)}class sU{presets;exportExtractable;name="argon2id";constructor(U,$=!1){this.presets=U;this.exportExtractable=$}async derive(U,$,q,J){let{hash:Z}=await X$(U,$,this.presets[q],J.isNode?"node":"browser");if(this.exportExtractable)return J.subtle.importKey("raw",Z,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]);else return J.subtle.importKey("raw",Z,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}}var z$={low:{time:5,mem:65536,parallelism:1},middle:{time:20,mem:65536,parallelism:1},high:{time:40,mem:65536,parallelism:1}},Uq={id:0,cipher:UU,kdf:new sU(z$),saltLengths:{low:12,high:16},difficulties:z$,defaultChunkSize:524288};p.register(Uq);var G$={low:{time:5,mem:65536,parallelism:2},middle:{time:10,mem:98304,parallelism:4},high:{time:20,mem:98304,parallelism:4}},$q={id:1,cipher:$U,kdf:new sU(G$,!0),saltLengths:{low:12,high:16},difficulties:G$,defaultChunkSize:524288};p.register($q);var nU=1;function AU(U,$,q,J,Z){let Y={low:0,middle:1,high:2};if(!($ in Y))throw TypeError(`Unsupported difficulty: ${$}`);let Q=Y[$],X=U<<5|(q==="high"?1:0)<<2|Q,z=jU(new Uint8Array([nU,X]),J);if(Z)Z.setAAD(z);return z}function qU(U,$){if(U[0]!==nU)throw new o("Invalid input format. The input is unknown.");if(U.length<14)throw new o("Invalid input format. Header too short.");try{let q=U[1],J=q>>5,Z=q>>2&1?"high":"low",Y=q&3,Q=["low","middle","high"][Y],X=p.get(J).saltLengths[Z],z=2+X;if(U.length<z)throw new o("Invalid input format. Header truncated.");if($)$.setAAD(U.subarray(0,z));let G=U.slice(2,2+X);return{scheme:J,difficulty:Q,saltStrength:Z,salt:G,headerLen:z}}catch(q){throw new HU(q instanceof Error?q.message:String(q))}}async function oU(U){if(U instanceof Uint8Array)return U;if(U instanceof ArrayBuffer)return new Uint8Array(U);return new Uint8Array(await U.arrayBuffer())}function S0(U){let $=new Uint8Array(4);return new DataView($.buffer).setUint32(0,U,!1),$}function T$(U,$=0){if(U.length-$<4)throw RangeError("Not enough bytes for frame header");return new DataView(U.buffer,U.byteOffset+$,4).getUint32(0,!1)}var GU=4;class xU{engine;chunkSize;buffer=new Uint8Array(0);constructor(U,$=524288){this.engine=U;this.chunkSize=$}toTransformStream(){return new TransformStream({transform:async(U,$)=>{await this.transform(await oU(U),$)},flush:async(U)=>this.flush(U)})}async transform(U,$){if(U.length>Math.min(this.chunkSize*4,67108864))throw RangeError(`Input block (${U.length} B) exceeds maximum allowed ${Math.min(this.chunkSize*4,67108864)} B`);let J=new Uint8Array(this.buffer.length+U.length);J.set(this.buffer),J.set(U,this.buffer.length);let Z=0;while(J.length-Z>=this.chunkSize){let Y=J.slice(Z,Z+this.chunkSize);Z+=this.chunkSize;let Q=await this.engine.encryptChunk(Y),X=new Uint8Array(GU+Q.length);X.set(S0(Q.length)),X.set(Q,GU),$.enqueue(X)}this.buffer=J.slice(Z)}async flush(U){if(!this.buffer.length)return;let $=await this.engine.encryptChunk(this.buffer),q=new Uint8Array(GU+$.length);q.set(S0($.length)),q.set($,GU),U.enqueue(q),this.buffer=new Uint8Array(0),this.engine.zeroKey()}}class CU{engine;chunkSize;buffer=new Uint8Array(0);constructor(U,$=524288){this.engine=U;this.chunkSize=$}toTransformStream(){return new TransformStream({transform:async(U,$)=>{await this.transform(await oU(U),$)},flush:async(U)=>this.flush(U)})}async transform(U,$){let q=new Uint8Array(this.buffer.length+U.length);q.set(this.buffer),q.set(U,this.buffer.length);let J=0;while(!0){if(q.length-J<GU)break;let Z=T$(q,J);if(Z>this.chunkSize*2)throw new g(`Frame length ${Z} exceeds …`);if(q.length-J-GU<Z)break;J+=GU;let Y=q.slice(J,J+Z);J+=Z;try{let Q=await this.engine.decryptChunk(Y);$.enqueue(Q)}catch(Q){throw Q instanceof g?Q:new g("Decryption failed: Wrong passphrase or corrupted ciphertext")}}this.buffer=q.slice(J)}async flush(U){await this.transform(new Uint8Array(0),U),this.buffer=new Uint8Array(0),this.engine.zeroKey()}}async function K$(U,$){let q=U.getReader(),J=$&&$.length?[$]:[];try{while(!0){let{value:X,done:z}=await q.read();if(z)break;J.push(X)}}finally{q.releaseLock()}let Z=J.reduce((X,z)=>X+z.byteLength,0),Y=new Uint8Array(Z),Q=0;for(let X of J)Y.set(X,Q),Q+=X.byteLength;return Y}class kU{engine;chunkSize;constructor(U,$=524288){this.engine=U;this.chunkSize=$}encryptionStream(){let U=new xU(this.engine,this.chunkSize).toTransformStream();return{writable:U.writable,readable:U.readable}}decryptionStream(U){let $=U,q=new TransformStream({transform(Z,Y){if($===0){Y.enqueue(Z);return}if(Z.byteLength<=$){$-=Z.byteLength;return}Y.enqueue(Z.slice($)),$=0}}),J=new CU(this.engine,this.chunkSize).toTransformStream();return{writable:q.writable,readable:q.readable.pipeThrough(J)}}async collect(U,$,q=null){return K$(U.pipeThrough($),q??void 0)}getEngine(){return this.engine}}function W$(U){try{if(U)U.fill(0)}catch{}}function qq(U){let $="";for(let q=0;q<U.length;q++){let J=U[q].toString(16).padStart(2,"0");$+=J}return $}class TU{bytes;destroyed=!1;static from(U){if(U instanceof TU)return U;if(typeof U==="string")return new TU(new TextEncoder().encode(U));if(U instanceof Uint8Array)return new TU(U);throw TypeError("ConvertibleInput: unsupported input type")}constructor(U){this.bytes=U}toUint8Array(){if(this.destroyed)throw Error("ConvertibleInput: already cleared");return this.bytes}clear(){if(!this.destroyed)W$(this.bytes),this.bytes=new Uint8Array(0),this.destroyed=!0}}class gU{bytes;destroyed=!1;constructor(U){this.bytes=U}get uint8array(){if(this.destroyed)throw Error("ConvertibleOutput: already cleared");return this.bytes}get base64(){if(this.destroyed)throw Error("ConvertibleOutput: already cleared");return OU(this.bytes)}get hex(){if(this.destroyed)throw Error("ConvertibleOutput: already cleared");return qq(this.bytes)}get text(){if(this.destroyed)throw Error("ConvertibleOutput: already cleared");return new TextDecoder().decode(this.bytes)}clear(){if(!this.destroyed)W$(this.bytes),this.bytes=new Uint8Array(0),this.destroyed=!0}toString(){return this.base64}}class hU extends Error{constructor(U="Malformed padding"){super(U)}}class m{static STRUCT_SIZE=8;static MAGIC40=new Uint8Array([227,122,193,93,180]);static VERSION=41;static CRC8_POLY=7;maxPad=m.STRUCT_SIZE+8-1;static ctEqU8(U,$){return(((U|0)^($|0))&255)===0}static ctEqFixedLen(U,$){let q=0,J=U.length;for(let Z=0;Z<J;Z++)q|=U[Z]^$[Z];return q===0}crc8(U){let $=0;for(let q=0;q<U.length;q++){$^=U[q]&255;for(let J=0;J<8;J++)$=$&128?$<<1^m.CRC8_POLY:$<<1,$&=255}return $&255}computeK(U,$){let q=m.STRUCT_SIZE;if(!Number.isInteger($)||$<1)throw new hU("align must be a positive integer");if(q+$-1>255)throw new hU("align too large for 1-byte LEN");let J=q+$-1,Z=($-U%$)%$;if(Z===0)Z=$;while(Z<q)Z+=$;if(Z>J)throw new hU("Cannot satisfy alignment within 1-byte LEN");return Z}pad(U,$,q=8){let J=m.STRUCT_SIZE,Z=this.computeK(U.length,q),Y=Z-J,Q=new Uint8Array(U.length+Z);if(Q.set(U,0),Y>0){let G=$(Y);if(!G||G.length!==Y)throw new hU("rng returned wrong length");Q.set(G,U.length)}let X=U.length+Y;Q.set(m.MAGIC40,X+0),Q[X+5]=m.VERSION&255,Q[X+6]=Z&255;let z=new Uint8Array(7);return z.set(m.MAGIC40,0),z[5]=m.VERSION&255,z[6]=Z&255,Q[X+7]=this.crc8(z),Q}tryUnpad(U){let $=m.STRUCT_SIZE,q=()=>({used:!1,plain:U});if(U.length<$)return q();let J=U.length,Z=U[J-1]&255,Y=U[J-2]&255,Q=U[J-3]&255;if(Y<$||Y>U.length)return q();let X=J-$,z=U.subarray(X,X+5);if(!m.ctEqFixedLen(z,m.MAGIC40))return q();if(!m.ctEqU8(Q,m.VERSION&255))return q();let T=new Uint8Array(7);T.set(m.MAGIC40,0),T[5]=Q,T[6]=Y;let K=this.crc8(T);if(!m.ctEqU8(K,Z))return q();return{used:!0,plain:U.subarray(0,J-Y)}}}function H$(U=0,$=console.info){return{level:U,log(q,J){if(q<=U)$(`${q}| ${J}`)}}}var R$=new WeakMap;class RU{static getEngine(U,$){let q=R$.get(U);if(!q)q=new Map,R$.set(U,q);let J=q.get($);if(J)return J;let Z=p.get($);return J={desc:Z,cipher:new Z.cipher(U),kdf:Z.kdf,chunkSize:Z.defaultChunkSize,provider:U},q.set($,J),J}static async deriveKey(U,$,q,J){try{let Z=await U.kdf.derive($.value,q,J,U.provider);await U.cipher.setKey(Z)}catch(Z){let Y=Z instanceof Error?Z.message:String(Z);throw new YU(Y)}finally{i($)}}}class s{provider;v;cipher;kdf;chunkSize;stream;acceptUnauthenticatedHeader;difficulty;saltStrength;engines=new Map;log;constructor(U,$={}){this.provider=U;this.v=p.get($.scheme??p.current.id),this.cipher=new this.v.cipher(U),this.kdf=this.v.kdf,this.chunkSize=this.setChunkSize($.chunkSize??this.v.defaultChunkSize),this.stream=new kU(this.cipher,this.chunkSize),this.difficulty=$.difficulty??"middle",this.saltStrength=$.saltStrength??"high",this.acceptUnauthenticatedHeader=$.acceptUnauthenticatedHeader??!1,this.log=H$($.verbose??0,$.logger)}static async isEncrypted(U){try{return await s.peekHeader(U),!0}catch{return!1}}static async decodeHeader(U){let $=await s.peekHeader(U),q=qU($);return{scheme:q.scheme,difficulty:q.difficulty,salt:OU(q.salt),saltBytes:q.salt,saltLength:q.salt.byteLength}}static async headerDecode(U){return this.decodeHeader(U)}static isRandomAccessSource(U){return typeof U==="object"&&U!==null&&typeof U.read==="function"}static async decodeData(U){let $=s.isRandomAccessSource(U)?U:new R0(U),q=await $.read(0,Math.min(256,$.length)),J=await s.peekHeader(q),{scheme:Z,headerLen:Y}=qU(J),Q=$.length,X=Q-Y;if(X<=0)throw new o("Payload is empty");let z=await $.read(Y,4),G=new DataView(z.buffer,z.byteOffset,4).getUint32(0,!1);if(G+4<=X&&G>=28){let N=G,V=Y,j=0,F=0;while(V+4<=Q){let _=await $.read(V,4),S=new DataView(_.buffer,_.byteOffset,4).getUint32(0,!1);if(S===0||V+4+S>Q)break;j++,F+=S,V+=4+S}return{isChunked:!0,chunks:{chunkSize:N,count:j,totalPayload:F}}}let K=await $.read(Y,X),H=p.get(Z).cipher.IV_LENGTH,R=p.get(Z).cipher.TAG_LENGTH;if(K.length<H+R)throw new o("Ciphertext too short for IV & tag");return{isChunked:!1,payloadLength:X-H-R,params:{iv:K.slice(0,H),ivLength:H,tag:K.slice(K.length-R),tagLength:R}}}setDifficulty(U){this.difficulty=U}getDifficulty(){return this.difficulty}setScheme(U){this.v=p.get(U),this.cipher=new this.v.cipher(this.provider),this.kdf=this.v.kdf,this.stream=new kU(this.cipher,this.chunkSize)}getScheme(){return this.v.id}setSaltDifficulty(U){this.saltStrength=U}getSaltDifficulty(){return this.saltStrength}setChunkSize(U){let q=U,J;if(q==null)J=this.v.defaultChunkSize;else{if(J=Number(q),!Number.isInteger(J)||J<1)throw Error(`Invalid chunkSize: ${q}. Must be a positive integer.`);if(J>134217728)throw RangeError("chunkSize cannot exceed 134217728 bytes.")}if(this.chunkSize=J,this.stream)this.stream=new kU(this.cipher,this.chunkSize);return J}getChunkSize(){return this.chunkSize}setVerbose(U){this.log.level=U}getVerbose(){return this.log.level}async encryptText(U,$){if($===null)throw new e("Password can't be null");let q={value:$};try{if($==="")this.log.log(0,"Empty passphrase provided to encryptText");this.log.log(1,`Start text encryption, scheme: ${this.getScheme()}`);let J=TU.from(U),Z=J.toUint8Array();this.log.log(2,"Deriving key for text encryption");let Y=this.genSalt();await this.deriveKey(q,Y),i(q),$=null,this.log.log(3,`Salt generated: ${OU(Y)}, KDF difficulty: ${this.difficulty}`),this.log.log(3,"Encoding header");let Q=AU(this.v.id,this.difficulty,this.saltStrength,Y,this.cipher);this.cipher.setPaddingScheme(new m),this.cipher.setPaddingAlign(8),this.cipher.setPaddingAADMode("require"),this.log.log(2,"Encrypting text data");let X=await this.cipher.encryptChunk(Z);this.cipher.zeroKey();try{J.clear()}catch{}let z=jU(Q,X);return this.log.log(1,"Encryption finished"),new gU(z)}catch(J){throw new e(J instanceof Error?J.message:String(J))}}async decryptText(U,$){if($===null)throw new e("Password can't be null");let q={value:$};try{if($==="")this.log.log(0,"Empty passphrase provided to decryptText");this.log.log(1,`Start text decryption, Version ${this.getScheme()}`);let J;if(typeof U==="string")this.log.log(3,"Decoding Base64 ciphertext"),J=fU(U);else if(U instanceof Uint8Array)J=U;else if(U instanceof TU)J=U.toUint8Array();else throw new PU("Unsupported ciphertext input type");this.log.log(3,"Start header decoding");let Z=qU(J);this.log.log(3,"Selecting decryption engine");let Y=RU.getEngine(this.provider,Z.scheme);this.log.log(2,`Deriving key via engine for scheme: ${Z.scheme}`),this.log.log(3,`Salt use: ${OU(Z.salt)}, KDF difficulty: ${Z.difficulty}`);try{await RU.deriveKey(Y,q,Z.salt,Z.difficulty)}finally{i(q),$=null}Y.cipher.setPaddingScheme(new m),Y.cipher.setPaddingAlign(8),Y.cipher.setPaddingAADMode("require"),Y.cipher.setLegacyAADFallback({enabled:!0,policy:"auto",tryEmptyAAD:this.acceptUnauthenticatedHeader?!0:!1}),this.log.log(2,"Decrypting text data"),qU(J,Y.cipher);let Q=await Y.cipher.decryptChunk(J.slice(Z.headerLen));if(Y.cipher.zeroKey(),U instanceof TU)try{U.clear()}catch{}return this.log.log(1,"Decryption finished"),new gU(Q)}catch(J){if(J instanceof g||J instanceof o||J instanceof HU||J instanceof PU||J instanceof YU)throw J;throw new g("Decryption failed: wrong passphrase or corrupted ciphertext")}}async encryptFile(U,$){if($===null)throw new e("Password can't be null");let q={value:$};try{if(U.size===0){let Q=this.genSalt();await this.deriveKey(q,Q),i(q),$=null;let X=AU(this.v.id,this.difficulty,this.saltStrength,Q);return new Blob([X],{type:"application/octet-stream"})}this.log.log(2,"Deriving key for file encryption");let J=this.genSalt();await this.deriveKey(q,J),i(q),$=null;let Z=AU(this.v.id,this.difficulty,this.saltStrength,J,this.stream.getEngine());this.stream.getEngine().setPaddingAADMode("forbid");let Y=await this.stream.collect(U.stream(),new xU(this.cipher,this.chunkSize).toTransformStream(),Z);return new Blob([Y],{type:"application/octet-stream"})}catch(J){throw new e(J instanceof Error?J.message:String(J))}}async decryptFile(U,$){if($===null)throw new e("Password can't be null");let q={value:$};try{let J=await s.peekHeader(U),Z=qU(J),Y=RU.getEngine(this.provider,Z.scheme);try{await RU.deriveKey(Y,q,Z.salt,Z.difficulty)}finally{i(q),$=null}if(U.size===Z.headerLen)return new Blob([],{type:"application/octet-stream"});this.log.log(2,"Decrypting file data");let Q=new kU(Y.cipher,Y.chunkSize);qU(J,Q.getEngine()),Y.cipher.setPaddingAADMode("forbid"),Y.cipher.setLegacyAADFallback({enabled:!0,policy:"auto",tryEmptyAAD:this.acceptUnauthenticatedHeader?!0:!1});let X=await Q.collect(U.slice(Z.headerLen).stream(),new CU(Y.cipher,Y.chunkSize).toTransformStream());return new Blob([X],{type:"application/octet-stream"})}catch(J){if(J instanceof g)throw J;throw new g(J instanceof Error?J.message:String(J))}}async createEncryptionStream(U){if(U===null)throw new e("Password can't be null");let $={value:U};this.log.log(2,"Deriving key for stream encryption");let q=this.genSalt();await this.deriveKey($,q),i($),U=null;let J=AU(this.v.id,this.difficulty,this.saltStrength,q,this.stream.getEngine());this.stream.getEngine().setPaddingAADMode("forbid");let Z=this.stream.encryptionStream();return{header:J,writable:Z.writable,readable:Z.readable}}async createDecryptionStream(U){if(U===null)throw new e("Password can't be null");let $=this.provider,q={value:U},J=new Uint8Array(0),Z=null,Y=65536,Q=14,X=async(z,G)=>{let T=z.getReader();while(!0){let{value:K,done:H}=await T.read();if(H)break;G.enqueue(K)}};return new TransformStream({transform:async(z,G)=>{if(!Z){if(z&&z.byteLength){if(J.byteLength+z.byteLength>Y){i(q),G.error(new o(`Header not found within ${Y} bytes`));return}J=jU(J,z)}if(J.byteLength<Q)return;let K=J[1],H=K>>5,R=K>>2&1?"high":"low",N=0;try{N=2+p.get(H).saltLengths[R]}catch(S){i(q),G.error(new HU(S instanceof Error?S.message:String(S)));return}if(J.byteLength<N)return;let V=J.subarray(0,N),j;try{j=qU(V)}catch(S){i(q),G.error(S instanceof Error?S:new HU("Invalid header"));return}let F=RU.getEngine($,j.scheme);try{await RU.deriveKey(F,q,j.salt,j.difficulty)}finally{i(q),U=null}qU(V,F.cipher),F.cipher.setPaddingAADMode("forbid"),F.cipher.setLegacyAADFallback({enabled:!0,policy:"auto",tryEmptyAAD:this.acceptUnauthenticatedHeader?!0:!1}),Z=new CU(F.cipher,F.chunkSize).toTransformStream(),X(Z.readable,G).catch((S)=>G.error(S));let _=J.subarray(N);if(J=new Uint8Array(0),_.byteLength){let S=Z.writable.getWriter();await S.write(_),S.releaseLock()}return}let T=Z.writable.getWriter();await T.write(z),T.releaseLock()},flush:async()=>{if(!Z)throw i(q),new o("Header not found before end of stream");let z=Z.writable.getWriter();await z.close(),z.releaseLock()}})}generateFakeData(U=0){if(!Number.isInteger(U)||U<0)throw RangeError("payloadLength must be a non-negative integer.");let $=this.genSalt(),q=AU(this.v.id,this.difficulty,this.saltStrength,$,this.cipher),J=U>0?this.provider.getRandomValues(new Uint8Array(U)):new Uint8Array(0);return jU(q,J)}async deriveKey(U,$,q=this.difficulty){let J=performance.now();try{let Z=await this.kdf.derive(U.value,$,q,this.provider);i(U),await this.cipher.setKey(Z),this.log.log(3,`Key derivation completed in ${(performance.now()-J).toFixed(1)} ms`)}catch(Z){throw new YU(Z instanceof Error?Z.message:String(Z))}}genSalt(U=this.saltStrength){let $=this.v.saltLengths[U];return this.provider.getRandomValues(new Uint8Array($))}static async peekHeader(U){let $=await this.readAsUint8(U);if($ instanceof Uint8Array){if($.length<2)throw new o("Input too short");let{headerLen:q}=qU($.length>=16?$:Uint8Array.from($));if($.length<q)throw new o("Incomplete header");return $.slice(0,q)}throw new HU("Unsupported input type")}static async readAsUint8(U){if(typeof U==="string")return fU(U);if(U instanceof Blob){let $=U.slice(0,64);return new Uint8Array(await $.arrayBuffer())}return U}}var aU=require("node:crypto"),I$={subtle:aU.webcrypto.subtle,getRandomValues(U){return aU.randomFillSync(U),U},isNode:!0};function vU(U){return new s(I$,U)}var KU=require("node:path");var rU=require("node:stream");function _0(U){return rU.Readable.toWeb(U)}function M0(U){return rU.Writable.toWeb(U)}var IU=require("fs"),V$=NU(require("os")),w0=NU(require("path")),Jq="2.2.0",Zq=process.cwd();async function tU(){if(!I.stdin.isTTY)throw Error("STDIN not a TTY; use --pass");I.stderr.write("Passphrase: "),I.stdin.setRawMode?.(!0),I.stdin.resume(),I.stdin.setEncoding("utf8");let U="";return new Promise(($)=>{function q(){I.stdin.setRawMode?.(!1),I.stdin.pause(),I.stderr.write(`
`),I.stdin.off("data",J),$(U)}function J(Z){if(Z==="\x03")I.exit(130);if(Z==="\r"||Z===`
`)return q();if(Z==="\b"||Z===""){U=U.slice(0,-1);return}U+=Z}I.stdin.on("data",J)})}function L0(U,$=Zq){if(U==="-")return;let q=r.realpathSync($),J=KU.isAbsolute(U)?KU.resolve(U):KU.resolve(q,U),Z=KU.dirname(J);if(!r.realpathSync(Z).startsWith(q+KU.sep))throw new DU("Refusing to write outside of root directory.");if(!r.existsSync(Z))throw new DU(`Output directory does not exist: ${Z}`);try{r.accessSync(Z,r.constants.W_OK)}catch{throw new DU("Output directory is not writeable")}return J}async function N$(){let U=[];for await(let $ of I.stdin)U.push($);return Buffer.concat(U).toString("utf8")}var n=new p0;n.name("cryptit").version(Jq).description(`Text and File Encryption Utility
Scheme 0: AES-GCM (Native) / Argon2id (Single Thread)
Scheme 1: XChaCha20-Poly1305 (JS Engine) / Argon2id (Parallel)`).showHelpAfterError().showSuggestionAfterError().addOption(new BU("-S, --scheme <0-1>","encryption scheme version").argParser((U)=>{let $=Number(U);if(!Number.isInteger($)||$<0||$>7)throw Error("Version size must be a integer between 0 and 7");return $}).default(0,"0")).addOption(new BU("-p, --pass <passphrase>","passphrase (prompt if omitted)").hideHelp().argParser((U)=>{if(!U.trim())throw Error("Passphrase cannot be empty");return U})).addOption(new BU("-d, --difficulty <level>","argon2 difficulty").choices(["low","middle","high"]).default("middle","middle")).addOption(new BU("-s, --salt-strength <variant>","salt length variant").choices(["low","high"]).default("high","high")).addOption(new BU("-c, --chunk-size <bytes>","chunk size in bytes").argParser((U)=>{let $=Number(U);if(!Number.isInteger($)||$<=0)throw Error("Chunk size must be a positive integer");return $}).default(524288,"512*1024")).addOption(new BU("-v, --verbose","increase verbosity (use multiple times)").default(0).argParser((U,$)=>{return $+1}));process.on("uncaughtException",(U)=>{if(U instanceof Error){let $=U.constructor.name,q=U.message;I.stderr.write(`Error [${$}]: ${q}
`)}else I.stderr.write(`Error [Unknown]: ${String(U)}
`);I.exit(1)});process.on("unhandledRejection",(U)=>{if(U instanceof Error){let $=U.constructor.name,q=U.message;I.stderr.write(`Error [${$}]: ${q}
`)}else I.stderr.write(`Error [Unknown]: ${String(U)}
`);I.exit(1)});n.command("decode [src]").description("Show Cryptit header information plus payload details; omit arg or use - to read from STDIN").action(async(U)=>{let $=!U||U==="-";async function q(z){if(z.length<2)throw Error("Input too short for header");let G=z.subarray(0,Math.min(256,z.length)),T=await s.decodeHeader(G),K=await s.decodeData(z);if(delete T.saltBytes,K.isChunked){let{chunkSize:N,count:V,totalPayload:j}=K.chunks;return{...T,isChunked:!0,chunks:{chunkSize:N,count:V,totalPayload:j}}}let H=Buffer.from(K.params.iv).toString("base64"),R=Buffer.from(K.params.tag).toString("base64");return{...T,isChunked:!1,payloadLength:K.payloadLength,params:{iv:H,ivLength:K.params.ivLength,tag:R,tagLength:K.params.tagLength}}}async function J(z){let G=await z.read(0,Math.min(256,z.length)),T=await s.decodeHeader(G),K=await s.decodeData(z);if(delete T.saltBytes,K.isChunked){let{chunkSize:N,count:V,totalPayload:j}=K.chunks;return{...T,isChunked:!0,chunks:{chunkSize:N,count:V,totalPayload:j}}}let H=Buffer.from(K.params.iv).toString("base64"),R=Buffer.from(K.params.tag).toString("base64");return{...T,isChunked:!1,payloadLength:K.payloadLength,params:{iv:H,tag:R}}}async function Z(){let z=Number(process.env.CRYPTIT_STDIN_MAX_BYTES),G=Number.isFinite(z)&&z>0?Math.floor(z):10073741824,T=await IU.promises.mkdtemp(w0.join(V$.tmpdir(),"cryptit-")),K=w0.join(T,"stdin.bin"),H=FU.createWriteStream(K,{flags:"w"}),R=0;try{for await(let N of process.stdin){let V=Buffer.isBuffer(N)?N:Buffer.from(N);if(R+=V.length,R>G)throw H.destroy(),await IU.promises.rm(T,{recursive:!0,force:!0}).catch(()=>{}),new DU(`STDIN exceeds maximum allowed size (${G} bytes). Aborting.`);if(!H.write(V))await new Promise((j)=>H.once("drain",j))}return await new Promise((N,V)=>{H.end(()=>N()),H.on("error",V)}),K}catch(N){throw H.destroy(),await IU.promises.rm(T,{recursive:!0,force:!0}).catch(()=>{}),N}}if(!$&&U){let z=await bU.open(U);try{let G=await J(z);I.stdout.write(JSON.stringify(G,null,2)+`
`)}finally{await z.close()}return}if($){let z=await Z(),G=await bU.open(z);try{try{let N=await J(G);I.stdout.write(JSON.stringify(N,null,2)+`
`);return}catch{}}finally{await G.close()}let T=(await IU.promises.readFile(z,{encoding:"utf8"})).trim();if(await IU.promises.unlink(z),!(/^[A-Za-z0-9+/]+={0,2}$/.test(T)&&T.length%4===0))I.stderr.write(`Error: Input neither valid Cryptit binary nor Base-64 text
`),I.exit(1);let H=Buffer.from(T,"base64"),R=await q(new Uint8Array(H));I.stdout.write(JSON.stringify(R,null,2)+`
`);return}let Y=Buffer.from(U,"utf8"),Q=Y.toString("utf8").trim(),X=/^[A-Za-z0-9+/]+={0,2}$/.test(Q)&&Q.length%4===0;try{if(X){let z=Buffer.from(Q,"base64"),G=await q(new Uint8Array(z));I.stdout.write(JSON.stringify(G,null,2)+`
`)}else{let z=await q(new Uint8Array(Y));I.stdout.write(JSON.stringify(z,null,2)+`
`)}}catch(z){let G=z instanceof Error?z.message:String(z);I.stderr.write(`Error: ${G}
`),I.exit(1)}});n.command("encrypt <src>").description("Encrypt file; use - for STDIN, --out - for STDOUT").option("-p, --pass <passphrase>","passphrase (prompt if omitted)").option("-o, --out <file>","output file (default STDOUT)","-").action(async(U,$)=>{if(U!=="-"&&!r.existsSync(U))I.stderr.write(`Error: input file not found: ${U}
`),I.exit(1);let q=n.opts(),J=vU({difficulty:q.difficulty,saltStrength:q.saltStrength,chunkSize:q.chunkSize,verbose:q.verbose,scheme:q.scheme}),Z=q.pass??(I.stdin.isTTY?await tU():(()=>{I.stderr.write(`Use --pass when piping via STDIN
`),I.exit(1)})());try{L0($.out)}catch(R){I.stderr.write(`Error: ${R.message}
`),I.exit(1)}let Y=U==="-"?I.stdin:FU.createReadStream(U),Q=$.out==="-"?I.stdout:FU.createWriteStream($.out),{header:X,writable:z,readable:G}=await J.createEncryptionStream(Z),T=_0(Y),K=M0(Q),H=K.getWriter();await H.write(X),H.releaseLock(),await Promise.all([T.pipeTo(z),G.pipeTo(K)])});n.command("decrypt <src>").description("Decrypt file; use - for STDIN, --out - for STDOUT").option("-p, --pass <passphrase>","passphrase (prompt if omitted)").option("-o, --out <file>","output file (default STDOUT)","-").option("--legacy","Enable text decryption of version < 1.0.0",!1).action(async(U,$)=>{if(U!=="-"&&!r.existsSync(U))I.stderr.write(`Error: input file not found: ${U}
`),I.exit(1);let q=n.opts(),J=vU({difficulty:q.difficulty,saltStrength:q.saltStrength,chunkSize:q.chunkSize,verbose:q.verbose,scheme:q.scheme,acceptUnauthenticatedHeader:$.legacy});try{L0($.out)}catch(T){I.stderr.write(`Error: ${T.message}
`),I.exit(1)}let Z=q.pass??await tU(),Y=U==="-"?I.stdin:FU.createReadStream(U),Q=$.out==="-"?I.stdout:FU.createWriteStream($.out),X=_0(Y),z=M0(Q),G=await J.createDecryptionStream(Z);await Promise.all([X.pipeTo(G.writable),G.readable.pipeTo(z)])});n.command("encrypt-text [text]").description("Encrypt plaintext; omit arg to read from STDIN").option("-p, --pass <passphrase>","passphrase (prompt if omitted)").action(async(U)=>{let $=n.opts(),q=vU({difficulty:$.difficulty,saltStrength:$.saltStrength,verbose:$.verbose,scheme:$.scheme}),J=$.pass??(I.stdin.isTTY?await tU():(()=>{I.stderr.write(`Use --pass when piping via STDIN
`),I.exit(1)})()),Z=U??await N$(),Y=await q.encryptText(Z,J);I.stdout.write(Y.base64+`
`)});n.command("decrypt-text [b64]").description("Decrypt Base64 ciphertext; omit arg to read from STDIN").option("-p, --pass <passphrase>","passphrase (prompt if omitted)").option("--legacy","Enable text decryption of version < 1.0.0",!1).action(async(U,$)=>{let q=n.opts(),J=vU({difficulty:q.difficulty,saltStrength:q.saltStrength,verbose:q.verbose,scheme:q.scheme,acceptUnauthenticatedHeader:$.legacy}),Z=q.pass??await tU(),Y=U??(await N$()).trim();if(!/^[A-Za-z0-9+/]+={0,2}$/.test(Y))I.stderr.write(`Error: ciphertext does not look like Base64
`),I.exit(1);let Q=await J.decryptText(Y,Z);I.stdout.write(Q.text+`
`)});n.command("fake-data <length>").description("Emit a valid Cryptit header followed by <length> random bytes").option("-o, --out <file>","output file (default STDOUT)","-").option("--base64","encode output as Base64 text (adds trailing newline)").action(async(U,$)=>{let q=Number(U);if(!Number.isInteger(q)||q<0)I.stderr.write(`Error: <length> must be a non-negative integer
`),I.exit(1);let J=n.opts(),Z=vU({difficulty:J.difficulty,saltStrength:J.saltStrength,chunkSize:J.chunkSize,verbose:J.verbose,scheme:J.scheme});try{L0($.out)}catch(X){I.stderr.write(`Error: ${X.message}
`),I.exit(1)}let Y=Z.generateFakeData(q),Q=Buffer.from(Y);if($.base64){let X=Q.toString("base64")+`
`;if($.out==="-")I.stdout.write(X);else await IU.promises.writeFile($.out,X,{encoding:"utf8"});return}if($.out==="-")I.stdout.write(Q);else await IU.promises.writeFile($.out,Q)});if(process.argv.length<=2)n.outputHelp(),process.exit(1);n.parse();

//# debugId=768AAC6BFBAF741D64756E2164756E21
