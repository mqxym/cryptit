#!/usr/bin/env node
var B$=Object.create;var{getPrototypeOf:j$,defineProperty:L0,getOwnPropertyNames:S$}=Object;var F$=Object.prototype.hasOwnProperty;var IU=(U,$,q)=>{q=U!=null?B$(j$(U)):{};let J=$||!U||!U.__esModule?L0(q,"default",{value:U,enumerable:!0}):q;for(let Z of S$(U))if(!F$.call(J,Z))L0(J,Z,{get:()=>U[Z],enumerable:!0});return J};var BU=(U,$)=>()=>($||U(($={exports:{}}).exports,$),$.exports);var yU=BU((U0)=>{class eU extends Error{constructor(U,$,q){super(q);Error.captureStackTrace(this,this.constructor),this.name=this.constructor.name,this.code=$,this.exitCode=U,this.nestedError=void 0}}class D0 extends eU{constructor(U){super(1,"commander.invalidArgument",U);Error.captureStackTrace(this,this.constructor),this.name=this.constructor.name}}U0.CommanderError=eU;U0.InvalidArgumentError=D0});var mU=BU(($0)=>{var{InvalidArgumentError:_$}=yU();class O0{constructor(U,$){switch(this.description=$||"",this.variadic=!1,this.parseArg=void 0,this.defaultValue=void 0,this.defaultValueDescription=void 0,this.argChoices=void 0,U[0]){case"<":this.required=!0,this._name=U.slice(1,-1);break;case"[":this.required=!1,this._name=U.slice(1,-1);break;default:this.required=!0,this._name=U;break}if(this._name.endsWith("..."))this.variadic=!0,this._name=this._name.slice(0,-3)}name(){return this._name}_collectValue(U,$){if($===this.defaultValue||!Array.isArray($))return[U];return $.push(U),$}default(U,$){return this.defaultValue=U,this.defaultValueDescription=$,this}argParser(U){return this.parseArg=U,this}choices(U){return this.argChoices=U.slice(),this.parseArg=($,q)=>{if(!this.argChoices.includes($))throw new _$(`Allowed choices are ${this.argChoices.join(", ")}.`);if(this.variadic)return this._collectValue($,q);return $},this}argRequired(){return this.required=!0,this}argOptional(){return this.required=!1,this}}function M$(U){let $=U.name()+(U.variadic===!0?"...":"");return U.required?"<"+$+">":"["+$+"]"}$0.Argument=O0;$0.humanReadableArgName=M$});var J0=BU((q0)=>{var{humanReadableArgName:w$}=mU();class E0{constructor(){this.helpWidth=void 0,this.minWidthToWrap=40,this.sortSubcommands=!1,this.sortOptions=!1,this.showGlobalOptions=!1}prepareContext(U){this.helpWidth=this.helpWidth??U.helpWidth??80}visibleCommands(U){let $=U.commands.filter((J)=>!J._hidden),q=U._getHelpCommand();if(q&&!q._hidden)$.push(q);if(this.sortSubcommands)$.sort((J,Z)=>{return J.name().localeCompare(Z.name())});return $}compareOptions(U,$){let q=(J)=>{return J.short?J.short.replace(/^-/,""):J.long.replace(/^--/,"")};return q(U).localeCompare(q($))}visibleOptions(U){let $=U.options.filter((J)=>!J.hidden),q=U._getHelpOption();if(q&&!q.hidden){let J=q.short&&U._findOption(q.short),Z=q.long&&U._findOption(q.long);if(!J&&!Z)$.push(q);else if(q.long&&!Z)$.push(U.createOption(q.long,q.description));else if(q.short&&!J)$.push(U.createOption(q.short,q.description))}if(this.sortOptions)$.sort(this.compareOptions);return $}visibleGlobalOptions(U){if(!this.showGlobalOptions)return[];let $=[];for(let q=U.parent;q;q=q.parent){let J=q.options.filter((Z)=>!Z.hidden);$.push(...J)}if(this.sortOptions)$.sort(this.compareOptions);return $}visibleArguments(U){if(U._argsDescription)U.registeredArguments.forEach(($)=>{$.description=$.description||U._argsDescription[$.name()]||""});if(U.registeredArguments.find(($)=>$.description))return U.registeredArguments;return[]}subcommandTerm(U){let $=U.registeredArguments.map((q)=>w$(q)).join(" ");return U._name+(U._aliases[0]?"|"+U._aliases[0]:"")+(U.options.length?" [options]":"")+($?" "+$:"")}optionTerm(U){return U.flags}argumentTerm(U){return U.name()}longestSubcommandTermLength(U,$){return $.visibleCommands(U).reduce((q,J)=>{return Math.max(q,this.displayWidth($.styleSubcommandTerm($.subcommandTerm(J))))},0)}longestOptionTermLength(U,$){return $.visibleOptions(U).reduce((q,J)=>{return Math.max(q,this.displayWidth($.styleOptionTerm($.optionTerm(J))))},0)}longestGlobalOptionTermLength(U,$){return $.visibleGlobalOptions(U).reduce((q,J)=>{return Math.max(q,this.displayWidth($.styleOptionTerm($.optionTerm(J))))},0)}longestArgumentTermLength(U,$){return $.visibleArguments(U).reduce((q,J)=>{return Math.max(q,this.displayWidth($.styleArgumentTerm($.argumentTerm(J))))},0)}commandUsage(U){let $=U._name;if(U._aliases[0])$=$+"|"+U._aliases[0];let q="";for(let J=U.parent;J;J=J.parent)q=J.name()+" "+q;return q+$+" "+U.usage()}commandDescription(U){return U.description()}subcommandDescription(U){return U.summary()||U.description()}optionDescription(U){let $=[];if(U.argChoices)$.push(`choices: ${U.argChoices.map((q)=>JSON.stringify(q)).join(", ")}`);if(U.defaultValue!==void 0){if(U.required||U.optional||U.isBoolean()&&typeof U.defaultValue==="boolean")$.push(`default: ${U.defaultValueDescription||JSON.stringify(U.defaultValue)}`)}if(U.presetArg!==void 0&&U.optional)$.push(`preset: ${JSON.stringify(U.presetArg)}`);if(U.envVar!==void 0)$.push(`env: ${U.envVar}`);if($.length>0){let q=`(${$.join(", ")})`;if(U.description)return`${U.description} ${q}`;return q}return U.description}argumentDescription(U){let $=[];if(U.argChoices)$.push(`choices: ${U.argChoices.map((q)=>JSON.stringify(q)).join(", ")}`);if(U.defaultValue!==void 0)$.push(`default: ${U.defaultValueDescription||JSON.stringify(U.defaultValue)}`);if($.length>0){let q=`(${$.join(", ")})`;if(U.description)return`${U.description} ${q}`;return q}return U.description}formatItemList(U,$,q){if($.length===0)return[];return[q.styleTitle(U),...$,""]}groupItems(U,$,q){let J=new Map;return U.forEach((Z)=>{let Y=q(Z);if(!J.has(Y))J.set(Y,[])}),$.forEach((Z)=>{let Y=q(Z);if(!J.has(Y))J.set(Y,[]);J.get(Y).push(Z)}),J}formatHelp(U,$){let q=$.padWidth(U,$),J=$.helpWidth??80;function Z(K,T){return $.formatItem(K,q,T,$)}let Y=[`${$.styleTitle("Usage:")} ${$.styleUsage($.commandUsage(U))}`,""],Q=$.commandDescription(U);if(Q.length>0)Y=Y.concat([$.boxWrap($.styleCommandDescription(Q),J),""]);let z=$.visibleArguments(U).map((K)=>{return Z($.styleArgumentTerm($.argumentTerm(K)),$.styleArgumentDescription($.argumentDescription(K)))});if(Y=Y.concat(this.formatItemList("Arguments:",z,$)),this.groupItems(U.options,$.visibleOptions(U),(K)=>K.helpGroupHeading??"Options:").forEach((K,T)=>{let R=K.map((H)=>{return Z($.styleOptionTerm($.optionTerm(H)),$.styleOptionDescription($.optionDescription(H)))});Y=Y.concat(this.formatItemList(T,R,$))}),$.showGlobalOptions){let K=$.visibleGlobalOptions(U).map((T)=>{return Z($.styleOptionTerm($.optionTerm(T)),$.styleOptionDescription($.optionDescription(T)))});Y=Y.concat(this.formatItemList("Global Options:",K,$))}return this.groupItems(U.commands,$.visibleCommands(U),(K)=>K.helpGroup()||"Commands:").forEach((K,T)=>{let R=K.map((H)=>{return Z($.styleSubcommandTerm($.subcommandTerm(H)),$.styleSubcommandDescription($.subcommandDescription(H)))});Y=Y.concat(this.formatItemList(T,R,$))}),Y.join(`
`)}displayWidth(U){return A0(U).length}styleTitle(U){return U}styleUsage(U){return U.split(" ").map(($)=>{if($==="[options]")return this.styleOptionText($);if($==="[command]")return this.styleSubcommandText($);if($[0]==="["||$[0]==="<")return this.styleArgumentText($);return this.styleCommandText($)}).join(" ")}styleCommandDescription(U){return this.styleDescriptionText(U)}styleOptionDescription(U){return this.styleDescriptionText(U)}styleSubcommandDescription(U){return this.styleDescriptionText(U)}styleArgumentDescription(U){return this.styleDescriptionText(U)}styleDescriptionText(U){return U}styleOptionTerm(U){return this.styleOptionText(U)}styleSubcommandTerm(U){return U.split(" ").map(($)=>{if($==="[options]")return this.styleOptionText($);if($[0]==="["||$[0]==="<")return this.styleArgumentText($);return this.styleSubcommandText($)}).join(" ")}styleArgumentTerm(U){return this.styleArgumentText(U)}styleOptionText(U){return U}styleArgumentText(U){return U}styleSubcommandText(U){return U}styleCommandText(U){return U}padWidth(U,$){return Math.max($.longestOptionTermLength(U,$),$.longestGlobalOptionTermLength(U,$),$.longestSubcommandTermLength(U,$),$.longestArgumentTermLength(U,$))}preformatted(U){return/\n[^\S\r\n]/.test(U)}formatItem(U,$,q,J){let Y=" ".repeat(2);if(!q)return Y+U;let Q=U.padEnd($+U.length-J.displayWidth(U)),z=2,G=(this.helpWidth??80)-$-z-2,K;if(G<this.minWidthToWrap||J.preformatted(q))K=q;else K=J.boxWrap(q,G).replace(/\n/g,`
`+" ".repeat($+z));return Y+Q+" ".repeat(z)+K.replace(/\n/g,`
${Y}`)}boxWrap(U,$){if($<this.minWidthToWrap)return U;let q=U.split(/\r\n|\n/),J=/[\s]*[^\s]+/g,Z=[];return q.forEach((Y)=>{let Q=Y.match(J);if(Q===null){Z.push("");return}let z=[Q.shift()],X=this.displayWidth(z[0]);Q.forEach((G)=>{let K=this.displayWidth(G);if(X+K<=$){z.push(G),X+=K;return}Z.push(z.join(""));let T=G.trimStart();z=[T],X=this.displayWidth(T)}),Z.push(z.join(""))}),Z.join(`
`)}}function A0(U){let $=/\x1b\[\d*(;\d*)*m/g;return U.replace($,"")}q0.Help=E0;q0.stripColor=A0});var Y0=BU((Z0)=>{var{InvalidArgumentError:P$}=yU();class k0{constructor(U,$){this.flags=U,this.description=$||"",this.required=U.includes("<"),this.optional=U.includes("["),this.variadic=/\w\.\.\.[>\]]$/.test(U),this.mandatory=!1;let q=L$(U);if(this.short=q.shortFlag,this.long=q.longFlag,this.negate=!1,this.long)this.negate=this.long.startsWith("--no-");this.defaultValue=void 0,this.defaultValueDescription=void 0,this.presetArg=void 0,this.envVar=void 0,this.parseArg=void 0,this.hidden=!1,this.argChoices=void 0,this.conflictsWith=[],this.implied=void 0,this.helpGroupHeading=void 0}default(U,$){return this.defaultValue=U,this.defaultValueDescription=$,this}preset(U){return this.presetArg=U,this}conflicts(U){return this.conflictsWith=this.conflictsWith.concat(U),this}implies(U){let $=U;if(typeof U==="string")$={[U]:!0};return this.implied=Object.assign(this.implied||{},$),this}env(U){return this.envVar=U,this}argParser(U){return this.parseArg=U,this}makeOptionMandatory(U=!0){return this.mandatory=!!U,this}hideHelp(U=!0){return this.hidden=!!U,this}_collectValue(U,$){if($===this.defaultValue||!Array.isArray($))return[U];return $.push(U),$}choices(U){return this.argChoices=U.slice(),this.parseArg=($,q)=>{if(!this.argChoices.includes($))throw new P$(`Allowed choices are ${this.argChoices.join(", ")}.`);if(this.variadic)return this._collectValue($,q);return $},this}name(){if(this.long)return this.long.replace(/^--/,"");return this.short.replace(/^-/,"")}attributeName(){if(this.negate)return C0(this.name().replace(/^no-/,""));return C0(this.name())}helpGroup(U){return this.helpGroupHeading=U,this}is(U){return this.short===U||this.long===U}isBoolean(){return!this.required&&!this.optional&&!this.negate}}class v0{constructor(U){this.positiveOptions=new Map,this.negativeOptions=new Map,this.dualOptions=new Set,U.forEach(($)=>{if($.negate)this.negativeOptions.set($.attributeName(),$);else this.positiveOptions.set($.attributeName(),$)}),this.negativeOptions.forEach(($,q)=>{if(this.positiveOptions.has(q))this.dualOptions.add(q)})}valueFromOption(U,$){let q=$.attributeName();if(!this.dualOptions.has(q))return!0;let J=this.negativeOptions.get(q).presetArg,Z=J!==void 0?J:!1;return $.negate===(Z===U)}}function C0(U){return U.split("-").reduce(($,q)=>{return $+q[0].toUpperCase()+q.slice(1)})}function L$(U){let $,q,J=/^-[^-]$/,Z=/^--[^-]/,Y=U.split(/[ |,]+/).concat("guard");if(J.test(Y[0]))$=Y.shift();if(Z.test(Y[0]))q=Y.shift();if(!$&&J.test(Y[0]))$=Y.shift();if(!$&&Z.test(Y[0]))$=q,q=Y.shift();if(Y[0].startsWith("-")){let Q=Y[0],z=`option creation failed due to '${Q}' in option flags '${U}'`;if(/^-[^-][^-]/.test(Q))throw Error(`${z}
- a short flag is a single dash and a single character
  - either use a single dash and a single character (for a short flag)
  - or use a double dash for a long option (and can have two, like '--ws, --workspace')`);if(J.test(Q))throw Error(`${z}
- too many short flags`);if(Z.test(Q))throw Error(`${z}
- too many long flags`);throw Error(`${z}
- unrecognised flag format`)}if($===void 0&&q===void 0)throw Error(`option creation failed due to no flags found in '${U}'.`);return{shortFlag:$,longFlag:q}}Z0.Option=k0;Z0.DualOptions=v0});var f0=BU((y0)=>{function D$(U,$){if(Math.abs(U.length-$.length)>3)return Math.max(U.length,$.length);let q=[];for(let J=0;J<=U.length;J++)q[J]=[J];for(let J=0;J<=$.length;J++)q[0][J]=J;for(let J=1;J<=$.length;J++)for(let Z=1;Z<=U.length;Z++){let Y=1;if(U[Z-1]===$[J-1])Y=0;else Y=1;if(q[Z][J]=Math.min(q[Z-1][J]+1,q[Z][J-1]+1,q[Z-1][J-1]+Y),Z>1&&J>1&&U[Z-1]===$[J-2]&&U[Z-2]===$[J-1])q[Z][J]=Math.min(q[Z][J],q[Z-2][J-2]+1)}return q[U.length][$.length]}function O$(U,$){if(!$||$.length===0)return"";$=Array.from(new Set($));let q=U.startsWith("--");if(q)U=U.slice(2),$=$.map((Q)=>Q.slice(2));let J=[],Z=3,Y=0.4;if($.forEach((Q)=>{if(Q.length<=1)return;let z=D$(U,Q),X=Math.max(U.length,Q.length);if((X-z)/X>Y){if(z<Z)Z=z,J=[Q];else if(z===Z)J.push(Q)}}),J.sort((Q,z)=>Q.localeCompare(z)),q)J=J.map((Q)=>`--${Q}`);if(J.length>1)return`
(Did you mean one of ${J.join(", ")}?)`;if(J.length===1)return`
(Did you mean ${J[0]}?)`;return""}y0.suggestSimilar=O$});var h0=BU((K0)=>{var E$=require("node:events").EventEmitter,Q0=require("node:child_process"),QU=require("node:path"),uU=require("node:fs"),M=require("node:process"),{Argument:A$,humanReadableArgName:C$}=mU(),{CommanderError:z0}=yU(),{Help:k$,stripColor:v$}=J0(),{Option:b0,DualOptions:y$}=Y0(),{suggestSimilar:x0}=f0();class G0 extends E${constructor(U){super();this.commands=[],this.options=[],this.parent=null,this._allowUnknownOption=!1,this._allowExcessArguments=!1,this.registeredArguments=[],this._args=this.registeredArguments,this.args=[],this.rawArgs=[],this.processedArgs=[],this._scriptPath=null,this._name=U||"",this._optionValues={},this._optionValueSources={},this._storeOptionsAsProperties=!1,this._actionHandler=null,this._executableHandler=!1,this._executableFile=null,this._executableDir=null,this._defaultCommandName=null,this._exitCallback=null,this._aliases=[],this._combineFlagAndOptionalValue=!0,this._description="",this._summary="",this._argsDescription=void 0,this._enablePositionalOptions=!1,this._passThroughOptions=!1,this._lifeCycleHooks={},this._showHelpAfterError=!1,this._showSuggestionAfterError=!0,this._savedState=null,this._outputConfiguration={writeOut:($)=>M.stdout.write($),writeErr:($)=>M.stderr.write($),outputError:($,q)=>q($),getOutHelpWidth:()=>M.stdout.isTTY?M.stdout.columns:void 0,getErrHelpWidth:()=>M.stderr.isTTY?M.stderr.columns:void 0,getOutHasColors:()=>X0()??(M.stdout.isTTY&&M.stdout.hasColors?.()),getErrHasColors:()=>X0()??(M.stderr.isTTY&&M.stderr.hasColors?.()),stripColor:($)=>v$($)},this._hidden=!1,this._helpOption=void 0,this._addImplicitHelpCommand=void 0,this._helpCommand=void 0,this._helpConfiguration={},this._helpGroupHeading=void 0,this._defaultCommandGroup=void 0,this._defaultOptionGroup=void 0}copyInheritedSettings(U){return this._outputConfiguration=U._outputConfiguration,this._helpOption=U._helpOption,this._helpCommand=U._helpCommand,this._helpConfiguration=U._helpConfiguration,this._exitCallback=U._exitCallback,this._storeOptionsAsProperties=U._storeOptionsAsProperties,this._combineFlagAndOptionalValue=U._combineFlagAndOptionalValue,this._allowExcessArguments=U._allowExcessArguments,this._enablePositionalOptions=U._enablePositionalOptions,this._showHelpAfterError=U._showHelpAfterError,this._showSuggestionAfterError=U._showSuggestionAfterError,this}_getCommandAndAncestors(){let U=[];for(let $=this;$;$=$.parent)U.push($);return U}command(U,$,q){let J=$,Z=q;if(typeof J==="object"&&J!==null)Z=J,J=null;Z=Z||{};let[,Y,Q]=U.match(/([^ ]+) *(.*)/),z=this.createCommand(Y);if(J)z.description(J),z._executableHandler=!0;if(Z.isDefault)this._defaultCommandName=z._name;if(z._hidden=!!(Z.noHelp||Z.hidden),z._executableFile=Z.executableFile||null,Q)z.arguments(Q);if(this._registerCommand(z),z.parent=this,z.copyInheritedSettings(this),J)return this;return z}createCommand(U){return new G0(U)}createHelp(){return Object.assign(new k$,this.configureHelp())}configureHelp(U){if(U===void 0)return this._helpConfiguration;return this._helpConfiguration=U,this}configureOutput(U){if(U===void 0)return this._outputConfiguration;return this._outputConfiguration={...this._outputConfiguration,...U},this}showHelpAfterError(U=!0){if(typeof U!=="string")U=!!U;return this._showHelpAfterError=U,this}showSuggestionAfterError(U=!0){return this._showSuggestionAfterError=!!U,this}addCommand(U,$){if(!U._name)throw Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);if($=$||{},$.isDefault)this._defaultCommandName=U._name;if($.noHelp||$.hidden)U._hidden=!0;return this._registerCommand(U),U.parent=this,U._checkForBrokenPassThrough(),this}createArgument(U,$){return new A$(U,$)}argument(U,$,q,J){let Z=this.createArgument(U,$);if(typeof q==="function")Z.default(J).argParser(q);else Z.default(q);return this.addArgument(Z),this}arguments(U){return U.trim().split(/ +/).forEach(($)=>{this.argument($)}),this}addArgument(U){let $=this.registeredArguments.slice(-1)[0];if($?.variadic)throw Error(`only the last argument can be variadic '${$.name()}'`);if(U.required&&U.defaultValue!==void 0&&U.parseArg===void 0)throw Error(`a default value for a required argument is never used: '${U.name()}'`);return this.registeredArguments.push(U),this}helpCommand(U,$){if(typeof U==="boolean"){if(this._addImplicitHelpCommand=U,U&&this._defaultCommandGroup)this._initCommandGroup(this._getHelpCommand());return this}let q=U??"help [command]",[,J,Z]=q.match(/([^ ]+) *(.*)/),Y=$??"display help for command",Q=this.createCommand(J);if(Q.helpOption(!1),Z)Q.arguments(Z);if(Y)Q.description(Y);if(this._addImplicitHelpCommand=!0,this._helpCommand=Q,U||$)this._initCommandGroup(Q);return this}addHelpCommand(U,$){if(typeof U!=="object")return this.helpCommand(U,$),this;return this._addImplicitHelpCommand=!0,this._helpCommand=U,this._initCommandGroup(U),this}_getHelpCommand(){if(this._addImplicitHelpCommand??(this.commands.length&&!this._actionHandler&&!this._findCommand("help"))){if(this._helpCommand===void 0)this.helpCommand(void 0,void 0);return this._helpCommand}return null}hook(U,$){let q=["preSubcommand","preAction","postAction"];if(!q.includes(U))throw Error(`Unexpected value for event passed to hook : '${U}'.
Expecting one of '${q.join("', '")}'`);if(this._lifeCycleHooks[U])this._lifeCycleHooks[U].push($);else this._lifeCycleHooks[U]=[$];return this}exitOverride(U){if(U)this._exitCallback=U;else this._exitCallback=($)=>{if($.code!=="commander.executeSubCommandAsync")throw $};return this}_exit(U,$,q){if(this._exitCallback)this._exitCallback(new z0(U,$,q));M.exit(U)}action(U){let $=(q)=>{let J=this.registeredArguments.length,Z=q.slice(0,J);if(this._storeOptionsAsProperties)Z[J]=this;else Z[J]=this.opts();return Z.push(this),U.apply(this,Z)};return this._actionHandler=$,this}createOption(U,$){return new b0(U,$)}_callParseArg(U,$,q,J){try{return U.parseArg($,q)}catch(Z){if(Z.code==="commander.invalidArgument"){let Y=`${J} ${Z.message}`;this.error(Y,{exitCode:Z.exitCode,code:Z.code})}throw Z}}_registerOption(U){let $=U.short&&this._findOption(U.short)||U.long&&this._findOption(U.long);if($){let q=U.long&&this._findOption(U.long)?U.long:U.short;throw Error(`Cannot add option '${U.flags}'${this._name&&` to command '${this._name}'`} due to conflicting flag '${q}'
-  already used by option '${$.flags}'`)}this._initOptionGroup(U),this.options.push(U)}_registerCommand(U){let $=(J)=>{return[J.name()].concat(J.aliases())},q=$(U).find((J)=>this._findCommand(J));if(q){let J=$(this._findCommand(q)).join("|"),Z=$(U).join("|");throw Error(`cannot add command '${Z}' as already have command '${J}'`)}this._initCommandGroup(U),this.commands.push(U)}addOption(U){this._registerOption(U);let $=U.name(),q=U.attributeName();if(U.negate){let Z=U.long.replace(/^--no-/,"--");if(!this._findOption(Z))this.setOptionValueWithSource(q,U.defaultValue===void 0?!0:U.defaultValue,"default")}else if(U.defaultValue!==void 0)this.setOptionValueWithSource(q,U.defaultValue,"default");let J=(Z,Y,Q)=>{if(Z==null&&U.presetArg!==void 0)Z=U.presetArg;let z=this.getOptionValue(q);if(Z!==null&&U.parseArg)Z=this._callParseArg(U,Z,z,Y);else if(Z!==null&&U.variadic)Z=U._collectValue(Z,z);if(Z==null)if(U.negate)Z=!1;else if(U.isBoolean()||U.optional)Z=!0;else Z="";this.setOptionValueWithSource(q,Z,Q)};if(this.on("option:"+$,(Z)=>{let Y=`error: option '${U.flags}' argument '${Z}' is invalid.`;J(Z,Y,"cli")}),U.envVar)this.on("optionEnv:"+$,(Z)=>{let Y=`error: option '${U.flags}' value '${Z}' from env '${U.envVar}' is invalid.`;J(Z,Y,"env")});return this}_optionEx(U,$,q,J,Z){if(typeof $==="object"&&$ instanceof b0)throw Error("To add an Option object use addOption() instead of option() or requiredOption()");let Y=this.createOption($,q);if(Y.makeOptionMandatory(!!U.mandatory),typeof J==="function")Y.default(Z).argParser(J);else if(J instanceof RegExp){let Q=J;J=(z,X)=>{let G=Q.exec(z);return G?G[0]:X},Y.default(Z).argParser(J)}else Y.default(J);return this.addOption(Y)}option(U,$,q,J){return this._optionEx({},U,$,q,J)}requiredOption(U,$,q,J){return this._optionEx({mandatory:!0},U,$,q,J)}combineFlagAndOptionalValue(U=!0){return this._combineFlagAndOptionalValue=!!U,this}allowUnknownOption(U=!0){return this._allowUnknownOption=!!U,this}allowExcessArguments(U=!0){return this._allowExcessArguments=!!U,this}enablePositionalOptions(U=!0){return this._enablePositionalOptions=!!U,this}passThroughOptions(U=!0){return this._passThroughOptions=!!U,this._checkForBrokenPassThrough(),this}_checkForBrokenPassThrough(){if(this.parent&&this._passThroughOptions&&!this.parent._enablePositionalOptions)throw Error(`passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`)}storeOptionsAsProperties(U=!0){if(this.options.length)throw Error("call .storeOptionsAsProperties() before adding options");if(Object.keys(this._optionValues).length)throw Error("call .storeOptionsAsProperties() before setting option values");return this._storeOptionsAsProperties=!!U,this}getOptionValue(U){if(this._storeOptionsAsProperties)return this[U];return this._optionValues[U]}setOptionValue(U,$){return this.setOptionValueWithSource(U,$,void 0)}setOptionValueWithSource(U,$,q){if(this._storeOptionsAsProperties)this[U]=$;else this._optionValues[U]=$;return this._optionValueSources[U]=q,this}getOptionValueSource(U){return this._optionValueSources[U]}getOptionValueSourceWithGlobals(U){let $;return this._getCommandAndAncestors().forEach((q)=>{if(q.getOptionValueSource(U)!==void 0)$=q.getOptionValueSource(U)}),$}_prepareUserArgs(U,$){if(U!==void 0&&!Array.isArray(U))throw Error("first parameter to parse must be array or undefined");if($=$||{},U===void 0&&$.from===void 0){if(M.versions?.electron)$.from="electron";let J=M.execArgv??[];if(J.includes("-e")||J.includes("--eval")||J.includes("-p")||J.includes("--print"))$.from="eval"}if(U===void 0)U=M.argv;this.rawArgs=U.slice();let q;switch($.from){case void 0:case"node":this._scriptPath=U[1],q=U.slice(2);break;case"electron":if(M.defaultApp)this._scriptPath=U[1],q=U.slice(2);else q=U.slice(1);break;case"user":q=U.slice(0);break;case"eval":q=U.slice(1);break;default:throw Error(`unexpected parse option { from: '${$.from}' }`)}if(!this._name&&this._scriptPath)this.nameFromFilename(this._scriptPath);return this._name=this._name||"program",q}parse(U,$){this._prepareForParse();let q=this._prepareUserArgs(U,$);return this._parseCommand([],q),this}async parseAsync(U,$){this._prepareForParse();let q=this._prepareUserArgs(U,$);return await this._parseCommand([],q),this}_prepareForParse(){if(this._savedState===null)this.saveStateBeforeParse();else this.restoreStateBeforeParse()}saveStateBeforeParse(){this._savedState={_name:this._name,_optionValues:{...this._optionValues},_optionValueSources:{...this._optionValueSources}}}restoreStateBeforeParse(){if(this._storeOptionsAsProperties)throw Error(`Can not call parse again when storeOptionsAsProperties is true.
- either make a new Command for each call to parse, or stop storing options as properties`);this._name=this._savedState._name,this._scriptPath=null,this.rawArgs=[],this._optionValues={...this._savedState._optionValues},this._optionValueSources={...this._savedState._optionValueSources},this.args=[],this.processedArgs=[]}_checkForMissingExecutable(U,$,q){if(uU.existsSync(U))return;let J=$?`searched for local subcommand relative to directory '${$}'`:"no directory for search for local subcommand, use .executableDir() to supply a custom directory",Z=`'${U}' does not exist
 - if '${q}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${J}`;throw Error(Z)}_executeSubCommand(U,$){$=$.slice();let q=!1,J=[".js",".ts",".tsx",".mjs",".cjs"];function Z(G,K){let T=QU.resolve(G,K);if(uU.existsSync(T))return T;if(J.includes(QU.extname(K)))return;let R=J.find((H)=>uU.existsSync(`${T}${H}`));if(R)return`${T}${R}`;return}this._checkForMissingMandatoryOptions(),this._checkForConflictingOptions();let Y=U._executableFile||`${this._name}-${U._name}`,Q=this._executableDir||"";if(this._scriptPath){let G;try{G=uU.realpathSync(this._scriptPath)}catch{G=this._scriptPath}Q=QU.resolve(QU.dirname(G),Q)}if(Q){let G=Z(Q,Y);if(!G&&!U._executableFile&&this._scriptPath){let K=QU.basename(this._scriptPath,QU.extname(this._scriptPath));if(K!==this._name)G=Z(Q,`${K}-${U._name}`)}Y=G||Y}q=J.includes(QU.extname(Y));let z;if(M.platform!=="win32")if(q)$.unshift(Y),$=g0(M.execArgv).concat($),z=Q0.spawn(M.argv[0],$,{stdio:"inherit"});else z=Q0.spawn(Y,$,{stdio:"inherit"});else this._checkForMissingExecutable(Y,Q,U._name),$.unshift(Y),$=g0(M.execArgv).concat($),z=Q0.spawn(M.execPath,$,{stdio:"inherit"});if(!z.killed)["SIGUSR1","SIGUSR2","SIGTERM","SIGINT","SIGHUP"].forEach((K)=>{M.on(K,()=>{if(z.killed===!1&&z.exitCode===null)z.kill(K)})});let X=this._exitCallback;z.on("close",(G)=>{if(G=G??1,!X)M.exit(G);else X(new z0(G,"commander.executeSubCommandAsync","(close)"))}),z.on("error",(G)=>{if(G.code==="ENOENT")this._checkForMissingExecutable(Y,Q,U._name);else if(G.code==="EACCES")throw Error(`'${Y}' not executable`);if(!X)M.exit(1);else{let K=new z0(1,"commander.executeSubCommandAsync","(error)");K.nestedError=G,X(K)}}),this.runningCommand=z}_dispatchSubcommand(U,$,q){let J=this._findCommand(U);if(!J)this.help({error:!0});J._prepareForParse();let Z;return Z=this._chainOrCallSubCommandHook(Z,J,"preSubcommand"),Z=this._chainOrCall(Z,()=>{if(J._executableHandler)this._executeSubCommand(J,$.concat(q));else return J._parseCommand($,q)}),Z}_dispatchHelpCommand(U){if(!U)this.help();let $=this._findCommand(U);if($&&!$._executableHandler)$.help();return this._dispatchSubcommand(U,[],[this._getHelpOption()?.long??this._getHelpOption()?.short??"--help"])}_checkNumberOfArguments(){if(this.registeredArguments.forEach((U,$)=>{if(U.required&&this.args[$]==null)this.missingArgument(U.name())}),this.registeredArguments.length>0&&this.registeredArguments[this.registeredArguments.length-1].variadic)return;if(this.args.length>this.registeredArguments.length)this._excessArguments(this.args)}_processArguments(){let U=(q,J,Z)=>{let Y=J;if(J!==null&&q.parseArg){let Q=`error: command-argument value '${J}' is invalid for argument '${q.name()}'.`;Y=this._callParseArg(q,J,Z,Q)}return Y};this._checkNumberOfArguments();let $=[];this.registeredArguments.forEach((q,J)=>{let Z=q.defaultValue;if(q.variadic){if(J<this.args.length){if(Z=this.args.slice(J),q.parseArg)Z=Z.reduce((Y,Q)=>{return U(q,Q,Y)},q.defaultValue)}else if(Z===void 0)Z=[]}else if(J<this.args.length){if(Z=this.args[J],q.parseArg)Z=U(q,Z,q.defaultValue)}$[J]=Z}),this.processedArgs=$}_chainOrCall(U,$){if(U?.then&&typeof U.then==="function")return U.then(()=>$());return $()}_chainOrCallHooks(U,$){let q=U,J=[];if(this._getCommandAndAncestors().reverse().filter((Z)=>Z._lifeCycleHooks[$]!==void 0).forEach((Z)=>{Z._lifeCycleHooks[$].forEach((Y)=>{J.push({hookedCommand:Z,callback:Y})})}),$==="postAction")J.reverse();return J.forEach((Z)=>{q=this._chainOrCall(q,()=>{return Z.callback(Z.hookedCommand,this)})}),q}_chainOrCallSubCommandHook(U,$,q){let J=U;if(this._lifeCycleHooks[q]!==void 0)this._lifeCycleHooks[q].forEach((Z)=>{J=this._chainOrCall(J,()=>{return Z(this,$)})});return J}_parseCommand(U,$){let q=this.parseOptions($);if(this._parseOptionsEnv(),this._parseOptionsImplied(),U=U.concat(q.operands),$=q.unknown,this.args=U.concat($),U&&this._findCommand(U[0]))return this._dispatchSubcommand(U[0],U.slice(1),$);if(this._getHelpCommand()&&U[0]===this._getHelpCommand().name())return this._dispatchHelpCommand(U[1]);if(this._defaultCommandName)return this._outputHelpIfRequested($),this._dispatchSubcommand(this._defaultCommandName,U,$);if(this.commands.length&&this.args.length===0&&!this._actionHandler&&!this._defaultCommandName)this.help({error:!0});this._outputHelpIfRequested(q.unknown),this._checkForMissingMandatoryOptions(),this._checkForConflictingOptions();let J=()=>{if(q.unknown.length>0)this.unknownOption(q.unknown[0])},Z=`command:${this.name()}`;if(this._actionHandler){J(),this._processArguments();let Y;if(Y=this._chainOrCallHooks(Y,"preAction"),Y=this._chainOrCall(Y,()=>this._actionHandler(this.processedArgs)),this.parent)Y=this._chainOrCall(Y,()=>{this.parent.emit(Z,U,$)});return Y=this._chainOrCallHooks(Y,"postAction"),Y}if(this.parent?.listenerCount(Z))J(),this._processArguments(),this.parent.emit(Z,U,$);else if(U.length){if(this._findCommand("*"))return this._dispatchSubcommand("*",U,$);if(this.listenerCount("command:*"))this.emit("command:*",U,$);else if(this.commands.length)this.unknownCommand();else J(),this._processArguments()}else if(this.commands.length)J(),this.help({error:!0});else J(),this._processArguments()}_findCommand(U){if(!U)return;return this.commands.find(($)=>$._name===U||$._aliases.includes(U))}_findOption(U){return this.options.find(($)=>$.is(U))}_checkForMissingMandatoryOptions(){this._getCommandAndAncestors().forEach((U)=>{U.options.forEach(($)=>{if($.mandatory&&U.getOptionValue($.attributeName())===void 0)U.missingMandatoryOptionValue($)})})}_checkForConflictingLocalOptions(){let U=this.options.filter((q)=>{let J=q.attributeName();if(this.getOptionValue(J)===void 0)return!1;return this.getOptionValueSource(J)!=="default"});U.filter((q)=>q.conflictsWith.length>0).forEach((q)=>{let J=U.find((Z)=>q.conflictsWith.includes(Z.attributeName()));if(J)this._conflictingOption(q,J)})}_checkForConflictingOptions(){this._getCommandAndAncestors().forEach((U)=>{U._checkForConflictingLocalOptions()})}parseOptions(U){let $=[],q=[],J=$;function Z(G){return G.length>1&&G[0]==="-"}let Y=(G)=>{if(!/^-\d*\.?\d+(e[+-]?\d+)?$/.test(G))return!1;return!this._getCommandAndAncestors().some((K)=>K.options.map((T)=>T.short).some((T)=>/^-\d$/.test(T)))},Q=null,z=null,X=0;while(X<U.length||z){let G=z??U[X++];if(z=null,G==="--"){if(J===q)J.push(G);J.push(...U.slice(X));break}if(Q&&(!Z(G)||Y(G))){this.emit(`option:${Q.name()}`,G);continue}if(Q=null,Z(G)){let K=this._findOption(G);if(K){if(K.required){let T=U[X++];if(T===void 0)this.optionMissingArgument(K);this.emit(`option:${K.name()}`,T)}else if(K.optional){let T=null;if(X<U.length&&(!Z(U[X])||Y(U[X])))T=U[X++];this.emit(`option:${K.name()}`,T)}else this.emit(`option:${K.name()}`);Q=K.variadic?K:null;continue}}if(G.length>2&&G[0]==="-"&&G[1]!=="-"){let K=this._findOption(`-${G[1]}`);if(K){if(K.required||K.optional&&this._combineFlagAndOptionalValue)this.emit(`option:${K.name()}`,G.slice(2));else this.emit(`option:${K.name()}`),z=`-${G.slice(2)}`;continue}}if(/^--[^=]+=/.test(G)){let K=G.indexOf("="),T=this._findOption(G.slice(0,K));if(T&&(T.required||T.optional)){this.emit(`option:${T.name()}`,G.slice(K+1));continue}}if(J===$&&Z(G)&&!(this.commands.length===0&&Y(G)))J=q;if((this._enablePositionalOptions||this._passThroughOptions)&&$.length===0&&q.length===0){if(this._findCommand(G)){$.push(G),q.push(...U.slice(X));break}else if(this._getHelpCommand()&&G===this._getHelpCommand().name()){$.push(G,...U.slice(X));break}else if(this._defaultCommandName){q.push(G,...U.slice(X));break}}if(this._passThroughOptions){J.push(G,...U.slice(X));break}J.push(G)}return{operands:$,unknown:q}}opts(){if(this._storeOptionsAsProperties){let U={},$=this.options.length;for(let q=0;q<$;q++){let J=this.options[q].attributeName();U[J]=J===this._versionOptionName?this._version:this[J]}return U}return this._optionValues}optsWithGlobals(){return this._getCommandAndAncestors().reduce((U,$)=>Object.assign(U,$.opts()),{})}error(U,$){if(this._outputConfiguration.outputError(`${U}
`,this._outputConfiguration.writeErr),typeof this._showHelpAfterError==="string")this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`);else if(this._showHelpAfterError)this._outputConfiguration.writeErr(`
`),this.outputHelp({error:!0});let q=$||{},J=q.exitCode||1,Z=q.code||"commander.error";this._exit(J,Z,U)}_parseOptionsEnv(){this.options.forEach((U)=>{if(U.envVar&&U.envVar in M.env){let $=U.attributeName();if(this.getOptionValue($)===void 0||["default","config","env"].includes(this.getOptionValueSource($)))if(U.required||U.optional)this.emit(`optionEnv:${U.name()}`,M.env[U.envVar]);else this.emit(`optionEnv:${U.name()}`)}})}_parseOptionsImplied(){let U=new y$(this.options),$=(q)=>{return this.getOptionValue(q)!==void 0&&!["default","implied"].includes(this.getOptionValueSource(q))};this.options.filter((q)=>q.implied!==void 0&&$(q.attributeName())&&U.valueFromOption(this.getOptionValue(q.attributeName()),q)).forEach((q)=>{Object.keys(q.implied).filter((J)=>!$(J)).forEach((J)=>{this.setOptionValueWithSource(J,q.implied[J],"implied")})})}missingArgument(U){let $=`error: missing required argument '${U}'`;this.error($,{code:"commander.missingArgument"})}optionMissingArgument(U){let $=`error: option '${U.flags}' argument missing`;this.error($,{code:"commander.optionMissingArgument"})}missingMandatoryOptionValue(U){let $=`error: required option '${U.flags}' not specified`;this.error($,{code:"commander.missingMandatoryOptionValue"})}_conflictingOption(U,$){let q=(Y)=>{let Q=Y.attributeName(),z=this.getOptionValue(Q),X=this.options.find((K)=>K.negate&&Q===K.attributeName()),G=this.options.find((K)=>!K.negate&&Q===K.attributeName());if(X&&(X.presetArg===void 0&&z===!1||X.presetArg!==void 0&&z===X.presetArg))return X;return G||Y},J=(Y)=>{let Q=q(Y),z=Q.attributeName();if(this.getOptionValueSource(z)==="env")return`environment variable '${Q.envVar}'`;return`option '${Q.flags}'`},Z=`error: ${J(U)} cannot be used with ${J($)}`;this.error(Z,{code:"commander.conflictingOption"})}unknownOption(U){if(this._allowUnknownOption)return;let $="";if(U.startsWith("--")&&this._showSuggestionAfterError){let J=[],Z=this;do{let Y=Z.createHelp().visibleOptions(Z).filter((Q)=>Q.long).map((Q)=>Q.long);J=J.concat(Y),Z=Z.parent}while(Z&&!Z._enablePositionalOptions);$=x0(U,J)}let q=`error: unknown option '${U}'${$}`;this.error(q,{code:"commander.unknownOption"})}_excessArguments(U){if(this._allowExcessArguments)return;let $=this.registeredArguments.length,q=$===1?"":"s",Z=`error: too many arguments${this.parent?` for '${this.name()}'`:""}. Expected ${$} argument${q} but got ${U.length}.`;this.error(Z,{code:"commander.excessArguments"})}unknownCommand(){let U=this.args[0],$="";if(this._showSuggestionAfterError){let J=[];this.createHelp().visibleCommands(this).forEach((Z)=>{if(J.push(Z.name()),Z.alias())J.push(Z.alias())}),$=x0(U,J)}let q=`error: unknown command '${U}'${$}`;this.error(q,{code:"commander.unknownCommand"})}version(U,$,q){if(U===void 0)return this._version;this._version=U,$=$||"-V, --version",q=q||"output the version number";let J=this.createOption($,q);return this._versionOptionName=J.attributeName(),this._registerOption(J),this.on("option:"+J.name(),()=>{this._outputConfiguration.writeOut(`${U}
`),this._exit(0,"commander.version",U)}),this}description(U,$){if(U===void 0&&$===void 0)return this._description;if(this._description=U,$)this._argsDescription=$;return this}summary(U){if(U===void 0)return this._summary;return this._summary=U,this}alias(U){if(U===void 0)return this._aliases[0];let $=this;if(this.commands.length!==0&&this.commands[this.commands.length-1]._executableHandler)$=this.commands[this.commands.length-1];if(U===$._name)throw Error("Command alias can't be the same as its name");let q=this.parent?._findCommand(U);if(q){let J=[q.name()].concat(q.aliases()).join("|");throw Error(`cannot add alias '${U}' to command '${this.name()}' as already have command '${J}'`)}return $._aliases.push(U),this}aliases(U){if(U===void 0)return this._aliases;return U.forEach(($)=>this.alias($)),this}usage(U){if(U===void 0){if(this._usage)return this._usage;let $=this.registeredArguments.map((q)=>{return C$(q)});return[].concat(this.options.length||this._helpOption!==null?"[options]":[],this.commands.length?"[command]":[],this.registeredArguments.length?$:[]).join(" ")}return this._usage=U,this}name(U){if(U===void 0)return this._name;return this._name=U,this}helpGroup(U){if(U===void 0)return this._helpGroupHeading??"";return this._helpGroupHeading=U,this}commandsGroup(U){if(U===void 0)return this._defaultCommandGroup??"";return this._defaultCommandGroup=U,this}optionsGroup(U){if(U===void 0)return this._defaultOptionGroup??"";return this._defaultOptionGroup=U,this}_initOptionGroup(U){if(this._defaultOptionGroup&&!U.helpGroupHeading)U.helpGroup(this._defaultOptionGroup)}_initCommandGroup(U){if(this._defaultCommandGroup&&!U.helpGroup())U.helpGroup(this._defaultCommandGroup)}nameFromFilename(U){return this._name=QU.basename(U,QU.extname(U)),this}executableDir(U){if(U===void 0)return this._executableDir;return this._executableDir=U,this}helpInformation(U){let $=this.createHelp(),q=this._getOutputContext(U);$.prepareContext({error:q.error,helpWidth:q.helpWidth,outputHasColors:q.hasColors});let J=$.formatHelp(this,$);if(q.hasColors)return J;return this._outputConfiguration.stripColor(J)}_getOutputContext(U){U=U||{};let $=!!U.error,q,J,Z;if($)q=(Q)=>this._outputConfiguration.writeErr(Q),J=this._outputConfiguration.getErrHasColors(),Z=this._outputConfiguration.getErrHelpWidth();else q=(Q)=>this._outputConfiguration.writeOut(Q),J=this._outputConfiguration.getOutHasColors(),Z=this._outputConfiguration.getOutHelpWidth();return{error:$,write:(Q)=>{if(!J)Q=this._outputConfiguration.stripColor(Q);return q(Q)},hasColors:J,helpWidth:Z}}outputHelp(U){let $;if(typeof U==="function")$=U,U=void 0;let q=this._getOutputContext(U),J={error:q.error,write:q.write,command:this};this._getCommandAndAncestors().reverse().forEach((Y)=>Y.emit("beforeAllHelp",J)),this.emit("beforeHelp",J);let Z=this.helpInformation({error:q.error});if($){if(Z=$(Z),typeof Z!=="string"&&!Buffer.isBuffer(Z))throw Error("outputHelp callback must return a string or a Buffer")}if(q.write(Z),this._getHelpOption()?.long)this.emit(this._getHelpOption().long);this.emit("afterHelp",J),this._getCommandAndAncestors().forEach((Y)=>Y.emit("afterAllHelp",J))}helpOption(U,$){if(typeof U==="boolean"){if(U){if(this._helpOption===null)this._helpOption=void 0;if(this._defaultOptionGroup)this._initOptionGroup(this._getHelpOption())}else this._helpOption=null;return this}if(this._helpOption=this.createOption(U??"-h, --help",$??"display help for command"),U||$)this._initOptionGroup(this._helpOption);return this}_getHelpOption(){if(this._helpOption===void 0)this.helpOption(void 0,void 0);return this._helpOption}addHelpOption(U){return this._helpOption=U,this._initOptionGroup(U),this}help(U){this.outputHelp(U);let $=Number(M.exitCode??0);if($===0&&U&&typeof U!=="function"&&U.error)$=1;this._exit($,"commander.help","(outputHelp)")}addHelpText(U,$){let q=["beforeAll","before","after","afterAll"];if(!q.includes(U))throw Error(`Unexpected value for position to addHelpText.
Expecting one of '${q.join("', '")}'`);let J=`${U}Help`;return this.on(J,(Z)=>{let Y;if(typeof $==="function")Y=$({error:Z.error,command:Z.command});else Y=$;if(Y)Z.write(`${Y}
`)}),this}_outputHelpIfRequested(U){let $=this._getHelpOption();if($&&U.find((J)=>$.is(J)))this.outputHelp(),this._exit(0,"commander.helpDisplayed","(outputHelp)")}}function g0(U){return U.map(($)=>{if(!$.startsWith("--inspect"))return $;let q,J="127.0.0.1",Z="9229",Y;if((Y=$.match(/^(--inspect(-brk)?)$/))!==null)q=Y[1];else if((Y=$.match(/^(--inspect(-brk|-port)?)=([^:]+)$/))!==null)if(q=Y[1],/^\d+$/.test(Y[3]))Z=Y[3];else J=Y[3];else if((Y=$.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/))!==null)q=Y[1],J=Y[3],Z=Y[4];if(q&&Z!=="0")return`${q}=${J}:${parseInt(Z)+1}`;return $})}function X0(){if(M.env.NO_COLOR||M.env.FORCE_COLOR==="0"||M.env.FORCE_COLOR==="false")return!1;if(M.env.FORCE_COLOR||M.env.CLICOLOR_FORCE!==void 0)return!0;return}K0.Command=G0;K0.useColor=X0});var c0=BU((r)=>{var{Argument:m0}=mU(),{Command:T0}=h0(),{CommanderError:f$,InvalidArgumentError:u0}=yU(),{Help:b$}=J0(),{Option:l0}=Y0();r.program=new T0;r.createCommand=(U)=>new T0(U);r.createOption=(U,$)=>new l0(U,$);r.createArgument=(U,$)=>new m0(U,$);r.Command=T0;r.Option=l0;r.Argument=m0;r.Help=b$;r.CommanderError=f$;r.InvalidArgumentError=u0;r.InvalidOptionArgumentError=u0});var d0=IU(c0()),{program:Hq,createCommand:Rq,createArgument:Vq,createOption:Nq,CommanderError:Iq,InvalidArgumentError:Bq,InvalidOptionArgumentError:jq,Command:p0,Argument:Sq,Option:jU,Help:Fq}=d0.default;var t=require("node:fs"),SU=require("node:fs"),N=require("node:process");class e extends Error{constructor(U){super(U);Object.setPrototypeOf(this,new.target.prototype),this.name=new.target.name,this.stack=void 0}}class a extends e{}class LU extends e{}class W0 extends e{}class lU extends e{}class HU extends e{}class zU extends e{}class UU extends e{}class g extends e{}class RU extends e{}function i0(){return typeof process<"u"&&typeof process.versions==="object"&&!0}function DU(...U){let $=U.reduce((Z,Y)=>Z+Y.byteLength,0),q=new Uint8Array($),J=0;for(let Z of U)q.set(Z,J),J+=Z.byteLength;return q}function OU(...U){try{let $=DU(...U);if(i0())return Buffer.from($).toString("base64");let q="";for(let J=0;J<$.length;J++)q+=String.fromCharCode($[J]);return btoa(q)}catch{throw new W0("Base64 Encoding Error")}}function fU(U){try{if(!/^[A-Za-z0-9+/]+={0,2}$/.test(U)||U.length%4!==0)throw Error("Invalid Base64");if(i0())return new Uint8Array(Buffer.from(U,"base64"));let $=atob(U),q=new Uint8Array($.length);for(let J=0;J<$.length;J++)q[J]=$.charCodeAt(J);return q}catch{throw new LU(`Invalid Base64: length=${U.length}, content='${U.slice(0,12)}â€¦'`)}}function i(U){let $=U.value.length,q=Array($).fill("\x00").join("");U.value=q}function H0(U,$,q){if($<0||q<0||$+q>U)throw RangeError("read() slice exceeds data bounds")}var s0=require("fs");class R0{src;#U=null;constructor(U){this.src=U}get length(){if(this.src instanceof Uint8Array)return this.src.byteLength;if(this.src instanceof Blob)return this.src.size;return this.ensureUint8().byteLength}async read(U,$){if(H0(this.length,U,$),this.src instanceof Uint8Array)return this.src.slice(U,U+$);if(this.src instanceof Blob){let q=await this.src.slice(U,U+$).arrayBuffer();return new Uint8Array(q)}return this.ensureUint8().slice(U,U+$)}ensureUint8(){if(!this.#U)this.#U=fU(this.src);return this.#U}}class bU{fd;length;constructor(U,$){this.fd=U;this.length=$}static async open(U){let $=await s0.promises.open(U,"r"),q=await $.stat();return new bU($,q.size)}async read(U,$){H0(this.length,U,$);let q=Buffer.allocUnsafe($);return await this.fd.read(q,0,$,U),new Uint8Array(q)}async close(){await this.fd.close()}}class p{static byId=new Map;static register(U){if(this.byId.has(U.id))throw new lU(`Scheme ${U.id} already registered`);this.byId.set(U.id,U)}static get(U){let $=this.byId.get(U);if(!$)throw new lU(`Unknown scheme: ${U}`);return $}static get current(){return this.get(0)}}class XU{p;padding=null;headerAAD=new Uint8Array(0);padAADMode="auto";padAlign=8;allowLegacyAADFallback=!0;legacyFallbackPolicy="auto";tryEmptyAADOnLegacyFallback=!1;setLegacyAADFallback(U={}){if(U.enabled!==void 0)this.allowLegacyAADFallback=!!U.enabled;if(U.policy)this.legacyFallbackPolicy=U.policy;if(U.tryEmptyAAD!==void 0)this.tryEmptyAADOnLegacyFallback=!!U.tryEmptyAAD}static PAD_AAD_MAGIC=new Uint8Array([80,65,68,49]);static PAD_AAD_VER=1;constructor(U){this.p=U}setPaddingScheme(U){this.padding=U}setPaddingAADMode(U){this.padAADMode=U}setPaddingAlign(U){if(!Number.isInteger(U)||U<1||U>255)throw Error("padAlign must be 1..255");this.padAlign=U|0}setAAD(U){this.headerAAD=U&&U.byteLength?new Uint8Array(U):new Uint8Array(0)}async encryptChunk(U){let $=this.resolveMode(),q=U;if($==="require"){if(!this.padding)throw Error("Padding required but no scheme set");let Y=(Q)=>this.p.getRandomValues(new Uint8Array(Q));q=this.padding.pad(U,Y,this.padAlign)}let J=this.composeAAD($),Z=await this.encryptWithAAD(q,J);if(U.fill(0),q!==U)q.fill(0);return Z}async decryptChunk(U){let $=this.resolveMode(),q=this.composeAAD($);try{let J=await this.decryptWithAAD(U,q);return this.enforcePolicyAfterDecrypt(J,$)}catch(J){if(!this.allowLegacyAADFallback)throw J;let Z=[];if(this.headerAAD.length)Z.push(this.headerAAD);if(this.tryEmptyAADOnLegacyFallback)Z.push(new Uint8Array(0));let Y=J;for(let Q of Z)try{let z=await this.decryptWithAAD(U,Q),X=this.legacyFallbackPolicy==="auto"?"auto":this.legacyFallbackPolicy;return this.enforcePolicyAfterDecrypt(z,X)}catch(z){Y=z}throw Y}}enforcePolicyAfterDecrypt(U,$){if(!this.padding){if($==="require")throw new g("Expected padding but no scheme configured");return U}let{used:q,plain:J}=this.padding.tryUnpad(U);if($==="require"){if(!q)throw new g("Expected padding trailer not found");return new Uint8Array(J)}if($==="forbid"){if(q)throw new g("Padding forbidden by policy");return U}return q?new Uint8Array(J):U}resolveMode(){if(this.padAADMode==="auto")return this.padding?"require":"forbid";return this.padAADMode}buildPadAAD(U){let $=U==="require"?0:1,q=new Uint8Array(XU.PAD_AAD_MAGIC.length+1+1+1),J=0;return q.set(XU.PAD_AAD_MAGIC,J),J+=XU.PAD_AAD_MAGIC.length,q[J++]=XU.PAD_AAD_VER&255,q[J++]=$,q[J++]=this.padAlign&255,q}composeAAD(U){let $=this.buildPadAAD(U);if(!this.headerAAD.length)return $;let q=new Uint8Array(this.headerAAD.length+$.length);return q.set(this.headerAAD,0),q.set($,this.headerAAD.length),q}}class $U extends XU{static IV_LENGTH=12;static TAG_LENGTH=16;IV_LENGTH=$U.IV_LENGTH;TAG_LENGTH=$U.TAG_LENGTH;key=null;constructor(U){super(U)}async setKey(U){this.key=U}zeroKey(){this.key=null}async encryptWithAAD(U,$){let q=this.p.getRandomValues(new Uint8Array($U.IV_LENGTH)),J={name:"AES-GCM",iv:q,additionalData:$},Z=await this.p.subtle.encrypt(J,this.requireKey(),U),Y=new Uint8Array(Z),Q=new Uint8Array(q.length+Y.length);return Q.set(q,0),Q.set(Y,q.length),Q}async decryptWithAAD(U,$){if(U.byteLength<$U.IV_LENGTH+$U.TAG_LENGTH)throw new g("Invalid ciphertext: too short.");let q=U.subarray(0,$U.IV_LENGTH),J=U.subarray($U.IV_LENGTH),Z={name:"AES-GCM",iv:q,additionalData:$};try{let Y=await this.p.subtle.decrypt(Z,this.requireKey(),J);return new Uint8Array(Y)}catch{throw new g("Decryption failed: wrong passphrase or corrupted ciphertext")}}requireKey(){if(!this.key)throw Error("Encryption key not set");return this.key}}/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function x$(U){return U instanceof Uint8Array||ArrayBuffer.isView(U)&&U.constructor.name==="Uint8Array"}function cU(U){if(typeof U!=="boolean")throw Error(`boolean expected, not ${U}`)}function dU(U){if(!Number.isSafeInteger(U)||U<0)throw Error("positive integer expected, got "+U)}function l(U,$,q=""){let J=x$(U),Z=U?.length,Y=$!==void 0;if(!J||Y&&Z!==$){let Q=q&&`"${q}" `,z=Y?` of length ${$}`:"",X=J?`length=${Z}`:`type=${typeof U}`;throw Error(Q+"expected Uint8Array"+z+", got "+X)}return U}function V0(U,$=!0){if(U.destroyed)throw Error("Hash instance has been destroyed");if($&&U.finished)throw Error("Hash#digest() has already been called")}function n0(U,$){l(U,void 0,"output");let q=$.outputLen;if(U.length<q)throw Error("digestInto() expects output buffer of length at least "+q)}function GU(U){return new Uint32Array(U.buffer,U.byteOffset,Math.floor(U.byteLength/4))}function KU(...U){for(let $=0;$<U.length;$++)U[$].fill(0)}function g$(U){return new DataView(U.buffer,U.byteOffset,U.byteLength)}var h$=(()=>new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68)();function o0(U,$){if($==null||typeof $!=="object")throw Error("options must be defined");return Object.assign(U,$)}function a0(U,$){if(U.length!==$.length)return!1;let q=0;for(let J=0;J<U.length;J++)q|=U[J]^$[J];return q===0}var N0=(U,$)=>{function q(J,...Z){if(l(J,void 0,"key"),!h$)throw Error("Non little-endian hardware is not yet supported");if(U.nonceLength!==void 0){let K=Z[0];l(K,U.varSizeNonce?void 0:U.nonceLength,"nonce")}let Y=U.tagLength;if(Y&&Z[1]!==void 0)l(Z[1],void 0,"AAD");let Q=$(J,...Z),z=(K,T)=>{if(T!==void 0){if(K!==2)throw Error("cipher output not supported");l(T,void 0,"output")}},X=!1;return{encrypt(K,T){if(X)throw Error("cannot encrypt() twice with same key + nonce");return X=!0,l(K),z(Q.encrypt.length,T),Q.encrypt(K,T)},decrypt(K,T){if(l(K),Y&&K.length<Y)throw Error('"ciphertext" expected length bigger than tagLength='+Y);return z(Q.decrypt.length,T),Q.decrypt(K,T)}}}return Object.assign(q,U),q};function I0(U,$,q=!0){if($===void 0)return new Uint8Array(U);if($.length!==U)throw Error('"output" expected Uint8Array of length '+U+", got: "+$.length);if(q&&!m$($))throw Error("invalid output, must be aligned");return $}function r0(U,$,q){cU(q);let J=new Uint8Array(16),Z=g$(J);return Z.setBigUint64(0,BigInt($),q),Z.setBigUint64(8,BigInt(U),q),J}function m$(U){return U.byteOffset%4===0}function EU(U){return Uint8Array.from(U)}var e0=(U)=>Uint8Array.from(U.split(""),($)=>$.charCodeAt(0)),u$=e0("expand 16-byte k"),l$=e0("expand 32-byte k"),c$=GU(u$),d$=GU(l$);function W(U,$){return U<<$|U>>>32-$}function B0(U){return U.byteOffset%4===0}var pU=64,p$=16,U$=4294967295,t0=Uint32Array.of();function i$(U,$,q,J,Z,Y,Q,z){let X=Z.length,G=new Uint8Array(pU),K=GU(G),T=B0(Z)&&B0(Y),R=T?GU(Z):t0,H=T?GU(Y):t0;for(let B=0;B<X;Q++){if(U($,q,J,K,Q,z),Q>=U$)throw Error("arx: counter overflow");let V=Math.min(pU,X-B);if(T&&V===pU){let j=B/4;if(B%4!==0)throw Error("arx: invalid block position");for(let S=0,F;S<p$;S++)F=j+S,H[F]=R[F]^K[S];B+=pU;continue}for(let j=0,S;j<V;j++)S=B+j,Y[S]=Z[S]^G[j];B+=V}}function j0(U,$){let{allowShortKeys:q,extendNonceFn:J,counterLength:Z,counterRight:Y,rounds:Q}=o0({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},$);if(typeof U!=="function")throw Error("core must be a function");return dU(Z),dU(Q),cU(Y),cU(q),(z,X,G,K,T=0)=>{l(z,void 0,"key"),l(X,void 0,"nonce"),l(G,void 0,"data");let R=G.length;if(K===void 0)K=new Uint8Array(R);if(l(K,void 0,"output"),dU(T),T<0||T>=U$)throw Error("arx: counter overflow");if(K.length<R)throw Error(`arx: output (${K.length}) is shorter than data (${R})`);let H=[],B=z.length,V,j;if(B===32)H.push(V=EU(z)),j=d$;else if(B===16&&q)V=new Uint8Array(32),V.set(z),V.set(z,16),j=c$,H.push(V);else throw l(z,32,"arx key"),Error("invalid key size");if(!B0(X))H.push(X=EU(X));let S=GU(V);if(J){if(X.length!==24)throw Error("arx: extended nonce must be 24 bytes");J(j,S,GU(X.subarray(0,16)),S),X=X.subarray(16)}let F=16-Z;if(F!==X.length)throw Error(`arx: nonce must be ${F} or 16 bytes`);if(F!==12){let _=new Uint8Array(12);_.set(X,Y?0:12-X.length),X=_,H.push(X)}let w=GU(X);return i$(U,j,S,w,G,K,T,Q),KU(...H),K}}function c(U,$){return U[$++]&255|(U[$++]&255)<<8}class $${blockLen=16;outputLen=16;buffer=new Uint8Array(16);r=new Uint16Array(10);h=new Uint16Array(10);pad=new Uint16Array(8);pos=0;finished=!1;constructor(U){U=EU(l(U,32,"key"));let $=c(U,0),q=c(U,2),J=c(U,4),Z=c(U,6),Y=c(U,8),Q=c(U,10),z=c(U,12),X=c(U,14);this.r[0]=$&8191,this.r[1]=($>>>13|q<<3)&8191,this.r[2]=(q>>>10|J<<6)&7939,this.r[3]=(J>>>7|Z<<9)&8191,this.r[4]=(Z>>>4|Y<<12)&255,this.r[5]=Y>>>1&8190,this.r[6]=(Y>>>14|Q<<2)&8191,this.r[7]=(Q>>>11|z<<5)&8065,this.r[8]=(z>>>8|X<<8)&8191,this.r[9]=X>>>5&127;for(let G=0;G<8;G++)this.pad[G]=c(U,16+2*G)}process(U,$,q=!1){let J=q?0:2048,{h:Z,r:Y}=this,Q=Y[0],z=Y[1],X=Y[2],G=Y[3],K=Y[4],T=Y[5],R=Y[6],H=Y[7],B=Y[8],V=Y[9],j=c(U,$+0),S=c(U,$+2),F=c(U,$+4),w=c(U,$+6),_=c(U,$+8),s=c(U,$+10),h=c(U,$+12),d=c(U,$+14),P=Z[0]+(j&8191),L=Z[1]+((j>>>13|S<<3)&8191),D=Z[2]+((S>>>10|F<<6)&8191),O=Z[3]+((F>>>7|w<<9)&8191),E=Z[4]+((w>>>4|_<<12)&8191),A=Z[5]+(_>>>1&8191),C=Z[6]+((_>>>14|s<<2)&8191),k=Z[7]+((s>>>11|h<<5)&8191),v=Z[8]+((h>>>8|d<<8)&8191),y=Z[9]+(d>>>5|J),I=0,b=I+P*Q+L*(5*V)+D*(5*B)+O*(5*H)+E*(5*R);I=b>>>13,b&=8191,b+=A*(5*T)+C*(5*K)+k*(5*G)+v*(5*X)+y*(5*z),I+=b>>>13,b&=8191;let x=I+P*z+L*Q+D*(5*V)+O*(5*B)+E*(5*H);I=x>>>13,x&=8191,x+=A*(5*R)+C*(5*T)+k*(5*K)+v*(5*G)+y*(5*X),I+=x>>>13,x&=8191;let m=I+P*X+L*z+D*Q+O*(5*V)+E*(5*B);I=m>>>13,m&=8191,m+=A*(5*H)+C*(5*R)+k*(5*T)+v*(5*K)+y*(5*G),I+=m>>>13,m&=8191;let f=I+P*G+L*X+D*z+O*Q+E*(5*V);I=f>>>13,f&=8191,f+=A*(5*B)+C*(5*H)+k*(5*R)+v*(5*T)+y*(5*K),I+=f>>>13,f&=8191;let YU=I+P*K+L*G+D*X+O*z+E*Q;I=YU>>>13,YU&=8191,YU+=A*(5*V)+C*(5*B)+k*(5*H)+v*(5*R)+y*(5*T),I+=YU>>>13,YU&=8191;let FU=I+P*T+L*K+D*G+O*X+E*z;I=FU>>>13,FU&=8191,FU+=A*Q+C*(5*V)+k*(5*B)+v*(5*H)+y*(5*R),I+=FU>>>13,FU&=8191;let _U=I+P*R+L*T+D*K+O*G+E*X;I=_U>>>13,_U&=8191,_U+=A*z+C*Q+k*(5*V)+v*(5*B)+y*(5*H),I+=_U>>>13,_U&=8191;let MU=I+P*H+L*R+D*T+O*K+E*G;I=MU>>>13,MU&=8191,MU+=A*X+C*z+k*Q+v*(5*V)+y*(5*B),I+=MU>>>13,MU&=8191;let wU=I+P*B+L*H+D*R+O*T+E*K;I=wU>>>13,wU&=8191,wU+=A*G+C*X+k*z+v*Q+y*(5*V),I+=wU>>>13,wU&=8191;let PU=I+P*V+L*B+D*H+O*R+E*T;I=PU>>>13,PU&=8191,PU+=A*K+C*G+k*X+v*z+y*Q,I+=PU>>>13,PU&=8191,I=(I<<2)+I|0,I=I+b|0,b=I&8191,I=I>>>13,x+=I,Z[0]=b,Z[1]=x,Z[2]=m,Z[3]=f,Z[4]=YU,Z[5]=FU,Z[6]=_U,Z[7]=MU,Z[8]=wU,Z[9]=PU}finalize(){let{h:U,pad:$}=this,q=new Uint16Array(10),J=U[1]>>>13;U[1]&=8191;for(let Q=2;Q<10;Q++)U[Q]+=J,J=U[Q]>>>13,U[Q]&=8191;U[0]+=J*5,J=U[0]>>>13,U[0]&=8191,U[1]+=J,J=U[1]>>>13,U[1]&=8191,U[2]+=J,q[0]=U[0]+5,J=q[0]>>>13,q[0]&=8191;for(let Q=1;Q<10;Q++)q[Q]=U[Q]+J,J=q[Q]>>>13,q[Q]&=8191;q[9]-=8192;let Z=(J^1)-1;for(let Q=0;Q<10;Q++)q[Q]&=Z;Z=~Z;for(let Q=0;Q<10;Q++)U[Q]=U[Q]&Z|q[Q];U[0]=(U[0]|U[1]<<13)&65535,U[1]=(U[1]>>>3|U[2]<<10)&65535,U[2]=(U[2]>>>6|U[3]<<7)&65535,U[3]=(U[3]>>>9|U[4]<<4)&65535,U[4]=(U[4]>>>12|U[5]<<1|U[6]<<14)&65535,U[5]=(U[6]>>>2|U[7]<<11)&65535,U[6]=(U[7]>>>5|U[8]<<8)&65535,U[7]=(U[8]>>>8|U[9]<<5)&65535;let Y=U[0]+$[0];U[0]=Y&65535;for(let Q=1;Q<8;Q++)Y=(U[Q]+$[Q]|0)+(Y>>>16)|0,U[Q]=Y&65535;KU(q)}update(U){V0(this),l(U),U=EU(U);let{buffer:$,blockLen:q}=this,J=U.length;for(let Z=0;Z<J;){let Y=Math.min(q-this.pos,J-Z);if(Y===q){for(;q<=J-Z;Z+=q)this.process(U,Z);continue}if($.set(U.subarray(Z,Z+Y),this.pos),this.pos+=Y,Z+=Y,this.pos===q)this.process($,0,!1),this.pos=0}return this}destroy(){KU(this.h,this.r,this.buffer,this.pad)}digestInto(U){V0(this),n0(U,this),this.finished=!0;let{buffer:$,h:q}=this,{pos:J}=this;if(J){$[J++]=1;for(;J<16;J++)$[J]=0;this.process($,0,!0)}this.finalize();let Z=0;for(let Y=0;Y<8;Y++)U[Z++]=q[Y]>>>0,U[Z++]=q[Y]>>>8;return U}digest(){let{buffer:U,outputLen:$}=this;this.digestInto(U);let q=U.slice(0,$);return this.destroy(),q}}function s$(U){let $=(J,Z)=>U(Z).update(J).digest(),q=U(new Uint8Array(32));return $.outputLen=q.outputLen,$.blockLen=q.blockLen,$.create=(J)=>U(J),$}var q$=(()=>s$((U)=>new $$(U)))();function Y$(U,$,q,J,Z,Y=20){let Q=U[0],z=U[1],X=U[2],G=U[3],K=$[0],T=$[1],R=$[2],H=$[3],B=$[4],V=$[5],j=$[6],S=$[7],F=Z,w=q[0],_=q[1],s=q[2],h=Q,d=z,P=X,L=G,D=K,O=T,E=R,A=H,C=B,k=V,v=j,y=S,I=F,b=w,x=_,m=s;for(let YU=0;YU<Y;YU+=2)h=h+D|0,I=W(I^h,16),C=C+I|0,D=W(D^C,12),h=h+D|0,I=W(I^h,8),C=C+I|0,D=W(D^C,7),d=d+O|0,b=W(b^d,16),k=k+b|0,O=W(O^k,12),d=d+O|0,b=W(b^d,8),k=k+b|0,O=W(O^k,7),P=P+E|0,x=W(x^P,16),v=v+x|0,E=W(E^v,12),P=P+E|0,x=W(x^P,8),v=v+x|0,E=W(E^v,7),L=L+A|0,m=W(m^L,16),y=y+m|0,A=W(A^y,12),L=L+A|0,m=W(m^L,8),y=y+m|0,A=W(A^y,7),h=h+O|0,m=W(m^h,16),v=v+m|0,O=W(O^v,12),h=h+O|0,m=W(m^h,8),v=v+m|0,O=W(O^v,7),d=d+E|0,I=W(I^d,16),y=y+I|0,E=W(E^y,12),d=d+E|0,I=W(I^d,8),y=y+I|0,E=W(E^y,7),P=P+A|0,b=W(b^P,16),C=C+b|0,A=W(A^C,12),P=P+A|0,b=W(b^P,8),C=C+b|0,A=W(A^C,7),L=L+D|0,x=W(x^L,16),k=k+x|0,D=W(D^k,12),L=L+D|0,x=W(x^L,8),k=k+x|0,D=W(D^k,7);let f=0;J[f++]=Q+h|0,J[f++]=z+d|0,J[f++]=X+P|0,J[f++]=G+L|0,J[f++]=K+D|0,J[f++]=T+O|0,J[f++]=R+E|0,J[f++]=H+A|0,J[f++]=B+C|0,J[f++]=V+k|0,J[f++]=j+v|0,J[f++]=S+y|0,J[f++]=F+I|0,J[f++]=w+b|0,J[f++]=_+x|0,J[f++]=s+m|0}function n$(U,$,q,J){let Z=U[0],Y=U[1],Q=U[2],z=U[3],X=$[0],G=$[1],K=$[2],T=$[3],R=$[4],H=$[5],B=$[6],V=$[7],j=q[0],S=q[1],F=q[2],w=q[3];for(let s=0;s<20;s+=2)Z=Z+X|0,j=W(j^Z,16),R=R+j|0,X=W(X^R,12),Z=Z+X|0,j=W(j^Z,8),R=R+j|0,X=W(X^R,7),Y=Y+G|0,S=W(S^Y,16),H=H+S|0,G=W(G^H,12),Y=Y+G|0,S=W(S^Y,8),H=H+S|0,G=W(G^H,7),Q=Q+K|0,F=W(F^Q,16),B=B+F|0,K=W(K^B,12),Q=Q+K|0,F=W(F^Q,8),B=B+F|0,K=W(K^B,7),z=z+T|0,w=W(w^z,16),V=V+w|0,T=W(T^V,12),z=z+T|0,w=W(w^z,8),V=V+w|0,T=W(T^V,7),Z=Z+G|0,w=W(w^Z,16),B=B+w|0,G=W(G^B,12),Z=Z+G|0,w=W(w^Z,8),B=B+w|0,G=W(G^B,7),Y=Y+K|0,j=W(j^Y,16),V=V+j|0,K=W(K^V,12),Y=Y+K|0,j=W(j^Y,8),V=V+j|0,K=W(K^V,7),Q=Q+T|0,S=W(S^Q,16),R=R+S|0,T=W(T^R,12),Q=Q+T|0,S=W(S^Q,8),R=R+S|0,T=W(T^R,7),z=z+X|0,F=W(F^z,16),H=H+F|0,X=W(X^H,12),z=z+X|0,F=W(F^z,8),H=H+F|0,X=W(X^H,7);let _=0;J[_++]=Z,J[_++]=Y,J[_++]=Q,J[_++]=z,J[_++]=j,J[_++]=S,J[_++]=F,J[_++]=w}var o$=j0(Y$,{counterRight:!1,counterLength:4,allowShortKeys:!1}),a$=j0(Y$,{counterRight:!1,counterLength:8,extendNonceFn:n$,allowShortKeys:!1});var r$=new Uint8Array(16),J$=(U,$)=>{U.update($);let q=$.length%16;if(q)U.update(r$.subarray(q))},t$=new Uint8Array(32);function Z$(U,$,q,J,Z){if(Z!==void 0)l(Z,void 0,"AAD");let Y=U($,q,t$),Q=r0(J.length,Z?Z.length:0,!0),z=q$.create(Y);if(Z)J$(z,Z);J$(z,J),z.update(Q);let X=z.digest();return KU(Y,Q),X}var Q$=(U)=>($,q,J)=>{return{encrypt(Y,Q){let z=Y.length;Q=I0(z+16,Q,!1),Q.set(Y);let X=Q.subarray(0,-16);U($,q,X,X,1);let G=Z$(U,$,q,X,J);return Q.set(G,z),KU(G),Q},decrypt(Y,Q){Q=I0(Y.length-16,Q,!1);let z=Y.subarray(0,-16),X=Y.subarray(-16),G=Z$(U,$,q,z,J);if(!a0(X,G))throw Error("invalid tag");return Q.set(Y.subarray(0,-16)),U($,q,Q,Q,1),KU(G),Q}}},rq=N0({blockSize:64,nonceLength:12,tagLength:16},Q$(o$)),S0=N0({blockSize:64,nonceLength:24,tagLength:16},Q$(a$));class qU extends XU{static IV_LENGTH=24;static TAG_LENGTH=16;IV_LENGTH=qU.IV_LENGTH;TAG_LENGTH=qU.TAG_LENGTH;key=null;constructor(U){super(U)}async setKey(U){this.key=new Uint8Array(await this.p.subtle.exportKey("raw",U))}zeroKey(){if(this.key)this.key.fill(0);this.key=null}async encryptWithAAD(U,$){let q=this.p.getRandomValues(new Uint8Array(qU.IV_LENGTH)),Z=S0(this.requireRawKey(),q,$).encrypt(U),Y=new Uint8Array(q.length+Z.length);return Y.set(q,0),Y.set(Z,q.length),Y}async decryptWithAAD(U,$){if(U.byteLength<qU.IV_LENGTH+qU.TAG_LENGTH)throw new g("Invalid ciphertext: too short.");let q=U.subarray(0,qU.IV_LENGTH),J=U.subarray(qU.IV_LENGTH),Z=S0(this.requireRawKey(),q,$);try{return Z.decrypt(J)}catch{throw new g("Decryption failed: wrong passphrase or corrupted ciphertext")}}requireRawKey(){if(!this.key)throw Error("Encryption key not set");return this.key}}var iU=IU(require("argon2-browser"));async function e$(){if(typeof window<"u")return;if(globalThis.loadArgon2WasmModule)return;try{let{createRequire:U}=await import("node:module"),{readFile:$}=await import("node:fs/promises"),q=U(import.meta.url),J=q.resolve("argon2-browser/dist/argon2.js"),Z=q.resolve("argon2-browser/dist/argon2.wasm");globalThis.loadArgon2WasmModule=async()=>{let Y=new Uint8Array(await $(Z));return globalThis.Module={wasmBinary:Y,locateFile:(Q)=>Q==="argon2.wasm"?Z:Q},q(J)}}catch{}}async function z$(U,$,q,J){if(J==="node"){let Z=await import("@node-rs/argon2"),Y=typeof U==="string"?Buffer.from(U,"utf8"):Buffer.from(U),z=(await Z.hash(Y,{salt:$,timeCost:q.time,memoryCost:q.mem,parallelism:q.parallelism,outputLen:32,algorithm:Z.Algorithm.Argon2id})).split("$").pop();if(!z)throw Error("Unexpected argon2 hash format");let X=Buffer.from(z,"base64");return Y.fill(0),{hash:new Uint8Array(X)}}if(J==="browser")return await e$(),iU.hash({pass:U,salt:$,time:q.time,mem:q.mem,parallelism:q.parallelism,hashLen:32,type:iU.ArgonType.Argon2id}).then((Z)=>{if(!Z||!Z.hash)throw new zU("Failed to produce key derivation");return{hash:Z.hash}}).catch((Z)=>{let Y=Z instanceof Error?Z.message:typeof Z==="string"?Z:"Unknown error";throw new zU(`argon2-browser failure: ${Y}`)});throw Error(`Unsupported environment: ${J}`)}class sU{presets;exportExtractable;name="argon2id";constructor(U,$=!1){this.presets=U;this.exportExtractable=$}async derive(U,$,q,J){let{hash:Z}=await z$(U,$,this.presets[q],J.isNode?"node":"browser");if(this.exportExtractable)return J.subtle.importKey("raw",Z,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]);else return J.subtle.importKey("raw",Z,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}}var X$={low:{time:5,mem:65536,parallelism:1},middle:{time:20,mem:65536,parallelism:1},high:{time:40,mem:65536,parallelism:1}},Uq={id:0,cipher:$U,kdf:new sU(X$),saltLengths:{low:12,high:16},difficulties:X$,defaultChunkSize:524288};p.register(Uq);var G$={low:{time:5,mem:65536,parallelism:2},middle:{time:10,mem:98304,parallelism:4},high:{time:20,mem:98304,parallelism:4}},$q={id:1,cipher:qU,kdf:new sU(G$,!0),saltLengths:{low:12,high:16},difficulties:G$,defaultChunkSize:524288};p.register($q);var nU=1;function AU(U,$,q,J,Z){let Y={low:0,middle:1,high:2};if(!($ in Y))throw TypeError(`Unsupported difficulty: ${$}`);let Q=Y[$],z=U<<5|(q==="high"?1:0)<<2|Q,X=DU(new Uint8Array([nU,z]),J);if(Z)Z.setAAD(X);return X}function JU(U,$){if(U[0]!==nU)throw new a("Invalid input format. The input is unknown.");if(U.length<14)throw new a("Invalid input format. Header too short.");try{let q=U[1],J=q>>5,Z=q>>2&1?"high":"low",Y=q&3,Q=["low","middle","high"][Y],z=p.get(J).saltLengths[Z],X=2+z;if(U.length<X)throw new a("Invalid input format. Header truncated.");if($)$.setAAD(U.subarray(0,X));let G=U.slice(2,2+z);return{scheme:J,difficulty:Q,saltStrength:Z,salt:G,headerLen:X}}catch(q){throw new HU(q instanceof Error?q.message:String(q))}}async function oU(U){if(U instanceof Uint8Array)return U;if(U instanceof ArrayBuffer)return new Uint8Array(U);return new Uint8Array(await U.arrayBuffer())}function F0(U){let $=new Uint8Array(4);return new DataView($.buffer).setUint32(0,U,!1),$}function K$(U,$=0){if(U.length-$<4)throw RangeError("Not enough bytes for frame header");return new DataView(U.buffer,U.byteOffset+$,4).getUint32(0,!1)}var TU=4;class xU{engine;chunkSize;buffer=new Uint8Array(0);constructor(U,$=524288){this.engine=U;this.chunkSize=$}toTransformStream(){return new TransformStream({transform:async(U,$)=>{await this.transform(await oU(U),$)},flush:async(U)=>this.flush(U)})}async transform(U,$){if(U.length>Math.min(this.chunkSize*4,67108864))throw RangeError(`Input block (${U.length} B) exceeds maximum allowed ${Math.min(this.chunkSize*4,67108864)} B`);let J=new Uint8Array(this.buffer.length+U.length);J.set(this.buffer),J.set(U,this.buffer.length);let Z=0;while(J.length-Z>=this.chunkSize){let Y=J.slice(Z,Z+this.chunkSize);Z+=this.chunkSize;let Q=await this.engine.encryptChunk(Y),z=new Uint8Array(TU+Q.length);z.set(F0(Q.length)),z.set(Q,TU),$.enqueue(z)}this.buffer=J.slice(Z)}async flush(U){if(!this.buffer.length)return;let $=await this.engine.encryptChunk(this.buffer),q=new Uint8Array(TU+$.length);q.set(F0($.length)),q.set($,TU),U.enqueue(q),this.buffer=new Uint8Array(0),this.engine.zeroKey()}}class CU{engine;chunkSize;buffer=new Uint8Array(0);constructor(U,$=524288){this.engine=U;this.chunkSize=$}toTransformStream(){return new TransformStream({transform:async(U,$)=>{await this.transform(await oU(U),$)},flush:async(U)=>this.flush(U)})}async transform(U,$){let q=new Uint8Array(this.buffer.length+U.length);q.set(this.buffer),q.set(U,this.buffer.length);let J=0;while(!0){if(q.length-J<TU)break;let Z=K$(q,J),Y=67108864,Q=this.engine.IV_LENGTH+this.engine.TAG_LENGTH;if(!Number.isInteger(Z)||Z<Q||Z>Y){$.error(new g(`Invalid frame length ${Z} (min=${Q}, max=${Y})`));return}if(q.length-J-TU<Z)break;J+=TU;let z=q.slice(J,J+Z);J+=Z;try{let X=await this.engine.decryptChunk(z);$.enqueue(X)}catch(X){$.error(X instanceof g?X:new g("Decryption failed: Wrong passphrase or corrupted ciphertext"));return}}this.buffer=q.slice(J)}async flush(U){await this.transform(new Uint8Array(0),U);let $=this.buffer.byteLength;if(this.buffer=new Uint8Array(0),this.engine.zeroKey(),$!==0){U.error(new g("Truncated ciphertext: incomplete final frame"));return}}}async function T$(U,$){let q=U.getReader(),J=$&&$.length?[$]:[];try{while(!0){let{value:z,done:X}=await q.read();if(X)break;J.push(z)}}finally{q.releaseLock()}let Z=J.reduce((z,X)=>z+X.byteLength,0),Y=new Uint8Array(Z),Q=0;for(let z of J)Y.set(z,Q),Q+=z.byteLength;return Y}class kU{engine;chunkSize;constructor(U,$=524288){this.engine=U;this.chunkSize=$}encryptionStream(){let U=new xU(this.engine,this.chunkSize).toTransformStream();return{writable:U.writable,readable:U.readable}}decryptionStream(U){let $=U,q=new TransformStream({transform(Z,Y){if($===0){Y.enqueue(Z);return}if(Z.byteLength<=$){$-=Z.byteLength;return}Y.enqueue(Z.slice($)),$=0}}),J=new CU(this.engine,this.chunkSize).toTransformStream();return{writable:q.writable,readable:q.readable.pipeThrough(J)}}async collect(U,$,q=null){return T$(U.pipeThrough($),q??void 0)}getEngine(){return this.engine}}function W$(U){try{if(U)U.fill(0)}catch{}}function qq(U){let $="";for(let q=0;q<U.length;q++){let J=U[q].toString(16).padStart(2,"0");$+=J}return $}class WU{bytes;destroyed=!1;static from(U){if(U instanceof WU)return U;if(typeof U==="string")return new WU(new TextEncoder().encode(U));if(U instanceof Uint8Array)return new WU(U);throw TypeError("ConvertibleInput: unsupported input type")}constructor(U){this.bytes=U}toUint8Array(){if(this.destroyed)throw Error("ConvertibleInput: already cleared");return this.bytes}clear(){if(!this.destroyed)W$(this.bytes),this.bytes=new Uint8Array(0),this.destroyed=!0}}class gU{bytes;destroyed=!1;constructor(U){this.bytes=U}get uint8array(){if(this.destroyed)throw Error("ConvertibleOutput: already cleared");return this.bytes}get base64(){if(this.destroyed)throw Error("ConvertibleOutput: already cleared");return OU(this.bytes)}get hex(){if(this.destroyed)throw Error("ConvertibleOutput: already cleared");return qq(this.bytes)}get text(){if(this.destroyed)throw Error("ConvertibleOutput: already cleared");return new TextDecoder().decode(this.bytes)}clear(){if(!this.destroyed)W$(this.bytes),this.bytes=new Uint8Array(0),this.destroyed=!0}toString(){return this.base64}}class hU extends Error{constructor(U="Malformed padding"){super(U)}}class u{static STRUCT_SIZE=8;static MAGIC40=new Uint8Array([196,231,155,173,242]);static VERSION=41;static CRC8_POLY=7;maxPad=u.STRUCT_SIZE+8-1;static ctEqU8(U,$){return(((U|0)^($|0))&255)===0}static ctEqFixedLen(U,$){let q=0,J=U.length;for(let Z=0;Z<J;Z++)q|=U[Z]^$[Z];return q===0}crc8(U){let $=0;for(let q=0;q<U.length;q++){$^=U[q]&255;for(let J=0;J<8;J++)$=$&128?$<<1^u.CRC8_POLY:$<<1,$&=255}return $&255}computeK(U,$){let q=u.STRUCT_SIZE;if(!Number.isInteger($)||$<1)throw new hU("align must be a positive integer");if(q+$-1>255)throw new hU("align too large for 1-byte LEN");let J=q+$-1,Z=($-U%$)%$;if(Z===0)Z=$;while(Z<q)Z+=$;if(Z>J)throw new hU("Cannot satisfy alignment within 1-byte LEN");return Z}pad(U,$,q=8){let J=u.STRUCT_SIZE,Z=this.computeK(U.length,q),Y=Z-J,Q=new Uint8Array(U.length+Z);if(Q.set(U,0),Y>0){let G=$(Y);if(!G||G.length!==Y)throw new hU("rng returned wrong length");Q.set(G,U.length)}let z=U.length+Y;Q.set(u.MAGIC40,z+0),Q[z+5]=u.VERSION&255,Q[z+6]=Z&255;let X=new Uint8Array(7);return X.set(u.MAGIC40,0),X[5]=u.VERSION&255,X[6]=Z&255,Q[z+7]=this.crc8(X),Q}tryUnpad(U){let $=u.STRUCT_SIZE,q=()=>({used:!1,plain:U});if(U.length<$)return q();let J=U.length,Z=U[J-1]&255,Y=U[J-2]&255,Q=U[J-3]&255;if(Y<$||Y>U.length)return q();let z=J-$,X=U.subarray(z,z+5);if(!u.ctEqFixedLen(X,u.MAGIC40))return q();if(!u.ctEqU8(Q,u.VERSION&255))return q();let K=new Uint8Array(7);K.set(u.MAGIC40,0),K[5]=Q,K[6]=Y;let T=this.crc8(K);if(!u.ctEqU8(T,Z))return q();return{used:!0,plain:U.subarray(0,J-Y)}}}function H$(U=0,$=console.info){return{level:U,log(q,J){if(q<=U)$(`${q}| ${J}`)}}}var R$=new WeakMap;class VU{static getEngine(U,$){let q=R$.get(U);if(!q)q=new Map,R$.set(U,q);let J=q.get($);if(J)return J;let Z=p.get($);return J={desc:Z,cipher:new Z.cipher(U),kdf:Z.kdf,chunkSize:Z.defaultChunkSize,provider:U},q.set($,J),J}static async deriveKey(U,$,q,J){try{let Z=await U.kdf.derive($.value,q,J,U.provider);await U.cipher.setKey(Z)}catch(Z){let Y=Z instanceof Error?Z.message:String(Z);throw new zU(Y)}finally{i($)}}}class n{provider;v;cipher;kdf;chunkSize;stream;acceptUnauthenticatedHeader;difficulty;saltStrength;engines=new Map;log;constructor(U,$={}){this.provider=U;this.v=p.get($.scheme??p.current.id),this.cipher=new this.v.cipher(U),this.kdf=this.v.kdf,this.chunkSize=this.setChunkSize($.chunkSize??this.v.defaultChunkSize),this.stream=new kU(this.cipher,this.chunkSize),this.difficulty=$.difficulty??"middle",this.saltStrength=$.saltStrength??"high",this.acceptUnauthenticatedHeader=$.acceptUnauthenticatedHeader??!1,this.log=H$($.verbose??0,$.logger)}static async isEncrypted(U){try{return await n.peekHeader(U),!0}catch{return!1}}static async decodeHeader(U){let $=await n.peekHeader(U),q=JU($);return{scheme:q.scheme,difficulty:q.difficulty,salt:OU(q.salt),saltBytes:q.salt,saltLength:q.salt.byteLength}}static async headerDecode(U){return this.decodeHeader(U)}static isRandomAccessSource(U){return typeof U==="object"&&U!==null&&typeof U.read==="function"}static async decodeData(U){let $=n.isRandomAccessSource(U)?U:new R0(U),q=await $.read(0,Math.min(256,$.length)),J=await n.peekHeader(q),{scheme:Z,headerLen:Y}=JU(J),Q=$.length,z=Q-Y;if(z<0)throw new a("Payload underflow");if(z===0)return{isChunked:!0,chunks:{chunkSize:0,count:0,totalPayload:0}};let X=await $.read(Y,4),G=new DataView(X.buffer,X.byteOffset,4).getUint32(0,!1);if(G+4<=z&&G>=28){let B=G,V=Y,j=0,S=0;while(V+4<=Q){let F=await $.read(V,4),w=new DataView(F.buffer,F.byteOffset,4).getUint32(0,!1);if(w===0||V+4+w>Q)break;j++,S+=w,V+=4+w}return{isChunked:!0,chunks:{chunkSize:B,count:j,totalPayload:S}}}let T=await $.read(Y,z),R=p.get(Z).cipher.IV_LENGTH,H=p.get(Z).cipher.TAG_LENGTH;if(T.length<R+H)throw new a("Ciphertext too short for IV & tag");return{isChunked:!1,payloadLength:z-R-H,params:{iv:T.slice(0,R),ivLength:R,tag:T.slice(T.length-H),tagLength:H}}}setDifficulty(U){this.difficulty=U}getDifficulty(){return this.difficulty}setScheme(U){this.v=p.get(U),this.cipher=new this.v.cipher(this.provider),this.kdf=this.v.kdf,this.stream=new kU(this.cipher,this.chunkSize)}getScheme(){return this.v.id}setSaltDifficulty(U){this.saltStrength=U}getSaltDifficulty(){return this.saltStrength}setChunkSize(U){let q=U,J;if(q==null)J=this.v.defaultChunkSize;else{if(J=Number(q),!Number.isInteger(J)||J<1)throw Error(`Invalid chunkSize: ${q}. Must be a positive integer.`);if(J>134217728)throw RangeError("chunkSize cannot exceed 134217728 bytes.")}if(this.chunkSize=J,this.stream)this.stream=new kU(this.cipher,this.chunkSize);return J}getChunkSize(){return this.chunkSize}setVerbose(U){this.log.level=U}getVerbose(){return this.log.level}async encryptText(U,$){if($===null)throw new UU("Password can't be null");let q={value:$};try{if($==="")this.log.log(0,"Empty passphrase provided to encryptText");this.log.log(1,`Start text encryption, scheme: ${this.getScheme()}`);let J=WU.from(U),Z=J.toUint8Array();this.log.log(2,"Deriving key for text encryption");let Y=this.genSalt();await this.deriveKey(q,Y),i(q),$=null,this.log.log(3,`Salt generated: ${OU(Y)}, KDF difficulty: ${this.difficulty}`),this.log.log(3,"Encoding header");let Q=AU(this.v.id,this.difficulty,this.saltStrength,Y,this.cipher);this.cipher.setPaddingScheme(new u),this.cipher.setPaddingAlign(8),this.cipher.setPaddingAADMode("require"),this.log.log(2,"Encrypting text data");let z=await this.cipher.encryptChunk(Z);this.cipher.zeroKey();try{J.clear()}catch{}let X=DU(Q,z);return this.log.log(1,"Encryption finished"),new gU(X)}catch(J){throw new UU(J instanceof Error?J.message:String(J))}}async decryptText(U,$){if($===null)throw new UU("Password can't be null");let q={value:$};try{if($==="")this.log.log(0,"Empty passphrase provided to decryptText");this.log.log(1,`Start text decryption, Version ${this.getScheme()}`);let J;if(typeof U==="string")this.log.log(3,"Decoding Base64 ciphertext"),J=fU(U);else if(U instanceof Uint8Array)J=U;else if(U instanceof WU)J=U.toUint8Array();else throw new LU("Unsupported ciphertext input type");this.log.log(3,"Start header decoding");let Z=JU(J);this.log.log(3,"Selecting decryption engine");let Y=VU.getEngine(this.provider,Z.scheme);this.log.log(2,`Deriving key via engine for scheme: ${Z.scheme}`),this.log.log(3,`Salt use: ${OU(Z.salt)}, KDF difficulty: ${Z.difficulty}`);try{await VU.deriveKey(Y,q,Z.salt,Z.difficulty)}finally{i(q),$=null}Y.cipher.setPaddingScheme(new u),Y.cipher.setPaddingAlign(8),Y.cipher.setPaddingAADMode("require"),Y.cipher.setLegacyAADFallback({enabled:!0,policy:"auto",tryEmptyAAD:this.acceptUnauthenticatedHeader?!0:!1}),this.log.log(2,"Decrypting text data"),JU(J,Y.cipher);let Q=await Y.cipher.decryptChunk(J.slice(Z.headerLen));if(Y.cipher.zeroKey(),U instanceof WU)try{U.clear()}catch{}return this.log.log(1,"Decryption finished"),new gU(Q)}catch(J){if(J instanceof g||J instanceof a||J instanceof HU||J instanceof LU||J instanceof zU)throw J;throw new g("Decryption failed: wrong passphrase or corrupted ciphertext")}}async encryptFile(U,$){if($===null)throw new UU("Password can't be null");let q={value:$};try{if(U.size===0){let Q=this.genSalt();await this.deriveKey(q,Q),i(q),$=null;let z=AU(this.v.id,this.difficulty,this.saltStrength,Q);return new Blob([z],{type:"application/octet-stream"})}this.log.log(2,"Deriving key for file encryption");let J=this.genSalt();await this.deriveKey(q,J),i(q),$=null;let Z=AU(this.v.id,this.difficulty,this.saltStrength,J,this.stream.getEngine());this.stream.getEngine().setPaddingAADMode("forbid");let Y=await this.stream.collect(U.stream(),new xU(this.cipher,this.chunkSize).toTransformStream(),Z);return new Blob([Y],{type:"application/octet-stream"})}catch(J){throw new UU(J instanceof Error?J.message:String(J))}}async decryptFile(U,$){if($===null)throw new UU("Password can't be null");let q={value:$};try{let J=await n.peekHeader(U),Z=JU(J),Y=VU.getEngine(this.provider,Z.scheme);try{await VU.deriveKey(Y,q,Z.salt,Z.difficulty)}finally{i(q),$=null}if(U.size===Z.headerLen)return new Blob([],{type:"application/octet-stream"});this.log.log(2,"Decrypting file data");let Q=new kU(Y.cipher,Y.chunkSize);JU(J,Q.getEngine()),Y.cipher.setPaddingAADMode("forbid"),Y.cipher.setLegacyAADFallback({enabled:!0,policy:"auto",tryEmptyAAD:this.acceptUnauthenticatedHeader?!0:!1});let z=await Q.collect(U.slice(Z.headerLen).stream(),new CU(Y.cipher,Y.chunkSize).toTransformStream());return new Blob([z],{type:"application/octet-stream"})}catch(J){if(J instanceof g)throw J;throw new g(J instanceof Error?J.message:String(J))}}async createEncryptionStream(U){if(U===null)throw new UU("Password can't be null");let $={value:U};this.log.log(2,"Deriving key for stream encryption");let q=this.genSalt();await this.deriveKey($,q),i($),U=null;let J=AU(this.v.id,this.difficulty,this.saltStrength,q,this.stream.getEngine());this.stream.getEngine().setPaddingAADMode("forbid");let Z=this.stream.encryptionStream();return{header:J,writable:Z.writable,readable:Z.readable}}async createDecryptionStream(U){if(U===null)throw new UU("Password can't be null");let $=this.provider,q={value:U},J=new Uint8Array(0),Z=null,Y=65536,Q=2,z=async(X,G)=>{let K=X.getReader();while(!0){let{value:T,done:R}=await K.read();if(R)break;G.enqueue(T)}};return new TransformStream({transform:async(X,G)=>{if(!Z){let T=new Uint8Array(0);if(X&&X.byteLength){let _=Math.max(0,Y-J.byteLength),s=_?X.subarray(0,_):new Uint8Array(0);if(T=X.subarray(s.byteLength),s.byteLength){let h=new Uint8Array(J.byteLength+s.byteLength);h.set(J),h.set(s,J.byteLength),J=h}}if(J.byteLength<Q)return;let R=J[1],H=R>>5,B=R>>2&1?"high":"low",V=0;try{V=2+p.get(H).saltLengths[B]}catch(_){i(q),G.error(new HU(_ instanceof Error?_.message:String(_)));return}if(J.byteLength<V){if(J.byteLength>=Y)i(q),G.error(new a(`Header not found within ${Y} bytes`));return}let j=J.subarray(0,V),S;try{S=JU(j)}catch(_){i(q),G.error(_ instanceof Error?_:new HU("Invalid header"));return}let F=VU.getEngine($,S.scheme);try{await VU.deriveKey(F,q,S.salt,S.difficulty)}finally{i(q),U=null}JU(j,F.cipher),F.cipher.setPaddingAADMode("forbid"),F.cipher.setLegacyAADFallback({enabled:!0,policy:"auto",tryEmptyAAD:this.acceptUnauthenticatedHeader?!0:!1}),Z=new CU(F.cipher,F.chunkSize).toTransformStream(),z(Z.readable,G).catch((_)=>G.error(_));let w=J.subarray(V);if(J=new Uint8Array(0),w.byteLength||T.byteLength){let _=Z.writable.getWriter();if(w.byteLength)await _.write(w);if(T.byteLength)await _.write(T);_.releaseLock()}return}let K=Z.writable.getWriter();await K.write(X),K.releaseLock()},flush:async()=>{if(!Z)throw i(q),new a("Header not found before end of stream");let X=Z.writable.getWriter();await X.close(),X.releaseLock()}})}generateFakeData(U=0,$=!1){if(!Number.isInteger(U)||U<0)throw RangeError("payloadLength must be a non-negative integer.");let q=this.genSalt(),J=AU(this.v.id,this.difficulty,this.saltStrength,q,this.cipher),Z=U;if($){let X=Math.max(16,Z);Z=Math.ceil(X/8)*8}let Y=Z>0?this.provider.getRandomValues(new Uint8Array(Z)):new Uint8Array(0);return DU(J,Y)}async deriveKey(U,$,q=this.difficulty){let J=performance.now();try{let Z=await this.kdf.derive(U.value,$,q,this.provider);i(U),await this.cipher.setKey(Z),this.log.log(3,`Key derivation completed in ${(performance.now()-J).toFixed(1)} ms`)}catch(Z){throw new zU(Z instanceof Error?Z.message:String(Z))}}genSalt(U=this.saltStrength){let $=this.v.saltLengths[U];return this.provider.getRandomValues(new Uint8Array($))}static async peekHeader(U){let $=await this.readAsUint8(U);if($.length<2)throw new a("Input too short");let{headerLen:q}=JU($.length>=32?$:$.slice());if($.length<q)throw new a("Incomplete header");return $.slice(0,q)}static async readAsUint8(U){if(typeof U==="string")return fU(U);if(U instanceof Uint8Array)return U;if(U instanceof Blob){let $=Math.max(32,Math.min(256,U.size)),q=U.slice(0,$);return new Uint8Array(await q.arrayBuffer())}throw new HU("Unsupported input type")}}var aU=require("node:crypto"),V$={subtle:aU.webcrypto.subtle,getRandomValues(U){return aU.randomFillSync(U),U},isNode:!0};function vU(U){return new n(V$,U)}var ZU=require("node:path");var rU=require("node:stream");function _0(U){return rU.Readable.toWeb(U)}function M0(U){return rU.Writable.toWeb(U)}var NU=require("fs"),I$=IU(require("os")),w0=IU(require("path")),Jq="2.2.1",Zq=process.cwd();async function tU(){if(!N.stdin.isTTY)throw Error("STDIN not a TTY; use --pass");N.stderr.write("Passphrase: "),N.stdin.setRawMode?.(!0),N.stdin.resume(),N.stdin.setEncoding("utf8");let U="";return new Promise(($)=>{function q(){N.stdin.setRawMode?.(!1),N.stdin.pause(),N.stderr.write(`
`),N.stdin.off("data",J),$(U)}function J(Z){if(Z==="\x03")N.exit(130);if(Z==="\r"||Z===`
`)return q();if(Z==="\b"||Z===""){U=U.slice(0,-1);return}U+=Z}N.stdin.on("data",J)})}function P0(U,$=Zq){if(U==="-")return;let q=t.realpathSync($),J=ZU.isAbsolute(U)?ZU.resolve(U):ZU.resolve(q,U),Z=ZU.dirname(J);if(!t.existsSync(Z))throw new RU(`Output directory does not exist: ${Z}`);let Y=t.realpathSync(Z);if(!Y.startsWith(q+ZU.sep))throw new RU("Refusing to write outside of root directory.");if(!Y.startsWith(q+ZU.sep))throw new RU("Refusing to write outside of root directory.");if(!t.existsSync(Z))throw new RU(`Output directory does not exist: ${Z}`);try{t.accessSync(Z,t.constants.W_OK)}catch{throw new RU("Output directory is not writeable")}return J}async function N$(){let U=[];for await(let $ of N.stdin)U.push($);return Buffer.concat(U).toString("utf8")}var o=new p0;o.name("cryptit").version(Jq).description(`Text and File Encryption Utility
Scheme 0: AES-GCM (Native) / Argon2id (Single Thread)
Scheme 1: XChaCha20-Poly1305 (JS Engine) / Argon2id (Parallel)`).showHelpAfterError().showSuggestionAfterError().addOption(new jU("-S, --scheme <0-1>","encryption scheme version").argParser((U)=>{let $=Number(U);if(!Number.isInteger($)||$<0||$>7)throw Error("Version size must be a integer between 0 and 7");return $}).default(0,"0")).addOption(new jU("-p, --pass <passphrase>","passphrase (prompt if omitted)").hideHelp().argParser((U)=>{if(!U.trim())throw Error("Passphrase cannot be empty");return U})).addOption(new jU("-d, --difficulty <level>","argon2 difficulty").choices(["low","middle","high"]).default("middle","middle")).addOption(new jU("-s, --salt-strength <variant>","salt length variant").choices(["low","high"]).default("high","high")).addOption(new jU("-c, --chunk-size <bytes>","chunk size in bytes").argParser((U)=>{let $=Number(U);if(!Number.isInteger($)||$<=0)throw Error("Chunk size must be a positive integer");return $}).default(524288,"512*1024")).addOption(new jU("-v, --verbose","increase verbosity (use multiple times)").default(0).argParser((U,$)=>{return $+1}));process.on("uncaughtException",(U)=>{if(U instanceof Error){let $=U.constructor.name,q=U.message;N.stderr.write(`Error [${$}]: ${q}
`)}else N.stderr.write(`Error [Unknown]: ${String(U)}
`);N.exit(1)});process.on("unhandledRejection",(U)=>{if(U instanceof Error){let $=U.constructor.name,q=U.message;N.stderr.write(`Error [${$}]: ${q}
`)}else N.stderr.write(`Error [Unknown]: ${String(U)}
`);N.exit(1)});o.command("decode [src]").description("Show Cryptit header information plus payload details; omit arg or use - to read from STDIN").action(async(U)=>{let $=!U||U==="-";async function q(X){if(X.length<2)throw Error("Input too short for header");let G=X.subarray(0,Math.min(256,X.length)),K=await n.decodeHeader(G),T=await n.decodeData(X);if(delete K.saltBytes,T.isChunked){let{chunkSize:B,count:V,totalPayload:j}=T.chunks;return{...K,isChunked:!0,chunks:{chunkSize:B,count:V,totalPayload:j}}}let R=Buffer.from(T.params.iv).toString("base64"),H=Buffer.from(T.params.tag).toString("base64");return{...K,isChunked:!1,payloadLength:T.payloadLength,params:{iv:R,ivLength:T.params.ivLength,tag:H,tagLength:T.params.tagLength}}}async function J(X){let G=await X.read(0,Math.min(256,X.length)),K=await n.decodeHeader(G),T=await n.decodeData(X);if(delete K.saltBytes,T.isChunked){let{chunkSize:B,count:V,totalPayload:j}=T.chunks;return{...K,isChunked:!0,chunks:{chunkSize:B,count:V,totalPayload:j}}}let R=Buffer.from(T.params.iv).toString("base64"),H=Buffer.from(T.params.tag).toString("base64");return{...K,isChunked:!1,payloadLength:T.payloadLength,params:{iv:R,tag:H}}}async function Z(){let X=Number(process.env.CRYPTIT_STDIN_MAX_BYTES),G=10737418240,K=Number.isFinite(X)&&X>0?Math.floor(X):10737418240,T=await NU.promises.mkdtemp(w0.join(I$.tmpdir(),"cryptit-")),R=w0.join(T,"stdin.bin"),H=SU.createWriteStream(R,{flags:"w"}),B=0;try{for await(let V of process.stdin){let j=Buffer.isBuffer(V)?V:Buffer.from(V);if(B+=j.length,B>K)throw H.destroy(),await NU.promises.rm(T,{recursive:!0,force:!0}).catch(()=>{}),new RU(`STDIN exceeds maximum allowed size (${K} bytes). Aborting.`);if(!H.write(j))await new Promise((S)=>H.once("drain",S))}return await new Promise((V,j)=>{H.end(()=>V()),H.on("error",j)}),R}catch(V){throw H.destroy(),await NU.promises.rm(T,{recursive:!0,force:!0}).catch(()=>{}),V}}if(!$&&U){let X=await bU.open(U);try{let G=await J(X);N.stdout.write(JSON.stringify(G,null,2)+`
`)}finally{await X.close()}return}if($){let X=await Z(),G=await bU.open(X);try{try{let B=await J(G);N.stdout.write(JSON.stringify(B,null,2)+`
`);return}catch{}}finally{await G.close()}let K=(await NU.promises.readFile(X,{encoding:"utf8"})).trim();if(await NU.promises.unlink(X),!(/^[A-Za-z0-9+/]+={0,2}$/.test(K)&&K.length%4===0))N.stderr.write(`Error: Input neither valid Cryptit binary nor Base-64 text
`),N.exit(1);let R=Buffer.from(K,"base64"),H=await q(new Uint8Array(R));N.stdout.write(JSON.stringify(H,null,2)+`
`);return}let Y=Buffer.from(U,"utf8"),Q=Y.toString("utf8").trim(),z=/^[A-Za-z0-9+/]+={0,2}$/.test(Q)&&Q.length%4===0;try{if(z){let X=Buffer.from(Q,"base64"),G=await q(new Uint8Array(X));N.stdout.write(JSON.stringify(G,null,2)+`
`)}else{let X=await q(new Uint8Array(Y));N.stdout.write(JSON.stringify(X,null,2)+`
`)}}catch(X){let G=X instanceof Error?X.message:String(X);N.stderr.write(`Error: ${G}
`),N.exit(1)}});o.command("encrypt <src>").description("Encrypt file; use - for STDIN, --out - for STDOUT").option("-p, --pass <passphrase>","passphrase (prompt if omitted)").option("-o, --out <file>","output file (default STDOUT)","-").action(async(U,$)=>{if(U!=="-"&&!t.existsSync(U))N.stderr.write(`Error: input file not found: ${U}
`),N.exit(1);let q=o.opts(),J=vU({difficulty:q.difficulty,saltStrength:q.saltStrength,chunkSize:q.chunkSize,verbose:q.verbose,scheme:q.scheme}),Z=q.pass??(N.stdin.isTTY?await tU():(()=>{N.stderr.write(`Use --pass when piping via STDIN
`),N.exit(1)})());try{P0($.out)}catch(H){N.stderr.write(`Error: ${H.message}
`),N.exit(1)}let Y=U==="-"?N.stdin:SU.createReadStream(U),Q=$.out==="-"?N.stdout:SU.createWriteStream($.out),{header:z,writable:X,readable:G}=await J.createEncryptionStream(Z),K=_0(Y),T=M0(Q),R=T.getWriter();await R.write(z),R.releaseLock(),await Promise.all([K.pipeTo(X),G.pipeTo(T)])});o.command("decrypt <src>").description("Decrypt file; use - for STDIN, --out - for STDOUT").option("-p, --pass <passphrase>","passphrase (prompt if omitted)").option("-o, --out <file>","output file (default STDOUT)","-").option("--legacy","Enable text decryption of version < 1.0.0",!1).action(async(U,$)=>{if(U!=="-"&&!t.existsSync(U))N.stderr.write(`Error: input file not found: ${U}
`),N.exit(1);let q=o.opts(),J=vU({difficulty:q.difficulty,saltStrength:q.saltStrength,chunkSize:q.chunkSize,verbose:q.verbose,scheme:q.scheme,acceptUnauthenticatedHeader:$.legacy});try{P0($.out)}catch(K){N.stderr.write(`Error: ${K.message}
`),N.exit(1)}let Z=q.pass??await tU(),Y=U==="-"?N.stdin:SU.createReadStream(U),Q=$.out==="-"?N.stdout:SU.createWriteStream($.out),z=_0(Y),X=M0(Q),G=await J.createDecryptionStream(Z);await Promise.all([z.pipeTo(G.writable),G.readable.pipeTo(X)])});o.command("encrypt-text [text]").description("Encrypt plaintext; omit arg to read from STDIN").option("-p, --pass <passphrase>","passphrase (prompt if omitted)").action(async(U)=>{let $=o.opts(),q=vU({difficulty:$.difficulty,saltStrength:$.saltStrength,verbose:$.verbose,scheme:$.scheme}),J=$.pass??(N.stdin.isTTY?await tU():(()=>{N.stderr.write(`Use --pass when piping via STDIN
`),N.exit(1)})()),Z=U??await N$(),Y=await q.encryptText(Z,J);N.stdout.write(Y.base64+`
`)});o.command("decrypt-text [b64]").description("Decrypt Base64 ciphertext; omit arg to read from STDIN").option("-p, --pass <passphrase>","passphrase (prompt if omitted)").option("--legacy","Enable text decryption of version < 1.0.0",!1).action(async(U,$)=>{let q=o.opts(),J=vU({difficulty:q.difficulty,saltStrength:q.saltStrength,verbose:q.verbose,scheme:q.scheme,acceptUnauthenticatedHeader:$.legacy}),Z=q.pass??await tU(),Y=U??(await N$()).trim();if(!/^[A-Za-z0-9+/]+={0,2}$/.test(Y))N.stderr.write(`Error: ciphertext does not look like Base64
`),N.exit(1);let Q=await J.decryptText(Y,Z);N.stdout.write(Q.text+`
`)});o.command("fake-data <length>").description("Emit a valid Cryptit header followed by <length> random bytes").option("-o, --out <file>","output file (default STDOUT)","-").option("--base64","encode output as Base64 text (adds trailing newline)").option("--use-padding","rounds <length> to the nearest 8 bytes to allow for realistic text-payloads.",!1).action(async(U,$)=>{let q=Number(U);if(!Number.isInteger(q)||q<0)N.stderr.write(`Error: <length> must be a non-negative integer
`),N.exit(1);let J=o.opts(),Z=vU({difficulty:J.difficulty,saltStrength:J.saltStrength,chunkSize:J.chunkSize,verbose:J.verbose,scheme:J.scheme});try{P0($.out)}catch(z){N.stderr.write(`Error: ${z.message}
`),N.exit(1)}let Y=Z.generateFakeData(q,$.usePadding),Q=Buffer.from(Y);if($.base64){let z=Q.toString("base64")+`
`;if($.out==="-")N.stdout.write(z);else await NU.promises.writeFile($.out,z,{encoding:"utf8"});return}if($.out==="-")N.stdout.write(Q);else await NU.promises.writeFile($.out,Q)});if(process.argv.length<=2)o.outputHelp(),process.exit(1);o.parse();

//# debugId=8082B1741C97494D64756E2164756E21
