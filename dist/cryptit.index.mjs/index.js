import{createRequire as uA}from"node:module";var hA=Object.create;var{getPrototypeOf:fA,defineProperty:$A,getOwnPropertyNames:bA}=Object;var gA=Object.prototype.hasOwnProperty;var nA=(A,U,S)=>{S=A!=null?hA(fA(A)):{};let V=U||!A||!A.__esModule?$A(S,"default",{value:A,enumerable:!0}):S;for(let Y of bA(A))if(!gA.call(V,Y))$A(V,Y,{get:()=>A[Y],enumerable:!0});return V};var m=(A,U)=>()=>(U||A((U={exports:{}}).exports,U),U.exports);var _=uA(import.meta.url);var WA=m((F8,QA)=>{var f=/^[a-z0-9-]{1,32}$/,b=/^[a-z0-9-]{1,32}$/,g=/^[a-zA-Z0-9/+.-]+$/,zA=/^([a-zA-Z0-9/+.-]+|)$/,lA=/^((-)?[1-9]\d*|0)$/,p=/^v=(\d+)$/;function oA(A){return R(A).map((U)=>[U,A[U]].join("=")).join(",")}function dA(A){let U={};return A.split(",").forEach((S)=>{let V=S.split("=");if(V.length<2)throw new TypeError("params must be in the format name=value");U[V.shift()]=V.join("=")}),U}function R(A){return Object.keys(A)}function JA(A){if(typeof Object.values==="function")return Object.values(A);return R(A).map((U)=>A[U])}function iA(A){let U=[""];if(typeof A!=="object"||A===null)throw new TypeError("opts must be an object");if(typeof A.id!=="string")throw new TypeError("id must be a string");if(!f.test(A.id))throw new TypeError(`id must satisfy ${f}`);if(U.push(A.id),typeof A.version!=="undefined"){if(typeof A.version!=="number"||A.version<0||!Number.isInteger(A.version))throw new TypeError("version must be a positive integer number");U.push(`v=${A.version}`)}if(typeof A.params!=="undefined"){if(typeof A.params!=="object"||A.params===null)throw new TypeError("params must be an object");let V=R(A.params);if(!V.every(($)=>b.test($)))throw new TypeError(`params names must satisfy ${b}`);V.forEach(($)=>{if(typeof A.params[$]==="number")A.params[$]=A.params[$].toString();else if(Buffer.isBuffer(A.params[$]))A.params[$]=A.params[$].toString("base64").split("=")[0]});let Y=JA(A.params);if(!Y.every(($)=>typeof $==="string"))throw new TypeError("params values must be strings");if(!Y.every(($)=>g.test($)))throw new TypeError(`params values must satisfy ${g}`);let P=oA(A.params);U.push(P)}if(typeof A.salt!=="undefined"){if(!Buffer.isBuffer(A.salt))throw new TypeError("salt must be a Buffer");if(U.push(A.salt.toString("base64").split("=")[0]),typeof A.hash!=="undefined"){if(!Buffer.isBuffer(A.hash))throw new TypeError("hash must be a Buffer");U.push(A.hash.toString("base64").split("=")[0])}}return U.join("$")}function pA(A){if(typeof A!=="string"||A==="")throw new TypeError("pchstr must be a non-empty string");if(A[0]!=="$")throw new TypeError("pchstr must contain a $ as first char");let U=A.split("$");U.shift();let S=5;if(!p.test(U[1]))S--;if(U.length>S)throw new TypeError(`pchstr contains too many fileds: ${U.length}/${S}`);let V=U.shift();if(!f.test(V))throw new TypeError(`id must satisfy ${f}`);let Y;if(p.test(U[0]))Y=parseInt(U.shift().match(p)[1],10);let P,$;if(zA.test(U[U.length-1]))if(U.length>1&&zA.test(U[U.length-2]))P=Buffer.from(U.pop(),"base64"),$=Buffer.from(U.pop(),"base64");else $=Buffer.from(U.pop(),"base64");let z;if(U.length>0){let Q=U.pop();if(z=dA(Q),!R(z).every((W)=>b.test(W)))throw new TypeError(`params names must satisfy ${b}`);if(!JA(z).every((W)=>g.test(W)))throw new TypeError(`params values must satisfy ${g}`);R(z).forEach((W)=>{z[W]=lA.test(z[W])?parseInt(z[W],10):z[W]})}if(U.length>0)throw new TypeError(`pchstr contains unrecognized fileds: ${U}`);let J={id:V};if(Y)J.version=Y;if(z)J.params=z;if($)J.salt=$;if(P)J.hash=P;return J}QA.exports={serialize:iA,deserialize:pA}});var BA=m((H8,wA)=>{var GA=_("fs"),I=_("path"),_A=_("os"),TA=typeof __webpack_require__==="function"?__non_webpack_require__:_,rA=process.config&&process.config.variables||{},tA=!!process.env.PREBUILDS_ONLY,XA=process.versions.modules,r=eA()?"electron":sA()?"node-webkit":"node",t=process.env.npm_config_arch||_A.arch(),a=process.env.npm_config_platform||_A.platform(),qA=process.env.LIBC||(A8(a)?"musl":"glibc"),s=process.env.ARM_VERSION||(t==="arm64"?"8":rA.arm_version)||"",IA=(process.versions.uv||"").split(".")[0];wA.exports=T;function T(A){return TA(T.resolve(A))}T.resolve=T.path=function(A){A=I.resolve(A||".");try{var U=TA(I.join(A,"package.json")).name.toUpperCase().replace(/-/g,"_");if(process.env[U+"_PREBUILD"])A=process.env[U+"_PREBUILD"]}catch(J){}if(!tA){var S=ZA(I.join(A,"build/Release"),OA);if(S)return S;var V=ZA(I.join(A,"build/Debug"),OA);if(V)return V}var Y=z(A);if(Y)return Y;var P=z(I.dirname(process.execPath));if(P)return P;var $=["platform="+a,"arch="+t,"runtime="+r,"abi="+XA,"uv="+IA,s?"armv="+s:"","libc="+qA,"node="+process.versions.node,process.versions.electron?"electron="+process.versions.electron:"",typeof __webpack_require__==="function"?"webpack=true":""].filter(Boolean).join(" ");throw new Error("No native build was found for "+$+`
    loaded from: `+A+`
`);function z(J){var Q=e(I.join(J,"prebuilds")).map(KA),G=Q.filter(MA(a,t)).sort(NA)[0];if(!G)return;var Z=I.join(J,"prebuilds",G.name),W=e(Z).map(xA),F=W.filter(DA(r,XA)),H=F.sort(LA(r))[0];if(H)return I.join(Z,H.file)}};function e(A){try{return GA.readdirSync(A)}catch(U){return[]}}function ZA(A,U){var S=e(A).filter(U);return S[0]&&I.join(A,S[0])}function OA(A){return/\.node$/.test(A)}function KA(A){var U=A.split("-");if(U.length!==2)return;var S=U[0],V=U[1].split("+");if(!S)return;if(!V.length)return;if(!V.every(Boolean))return;return{name:A,platform:S,architectures:V}}function MA(A,U){return function(S){if(S==null)return!1;if(S.platform!==A)return!1;return S.architectures.includes(U)}}function NA(A,U){return A.architectures.length-U.architectures.length}function xA(A){var U=A.split("."),S=U.pop(),V={file:A,specificity:0};if(S!=="node")return;for(var Y=0;Y<U.length;Y++){var P=U[Y];if(P==="node"||P==="electron"||P==="node-webkit")V.runtime=P;else if(P==="napi")V.napi=!0;else if(P.slice(0,3)==="abi")V.abi=P.slice(3);else if(P.slice(0,2)==="uv")V.uv=P.slice(2);else if(P.slice(0,4)==="armv")V.armv=P.slice(4);else if(P==="glibc"||P==="musl")V.libc=P;else continue;V.specificity++}return V}function DA(A,U){return function(S){if(S==null)return!1;if(S.runtime&&S.runtime!==A&&!aA(S))return!1;if(S.abi&&S.abi!==U&&!S.napi)return!1;if(S.uv&&S.uv!==IA)return!1;if(S.armv&&S.armv!==s)return!1;if(S.libc&&S.libc!==qA)return!1;return!0}}function aA(A){return A.runtime==="node"&&A.napi}function LA(A){return function(U,S){if(U.runtime!==S.runtime)return U.runtime===A?-1:1;else if(U.abi!==S.abi)return U.abi?-1:1;else if(U.specificity!==S.specificity)return U.specificity>S.specificity?-1:1;else return 0}}function sA(){return!!(process.versions&&process.versions.nw)}function eA(){if(process.versions&&process.versions.electron)return!0;if(process.env.ELECTRON_RUN_AS_NODE)return!0;return typeof window!=="undefined"&&window.process&&window.process.type==="renderer"}function A8(A){return A==="linux"&&GA.existsSync("/etc/alpine-release")}T.parseTags=xA;T.matchTags=DA;T.compareTags=LA;T.parseTuple=KA;T.matchTuple=MA;T.compareTuples=NA});var CA=m((R8,UA)=>{var AA=typeof __webpack_require__==="function"?__non_webpack_require__:_;if(typeof AA.addon==="function")UA.exports=AA.addon.bind(AA);else UA.exports=BA()});var RA=m((X8,x)=>{var __dirname="/Users/maxim/Projects/Private/Sites/cryptit/node_modules/argon2",k8=_("node:assert"),{randomBytes:U8,timingSafeEqual:S8}=_("node:crypto"),{promisify:V8}=_("node:util"),{deserialize:FA,serialize:Y8}=WA(),P8=CA(),{hash:HA}=P8(__dirname),$8=V8(U8);X8.argon2d=0;X8.argon2i=1;X8.argon2id=2;var y=Object.freeze({argon2d:0,argon2i:1,argon2id:2}),z8=Object.freeze({[y.argon2d]:"argon2d",[y.argon2i]:"argon2i",[y.argon2id]:"argon2id"}),EA={hashLength:32,timeCost:3,memoryCost:65536,parallelism:4,type:2,version:19};async function J8(A,U){let{raw:S,salt:V,...Y}={...EA,...U};if(Y.hashLength>4294967295)throw new RangeError("Hash length is too large");if(Y.memoryCost>4294967295)throw new RangeError("Memory cost is too large");if(Y.timeCost>4294967295)throw new RangeError("Time cost is too large");if(Y.parallelism>16777215)throw new RangeError("Parallelism is too large");V=V??await $8(16);let{hashLength:P,secret:$=Buffer.alloc(0),type:z,version:J,memoryCost:Q,timeCost:G,parallelism:Z,associatedData:W=Buffer.alloc(0)}=Y,F=await HA({password:Buffer.from(A),salt:V,secret:$,data:W,hashLength:P,m:Q,t:G,p:Z,version:J,type:z});if(S)return F;return Y8({id:z8[z],version:J,params:{m:Q,t:G,p:Z,...W.byteLength>0?{data:W}:{}},salt:V,hash:F})}X8.hash=J8;function Q8(A,U={}){let{memoryCost:S,timeCost:V,parallelism:Y,version:P}={...EA,...U},{version:$,params:{m:z,t:J,p:Q}}=FA(A);return+$!==+P||+z!==+S||+J!==+V||+Q!==+Y}X8.needsRehash=Q8;async function W8(A,U,S={}){let{id:V,...Y}=FA(A);if(!(V in y))return!1;let{version:P=16,params:{m:$,t:z,p:J,data:Q=""},salt:G,hash:Z}=Y,{secret:W=Buffer.alloc(0)}=S;return S8(await HA({password:Buffer.from(U),salt:G,secret:W,data:Buffer.from(Q,"base64"),hashLength:Z.byteLength,m:+$,t:+z,p:+J,version:+P,type:y[V]}),Z)}X8.verify=W8});class q extends Error{constructor(A){super(A);Object.setPrototypeOf(this,new.target.prototype),this.name=new.target.name,this.stack=void 0}}class K extends q{}class E extends q{}class d extends q{}class c extends q{}class w extends q{}class M extends q{}class h extends q{}class O extends q{}class X{static byId=new Map;static register(A){if(this.byId.has(A.id))throw new c(`Version ${A.id} already registered`);this.byId.set(A.id,A)}static get(A){let U=this.byId.get(A);if(!U)throw new c(`Unknown version: ${A}`);return U}static get current(){return this.get(0)}}class i{p;key;constructor(A){this.p=A}setKey(A){this.key=A}async encryptChunk(A){let U=this.p.getRandomValues(new Uint8Array(12)),S=new Uint8Array(await this.p.subtle.encrypt({name:"AES-GCM",iv:U},this.key,A)),V=new Uint8Array(U.length+S.length);return V.set(U),V.set(S,U.length),V}async decryptChunk(A){let U=A.slice(0,12),S=A.slice(12),V=await this.p.subtle.decrypt({name:"AES-GCM",iv:U},this.key,S);try{let Y=await this.p.subtle.decrypt({name:"AES-GCM",iv:U},this.key,S);return new Uint8Array(Y)}catch{throw new O("Decryption failed: wrong passphrase or corrupted ciphertext")}}}import*as n from"argon2-browser";async function yA(A,U,S,V){if(V==="node"){let Y=await Promise.resolve().then(() => nA(RA(),1)),P=typeof A==="string"?Buffer.from(A,"utf8"):Buffer.from(A),$=Buffer.from(U),z=await Y.hash(P,{salt:$,timeCost:S.time,memoryCost:S.mem,parallelism:S.parallelism,hashLength:32,raw:!0,type:Y.argon2id});return{hash:new Uint8Array(z)}}if(V==="browser"){if(!("loadArgon2WasmBinary"in globalThis))globalThis.loadArgon2WasmBinary=()=>{let Y=new URL("argon2.wasm",import.meta.url).href;return fetch(Y).then((P)=>{if(!P.ok)throw new Error("Failed to load argon2.wasm");return P.arrayBuffer()}).then((P)=>new Uint8Array(P))};return n.hash({pass:A,salt:U,time:S.time,mem:S.mem,parallelism:S.parallelism,hashLen:32,type:n.ArgonType.Argon2id}).then((Y)=>{if(!Y||!Y.hash)throw new Error("Failed to produce key derivation");return{hash:Y.hash}}).catch((Y)=>{let P=Y instanceof Error?Y.message:typeof Y==="string"?Y:"Unknown error";throw new M(`argon2-browser failure: ${P}`)})}throw new Error(`Unsupported environment: ${V}`)}class SA{presets;name="argon2id";constructor(A){this.presets=A}async derive(A,U,S,V){let{hash:Y}=await yA(A,U,this.presets[S],V.isNode?"node":"browser");return V.subtle.importKey("raw",Y,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}}var kA={low:{time:5,mem:65536,parallelism:1},middle:{time:20,mem:65536,parallelism:1},high:{time:40,mem:65536,parallelism:1}},I8={id:0,cipher:i,kdf:new SA(kA),saltLengths:{low:12,high:16},difficulties:kA,defaultChunkSize:524288};X.register(I8);var u=1;function jA(){return typeof process!=="undefined"&&typeof process.versions==="object"&&!0}function k(...A){let U=A.reduce((Y,P)=>Y+P.byteLength,0),S=new Uint8Array(U),V=0;for(let Y of A)S.set(Y,V),V+=Y.byteLength;return S}function j(...A){try{let U=k(...A);if(jA())return Buffer.from(U).toString("base64");let S="";for(let V=0;V<U.length;V++)S+=String.fromCharCode(U[V]);return btoa(S)}catch(U){throw new d("Base64 Enconding Error")}}function VA(A){try{if(!/^[A-Za-z0-9+/]+={0,2}$/.test(A)||A.length%4!==0)throw new Error("invalid base64");if(jA())return new Uint8Array(Buffer.from(A,"base64"));let U=atob(A),S=new Uint8Array(U.length);for(let V=0;V<U.length;V++)S[V]=U.charCodeAt(V);return S}catch(U){throw new E("Base64 Decoding Error")}}function l(A,U,S,V){let Y={low:0,middle:1,high:2}[U]??0,P=A<<5|(S==="high"?1:0)<<2|Y;return k(new Uint8Array([u,P]),V)}function D(A){if(A[0]!==u)throw new K("Invalid input format. The input is unknown.");try{let U=A[1],S=U>>5,V=U>>2&1?"high":"low",Y=U&3,P=["low","middle","high"][Y],$=X.get(S).saltLengths[V],z=A.slice(2,2+$);return{version:S,difficulty:P,saltStrength:V,salt:z,headerLen:2+$}}catch(U){throw new w(U instanceof Error?U.message:String(U))}}class v{engine;chunkSize;buffer=new Uint8Array(0);constructor(A,U=524288){this.engine=A;this.chunkSize=U}toTransformStream(){return new TransformStream({transform:async(A,U)=>{await this.transform(await this.asUint8Array(A),U)},flush:async(A)=>this.flush(A)})}async transform(A,U){let S=new Uint8Array(this.buffer.length+A.length);S.set(this.buffer),S.set(A,this.buffer.length);let V=0;while(S.length-V>=this.chunkSize){let Y=S.slice(V,V+this.chunkSize);V+=this.chunkSize;let P=await this.engine.encryptChunk(Y),$=new Uint8Array(4);new DataView($.buffer).setUint32(0,P.length,!1);let z=new Uint8Array(4+P.length);z.set($),z.set(P,$.length),U.enqueue(z)}this.buffer=S.slice(V)}async flush(A){if(!this.buffer.length)return;let U=await this.engine.encryptChunk(this.buffer),S=new Uint8Array(4);new DataView(S.buffer).setUint32(0,U.length,!1);let V=new Uint8Array(4+U.length);V.set(S),V.set(U,4),A.enqueue(V),this.buffer=new Uint8Array(0)}async asUint8Array(A){if(A instanceof Uint8Array)return A;if(A instanceof ArrayBuffer)return new Uint8Array(A);return new Uint8Array(await A.arrayBuffer())}}class B{engine;chunkSize;buffer=new Uint8Array(0);constructor(A,U=524288){this.engine=A;this.chunkSize=U}toTransformStream(){return new TransformStream({transform:async(A,U)=>{await this.transform(await this.asUint8Array(A),U)},flush:async(A)=>this.flush(A)})}async transform(A,U){let S=new Uint8Array(this.buffer.length+A.length);S.set(this.buffer),S.set(A,this.buffer.length);let V=0;while(!0){if(S.length-V<4)break;let Y=new DataView(S.buffer,S.byteOffset+V,4).getUint32(0,!1);if(S.length-V-4<Y)break;V+=4;let P=S.slice(V,V+Y);V+=Y;try{let $=await this.engine.decryptChunk(P);U.enqueue($)}catch($){throw $ instanceof O?$:new O("Decryption failed: Wrong passphrase or corrupted ciphertext")}}this.buffer=S.slice(V)}async flush(A){await this.transform(new Uint8Array(0),A),this.buffer=new Uint8Array(0)}async asUint8Array(A){if(A instanceof Uint8Array)return A;if(A instanceof ArrayBuffer)return new Uint8Array(A);return new Uint8Array(await A.arrayBuffer())}}class C{engine;chunkSize;constructor(A,U=524288){this.engine=A;this.chunkSize=U}encryptionStream(){let A=new v(this.engine,this.chunkSize).toTransformStream();return{writable:A.writable,readable:A.readable}}decryptionStream(A){let U=A,S=new TransformStream({transform(Y,P){if(U===0){P.enqueue(Y);return}if(Y.byteLength<=U){U-=Y.byteLength;return}P.enqueue(Y.slice(U)),U=0}}),V=new B(this.engine,this.chunkSize).toTransformStream();return{writable:S.writable,readable:S.readable.pipeThrough(V)}}async collect(A,U,S=null){let V=A.pipeThrough(U).getReader(),Y=[];if(S?.length)Y.push(S);while(!0){let{value:J,done:Q}=await V.read();if(Q)break;Y.push(J)}let P=Y.reduce((J,Q)=>J+Q.byteLength,0),$=new Uint8Array(P),z=0;for(let J of Y)$.set(J,z),z+=J.byteLength;return $}}function vA(A=0,U=console.info){return{level:A,log(S,V){if(S<=A)U(`${S}| ${V}`)}}}var mA=new Map;class N{static getEngine(A,U){let S=mA.get(U);if(S)return S;let V=X.get(U),Y=new V.cipher(A),P=V.kdf,$=V.defaultChunkSize;return S={desc:V,cipher:Y,kdf:P,chunkSize:$,provider:A},mA.set(U,S),S}static async deriveKey(A,U,S,V){try{let Y=await A.kdf.derive(U,S,V,A.provider);A.cipher.key=Y}catch(Y){let P=Y instanceof Error?Y.message:String(Y);throw new M(P)}}}class L{provider;v;cipher;kdf;chunkSize;stream;difficulty;saltStrength;engines=new Map;log;constructor(A,U={}){this.provider=A;this.v=X.get(U.version??X.current.id),this.cipher=new this.v.cipher(A),this.kdf=this.v.kdf,this.chunkSize=U.chunkSize??this.v.defaultChunkSize,this.stream=new C(this.cipher,this.chunkSize),this.difficulty=U.difficulty??"middle",this.saltStrength=U.saltStrength??"high",this.log=vA(U.verbose??0,U.logger)}static async isEncrypted(A){try{return await L.peekHeader(A),!0}catch{return!1}}static async headerDecode(A){let U=await L.peekHeader(A),S=D(U);return{version:S.version,difficulty:S.difficulty,salt:j(S.salt),saltLength:S.salt.byteLength}}setDifficulty(A){this.difficulty=A}getDifficulty(){return this.difficulty}setVersion(A){this.v=X.get(A),this.cipher=new this.v.cipher(this.provider),this.kdf=this.v.kdf,this.stream=new C(this.cipher,this.chunkSize)}getVersion(){return this.v.id}setSaltDifficulty(A){this.saltStrength=A}getSaltDifficulty(){return this.saltStrength}setChunkSize(A){this.chunkSize=A,this.stream=new C(this.cipher,this.chunkSize)}getChunkSize(){return this.chunkSize}setVerbose(A){this.log.level=A}getVerbose(){return this.log.level}async encryptText(A,U){try{this.log.log(1,"Start text encryption"),this.log.log(2,"Deriving key for text encryption");let S=this.genSalt();await this.deriveKey(U,S),this.log.log(3,`Salt generated: ${j(S)}, KDF difficulty: ${this.difficulty}`),this.log.log(2,"Encrypting text data");let V=await this.cipher.encryptChunk(typeof A==="string"?new TextEncoder().encode(A):A);this.log.log(3,"Encoding header");let Y=l(this.v.id,this.difficulty,this.saltStrength,S);this.log.log(3,"Encoding text");let P=j(Y,V);return this.log.log(1,"Decryption finished"),P}catch(S){throw new h(S instanceof Error?S.message:String(S))}}async decryptText(A,U){try{this.log.log(1,"Start text decryption"),this.log.log(3,"Start text decoding");let S=VA(A);this.log.log(3,"Start header decoding"),await L.peekHeader(A);let V=D(S);this.log.log(3,"Trying to get engine");let Y=N.getEngine(this.provider,V.version);this.log.log(2,"Deriving key via engine for text decryption"),this.log.log(3,`Salt use: ${j(V.salt)}, KDF difficulty: ${V.difficulty}`),await N.deriveKey(Y,U,V.salt,V.difficulty),this.log.log(2,"Decrypting text data");let P=await Y.cipher.decryptChunk(S.slice(V.headerLen));this.log.log(3,"Decoding text");let $=new TextDecoder().decode(P);return this.log.log(1,"Decryption finished"),$}catch(S){if(S instanceof O||S instanceof K||S instanceof w||S instanceof E||S instanceof M)throw S;throw new O("Decryption failed: wrong passphrase or corrupted ciphertext")}}async encryptFile(A,U){try{this.log.log(2,"Deriving key for file encryption");let S=this.genSalt();await this.deriveKey(U,S);let V=l(this.v.id,this.difficulty,this.saltStrength,S),Y=await this.stream.collect(A.stream(),new v(this.cipher,this.chunkSize).toTransformStream(),V);return new Blob([Y],{type:"application/octet-stream"})}catch(S){throw new h(S instanceof Error?S.message:String(S))}}async decryptFile(A,U){try{let S=await L.peekHeader(A),V=D(S),Y=N.getEngine(this.provider,V.version);await N.deriveKey(Y,U,V.salt,V.difficulty),this.log.log(2,"Decrypting file data");let $=await new C(Y.cipher,Y.chunkSize).collect(A.slice(V.headerLen).stream(),new B(Y.cipher,Y.chunkSize).toTransformStream());return new Blob([$],{type:"application/octet-stream"})}catch(S){if(S instanceof O)throw S;throw new O(S instanceof Error?S.message:String(S))}}async createEncryptionStream(A){this.log.log(2,"Deriving key for stream encryption");let U=this.genSalt();await this.deriveKey(A,U);let S=l(this.v.id,this.difficulty,this.saltStrength,U),V=this.stream.encryptionStream();return{header:S,writable:V.writable,readable:V.readable}}async createDecryptionStream(A){let U=this,S=new Uint8Array(0),V=null;async function Y(P,$){let z=P.getReader();while(!0){let{value:J,done:Q}=await z.read();if(Q)break;$.enqueue(J)}}return new TransformStream({async transform(P,$){if(!V){if(S=k(S,P),S.length<2)return;let J=S.slice(0,30),{salt:Q,difficulty:G}=D(J),Z=S[1]>>5,W=S[1]>>2&1?"high":"low",H=2+X.get(Z).saltLengths[W];if(S.length<H)return;let o=N.getEngine(U.provider,Z);await N.deriveKey(o,A,Q,G),V=new B(o.cipher,o.chunkSize).toTransformStream(),Y(V.readable,$);let YA=S.slice(H);if(YA.length){let PA=V.writable.getWriter();await PA.write(YA),PA.releaseLock()}return}let z=V.writable.getWriter();await z.write(P),z.releaseLock()},async flush(){if(V){let P=V.writable.getWriter();await P.close(),P.releaseLock()}}})}async deriveKey(A,U,S=this.difficulty){let V=performance.now();try{let Y=await this.kdf.derive(A,U,S,this.provider);this.cipher.key=Y,this.log.log(3,`Key derivation completed in ${(performance.now()-V).toFixed(1)} ms`)}catch(Y){throw new M(Y instanceof Error?Y.message:String(Y))}}genSalt(){let A=this.v.saltLengths[this.saltStrength];return this.provider.getRandomValues(new Uint8Array(A))}static async peekHeader(A){if(typeof A==="string")A=VA(A);if(A instanceof Uint8Array){if(A.length<2)throw new K("Input too short");let{headerLen:U}=D(A.length>=16?A:Uint8Array.from(A));if(A.length<U)throw new K("Incomplete header");return A.slice(0,U)}if(A instanceof Blob){let U=new Uint8Array(await A.slice(0,2).arrayBuffer());if(U[0]!==1)throw new K("Invalid input format. The input is unknown.");let S=U[1],V=S>>5,Y=S>>2&1?"high":"low",P=X.get(V).saltLengths[Y],$=new Uint8Array(await A.slice(0,2+P).arrayBuffer());return D($),$}throw new w("Unsupported input type")}}import{webcrypto as K8,randomFillSync as M8}from"node:crypto";var cA={subtle:K8.subtle,getRandomValues(A){return M8(A),A},isNode:!0};function LU(A){return new L(cA,A)}export{LU as createCryptit};

//# debugId=5A1099B5CC32629F64756E2164756E21
