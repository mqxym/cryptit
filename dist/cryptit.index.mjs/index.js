import{createRequire as sU}from"node:module";var hU=Object.create;var{getPrototypeOf:uU,defineProperty:a0,getOwnPropertyNames:xU}=Object;var pU=Object.prototype.hasOwnProperty;var iU=(U,$,V)=>{V=U!=null?hU(uU(U)):{};let Y=$||!U||!U.__esModule?a0(V,"default",{value:U,enumerable:!0}):V;for(let z of xU(U))if(!pU.call(Y,z))a0(Y,z,{get:()=>U[z],enumerable:!0});return Y};var K0=(U,$)=>()=>($||U(($={exports:{}}).exports,$),$.exports);var h=sU(import.meta.url);var HU=K0((XV,MU)=>{var R0=/^[a-z0-9-]{1,32}$/,B0=/^[a-z0-9-]{1,32}$/,E0=/^[a-zA-Z0-9/+.-]+$/,SU=/^([a-zA-Z0-9/+.-]+|)$/,q$=/^((-)?[1-9]\d*|0)$/,n0=/^v=(\d+)$/;function P$(U){return P0(U).map(($)=>[$,U[$]].join("=")).join(",")}function S$(U){let $={};return U.split(",").forEach((V)=>{let Y=V.split("=");if(Y.length<2)throw new TypeError("params must be in the format name=value");$[Y.shift()]=Y.join("=")}),$}function P0(U){return Object.keys(U)}function IU(U){if(typeof Object.values==="function")return Object.values(U);return P0(U).map(($)=>U[$])}function I$(U){let $=[""];if(typeof U!=="object"||U===null)throw new TypeError("opts must be an object");if(typeof U.id!=="string")throw new TypeError("id must be a string");if(!R0.test(U.id))throw new TypeError(`id must satisfy ${R0}`);if($.push(U.id),typeof U.version!=="undefined"){if(typeof U.version!=="number"||U.version<0||!Number.isInteger(U.version))throw new TypeError("version must be a positive integer number");$.push(`v=${U.version}`)}if(typeof U.params!=="undefined"){if(typeof U.params!=="object"||U.params===null)throw new TypeError("params must be an object");let Y=P0(U.params);if(!Y.every((J)=>B0.test(J)))throw new TypeError(`params names must satisfy ${B0}`);Y.forEach((J)=>{if(typeof U.params[J]==="number")U.params[J]=U.params[J].toString();else if(Buffer.isBuffer(U.params[J]))U.params[J]=U.params[J].toString("base64").split("=")[0]});let z=IU(U.params);if(!z.every((J)=>typeof J==="string"))throw new TypeError("params values must be strings");if(!z.every((J)=>E0.test(J)))throw new TypeError(`params values must satisfy ${E0}`);let Q=P$(U.params);$.push(Q)}if(typeof U.salt!=="undefined"){if(!Buffer.isBuffer(U.salt))throw new TypeError("salt must be a Buffer");if($.push(U.salt.toString("base64").split("=")[0]),typeof U.hash!=="undefined"){if(!Buffer.isBuffer(U.hash))throw new TypeError("hash must be a Buffer");$.push(U.hash.toString("base64").split("=")[0])}}return $.join("$")}function M$(U){if(typeof U!=="string"||U==="")throw new TypeError("pchstr must be a non-empty string");if(U[0]!=="$")throw new TypeError("pchstr must contain a $ as first char");let $=U.split("$");$.shift();let V=5;if(!n0.test($[1]))V--;if($.length>V)throw new TypeError(`pchstr contains too many fileds: ${$.length}/${V}`);let Y=$.shift();if(!R0.test(Y))throw new TypeError(`id must satisfy ${R0}`);let z;if(n0.test($[0]))z=parseInt($.shift().match(n0)[1],10);let Q,J;if(SU.test($[$.length-1]))if($.length>1&&SU.test($[$.length-2]))Q=Buffer.from($.pop(),"base64"),J=Buffer.from($.pop(),"base64");else J=Buffer.from($.pop(),"base64");let G;if($.length>0){let Z=$.pop();if(G=S$(Z),!P0(G).every((I)=>B0.test(I)))throw new TypeError(`params names must satisfy ${B0}`);if(!IU(G).every((I)=>E0.test(I)))throw new TypeError(`params values must satisfy ${E0}`);P0(G).forEach((I)=>{G[I]=q$.test(G[I])?parseInt(G[I],10):G[I]})}if($.length>0)throw new TypeError(`pchstr contains unrecognized fileds: ${$}`);let W={id:Y};if(z)W.version=z;if(G)W.params=G;if(J)W.salt=J;if(Q)W.hash=Q;return W}MU.exports={serialize:I$,deserialize:M$}});var vU=K0((qV,_U)=>{var OU=h("fs"),o=h("path"),FU=h("os"),DU=typeof __webpack_require__==="function"?__non_webpack_require__:h,H$=process.config&&process.config.variables||{},K$=!!process.env.PREBUILDS_ONLY,KU=process.versions.modules,h0=O$()?"electron":A$()?"node-webkit":"node",u0=process.env.npm_config_arch||FU.arch(),x0=process.env.npm_config_platform||FU.platform(),TU=process.env.LIBC||(F$(x0)?"musl":"glibc"),p0=process.env.ARM_VERSION||(u0==="arm64"?"8":H$.arm_version)||"",wU=(process.versions.uv||"").split(".")[0];_U.exports=u;function u(U){return DU(u.resolve(U))}u.resolve=u.path=function(U){U=o.resolve(U||".");try{var $=DU(o.join(U,"package.json")).name.toUpperCase().replace(/-/g,"_");if(process.env[$+"_PREBUILD"])U=process.env[$+"_PREBUILD"]}catch(W){}if(!K$){var V=NU(o.join(U,"build/Release"),AU);if(V)return V;var Y=NU(o.join(U,"build/Debug"),AU);if(Y)return Y}var z=G(U);if(z)return z;var Q=G(o.dirname(process.execPath));if(Q)return Q;var J=["platform="+x0,"arch="+u0,"runtime="+h0,"abi="+KU,"uv="+wU,p0?"armv="+p0:"","libc="+TU,"node="+process.versions.node,process.versions.electron?"electron="+process.versions.electron:"",typeof __webpack_require__==="function"?"webpack=true":""].filter(Boolean).join(" ");throw new Error("No native build was found for "+J+`
    loaded from: `+U+`
`);function G(W){var Z=i0(o.join(W,"prebuilds")).map(RU),q=Z.filter(BU(x0,u0)).sort(EU)[0];if(!q)return;var P=o.join(W,"prebuilds",q.name),I=i0(P).map(CU),K=I.filter(LU(h0,KU)),M=K.sort(jU(h0))[0];if(M)return o.join(P,M.file)}};function i0(U){try{return OU.readdirSync(U)}catch($){return[]}}function NU(U,$){var V=i0(U).filter($);return V[0]&&o.join(U,V[0])}function AU(U){return/\.node$/.test(U)}function RU(U){var $=U.split("-");if($.length!==2)return;var V=$[0],Y=$[1].split("+");if(!V)return;if(!Y.length)return;if(!Y.every(Boolean))return;return{name:U,platform:V,architectures:Y}}function BU(U,$){return function(V){if(V==null)return!1;if(V.platform!==U)return!1;return V.architectures.includes($)}}function EU(U,$){return U.architectures.length-$.architectures.length}function CU(U){var $=U.split("."),V=$.pop(),Y={file:U,specificity:0};if(V!=="node")return;for(var z=0;z<$.length;z++){var Q=$[z];if(Q==="node"||Q==="electron"||Q==="node-webkit")Y.runtime=Q;else if(Q==="napi")Y.napi=!0;else if(Q.slice(0,3)==="abi")Y.abi=Q.slice(3);else if(Q.slice(0,2)==="uv")Y.uv=Q.slice(2);else if(Q.slice(0,4)==="armv")Y.armv=Q.slice(4);else if(Q==="glibc"||Q==="musl")Y.libc=Q;else continue;Y.specificity++}return Y}function LU(U,$){return function(V){if(V==null)return!1;if(V.runtime&&V.runtime!==U&&!N$(V))return!1;if(V.abi&&V.abi!==$&&!V.napi)return!1;if(V.uv&&V.uv!==wU)return!1;if(V.armv&&V.armv!==p0)return!1;if(V.libc&&V.libc!==TU)return!1;return!0}}function N$(U){return U.runtime==="node"&&U.napi}function jU(U){return function($,V){if($.runtime!==V.runtime)return $.runtime===U?-1:1;else if($.abi!==V.abi)return $.abi?-1:1;else if($.specificity!==V.specificity)return $.specificity>V.specificity?-1:1;else return 0}}function A$(){return!!(process.versions&&process.versions.nw)}function O$(){if(process.versions&&process.versions.electron)return!0;if(process.env.ELECTRON_RUN_AS_NODE)return!0;return typeof window!=="undefined"&&window.process&&window.process.type==="renderer"}function F$(U){return U==="linux"&&OU.existsSync("/etc/alpine-release")}u.parseTags=CU;u.matchTags=LU;u.compareTags=jU;u.parseTuple=RU;u.matchTuple=BU;u.compareTuples=EU});var mU=K0((SV,o0)=>{var s0=typeof __webpack_require__==="function"?__non_webpack_require__:h;if(typeof s0.addon==="function")o0.exports=s0.addon.bind(s0);else o0.exports=vU()});var bU=K0((v$,U0)=>{var __dirname="/Users/maxim/Projects/Private/Sites/cryptit/node_modules/argon2",MV=h("node:assert"),{randomBytes:D$,timingSafeEqual:T$}=h("node:crypto"),{promisify:w$}=h("node:util"),{deserialize:kU,serialize:R$}=HU(),B$=mU(),{hash:fU}=B$(__dirname),E$=w$(D$);v$.argon2d=0;v$.argon2i=1;v$.argon2id=2;var S0=Object.freeze({argon2d:0,argon2i:1,argon2id:2}),C$=Object.freeze({[S0.argon2d]:"argon2d",[S0.argon2i]:"argon2i",[S0.argon2id]:"argon2id"}),yU={hashLength:32,timeCost:3,memoryCost:65536,parallelism:4,type:2,version:19};async function L$(U,$){let{raw:V,salt:Y,...z}={...yU,...$};if(z.hashLength>4294967295)throw new RangeError("Hash length is too large");if(z.memoryCost>4294967295)throw new RangeError("Memory cost is too large");if(z.timeCost>4294967295)throw new RangeError("Time cost is too large");if(z.parallelism>16777215)throw new RangeError("Parallelism is too large");Y=Y??await E$(16);let{hashLength:Q,secret:J=Buffer.alloc(0),type:G,version:W,memoryCost:Z,timeCost:q,parallelism:P,associatedData:I=Buffer.alloc(0)}=z,K=await fU({password:Buffer.from(U),salt:Y,secret:J,data:I,hashLength:Q,m:Z,t:q,p:P,version:W,type:G});if(V)return K;return R$({id:C$[G],version:W,params:{m:Z,t:q,p:P,...I.byteLength>0?{data:I}:{}},salt:Y,hash:K})}v$.hash=L$;function j$(U,$={}){let{memoryCost:V,timeCost:Y,parallelism:z,version:Q}={...yU,...$},{version:J,params:{m:G,t:W,p:Z}}=kU(U);return+J!==+Q||+G!==+V||+W!==+Y||+Z!==+z}v$.needsRehash=j$;async function _$(U,$,V={}){let{id:Y,...z}=kU(U);if(!(Y in S0))return!1;let{version:Q=16,params:{m:J,t:G,p:W,data:Z=""},salt:q,hash:P}=z,{secret:I=Buffer.alloc(0)}=V;return T$(await fU({password:Buffer.from($),salt:q,secret:I,data:Buffer.from(Z,"base64"),hashLength:P.byteLength,m:+J,t:+G,p:+W,version:+Q,type:S0[Y]}),P)}v$.verify=_$});class p extends Error{constructor(U){super(U);Object.setPrototypeOf(this,new.target.prototype),this.name=new.target.name,this.stack=void 0}}class a extends p{}class q0 extends p{}class m0 extends p{}class N0 extends p{}class W0 extends p{}class e extends p{}class A0 extends p{}class n extends p{}class d{static byId=new Map;static register(U){if(this.byId.has(U.id))throw new N0(`Version ${U.id} already registered`);this.byId.set(U.id,U)}static get(U){let $=this.byId.get(U);if(!$)throw new N0(`Unknown version: ${U}`);return $}static get current(){return this.get(0)}}class k0{p;key;constructor(U){this.p=U}setKey(U){this.key=U}async encryptChunk(U){let $=this.p.getRandomValues(new Uint8Array(12)),V=new Uint8Array(await this.p.subtle.encrypt({name:"AES-GCM",iv:$},this.key,U)),Y=new Uint8Array($.length+V.length);return Y.set($),Y.set(V,$.length),Y}async decryptChunk(U){let $=U.slice(0,12),V=U.slice(12),Y=await this.p.subtle.decrypt({name:"AES-GCM",iv:$},this.key,V);try{let z=await this.p.subtle.decrypt({name:"AES-GCM",iv:$},this.key,V);return new Uint8Array(z)}catch{throw new n("Decryption failed: wrong passphrase or corrupted ciphertext")}}}/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function t0(U){return U instanceof Uint8Array||ArrayBuffer.isView(U)&&U.constructor.name==="Uint8Array"}function O0(U){if(typeof U!=="boolean")throw new Error(`boolean expected, not ${U}`)}function F0(U){if(!Number.isSafeInteger(U)||U<0)throw new Error("positive integer expected, got "+U)}function l(U,...$){if(!t0(U))throw new Error("Uint8Array expected");if($.length>0&&!$.includes(U.length))throw new Error("Uint8Array expected of length "+$+", got length="+U.length)}function f0(U,$=!0){if(U.destroyed)throw new Error("Hash instance has been destroyed");if($&&U.finished)throw new Error("Hash#digest() has already been called")}function UU(U,$){l(U);let V=$.outputLen;if(U.length<V)throw new Error("digestInto() expects output buffer of length at least "+V)}function i(U){return new Uint32Array(U.buffer,U.byteOffset,Math.floor(U.byteLength/4))}function s(...U){for(let $=0;$<U.length;$++)U[$].fill(0)}function oU(U){return new DataView(U.buffer,U.byteOffset,U.byteLength)}var rU=(()=>new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68)();function aU(U){if(typeof U!=="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(U))}function D0(U){if(typeof U==="string")U=aU(U);else if(t0(U))U=T0(U);else throw new Error("Uint8Array expected, got "+typeof U);return U}function $U(U,$){if($==null||typeof $!=="object")throw new Error("options must be defined");return Object.assign(U,$)}function VU(U,$){if(U.length!==$.length)return!1;let V=0;for(let Y=0;Y<U.length;Y++)V|=U[Y]^$[Y];return V===0}var y0=(U,$)=>{function V(Y,...z){if(l(Y),!rU)throw new Error("Non little-endian hardware is not yet supported");if(U.nonceLength!==void 0){let q=z[0];if(!q)throw new Error("nonce / iv required");if(U.varSizeNonce)l(q);else l(q,U.nonceLength)}let Q=U.tagLength;if(Q&&z[1]!==void 0)l(z[1]);let J=$(Y,...z),G=(q,P)=>{if(P!==void 0){if(q!==2)throw new Error("cipher output not supported");l(P)}},W=!1;return{encrypt(q,P){if(W)throw new Error("cannot encrypt() twice with same key + nonce");return W=!0,l(q),G(J.encrypt.length,P),J.encrypt(q,P)},decrypt(q,P){if(l(q),Q&&q.length<Q)throw new Error("invalid ciphertext length: smaller than tagLength="+Q);return G(J.decrypt.length,P),J.decrypt(q,P)}}}return Object.assign(V,U),V};function b0(U,$,V=!0){if($===void 0)return new Uint8Array(U);if($.length!==U)throw new Error("invalid output length, expected "+U+", got: "+$.length);if(V&&!eU($))throw new Error("invalid output, must be aligned");return $}function e0(U,$,V,Y){if(typeof U.setBigUint64==="function")return U.setBigUint64($,V,Y);let z=BigInt(32),Q=BigInt(4294967295),J=Number(V>>z&Q),G=Number(V&Q),W=Y?4:0,Z=Y?0:4;U.setUint32($+W,J,Y),U.setUint32($+Z,G,Y)}function YU(U,$,V){O0(V);let Y=new Uint8Array(16),z=oU(Y);return e0(z,0,BigInt($),V),e0(z,8,BigInt(U),V),Y}function eU(U){return U.byteOffset%4===0}function T0(U){return Uint8Array.from(U)}var JU=(U)=>Uint8Array.from(U.split("").map(($)=>$.charCodeAt(0))),tU=JU("expand 16-byte k"),U$=JU("expand 32-byte k"),$$=i(tU),V$=i(U$);function X(U,$){return U<<$|U>>>32-$}function g0(U){return U.byteOffset%4===0}var w0=64,Y$=16,QU=4294967295,zU=new Uint32Array;function z$(U,$,V,Y,z,Q,J,G){let W=z.length,Z=new Uint8Array(w0),q=i(Z),P=g0(z)&&g0(Q),I=P?i(z):zU,K=P?i(Q):zU;for(let M=0;M<W;J++){if(U($,V,Y,q,J,G),J>=QU)throw new Error("arx: counter overflow");let H=Math.min(w0,W-M);if(P&&H===w0){let A=M/4;if(M%4!==0)throw new Error("arx: invalid block position");for(let N=0,O;N<Y$;N++)O=A+N,K[O]=I[O]^q[N];M+=w0;continue}for(let A=0,N;A<H;A++)N=M+A,Q[N]=z[N]^Z[A];M+=H}}function c0(U,$){let{allowShortKeys:V,extendNonceFn:Y,counterLength:z,counterRight:Q,rounds:J}=$U({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},$);if(typeof U!=="function")throw new Error("core must be a function");return F0(z),F0(J),O0(Q),O0(V),(G,W,Z,q,P=0)=>{l(G),l(W),l(Z);let I=Z.length;if(q===void 0)q=new Uint8Array(I);if(l(q),F0(P),P<0||P>=QU)throw new Error("arx: counter overflow");if(q.length<I)throw new Error(`arx: output (${q.length}) is shorter than data (${I})`);let K=[],M=G.length,H,A;if(M===32)K.push(H=T0(G)),A=V$;else if(M===16&&V)H=new Uint8Array(32),H.set(G),H.set(G,16),A=$$,K.push(H);else throw new Error(`arx: invalid 32-byte key, got length=${M}`);if(!g0(W))K.push(W=T0(W));let N=i(H);if(Y){if(W.length!==24)throw new Error("arx: extended nonce must be 24 bytes");Y(A,N,i(W.subarray(0,16)),N),W=W.subarray(16)}let O=16-z;if(O!==W.length)throw new Error(`arx: nonce must be ${O} or 16 bytes`);if(O!==12){let y=new Uint8Array(12);y.set(W,Q?0:12-W.length),W=y,K.push(W)}let m=i(W);return z$(U,A,N,m,Z,q,P,J),s(...K),q}}var b=(U,$)=>U[$++]&255|(U[$++]&255)<<8;class GU{constructor(U){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,U=D0(U),l(U,32);let $=b(U,0),V=b(U,2),Y=b(U,4),z=b(U,6),Q=b(U,8),J=b(U,10),G=b(U,12),W=b(U,14);this.r[0]=$&8191,this.r[1]=($>>>13|V<<3)&8191,this.r[2]=(V>>>10|Y<<6)&7939,this.r[3]=(Y>>>7|z<<9)&8191,this.r[4]=(z>>>4|Q<<12)&255,this.r[5]=Q>>>1&8190,this.r[6]=(Q>>>14|J<<2)&8191,this.r[7]=(J>>>11|G<<5)&8065,this.r[8]=(G>>>8|W<<8)&8191,this.r[9]=W>>>5&127;for(let Z=0;Z<8;Z++)this.pad[Z]=b(U,16+2*Z)}process(U,$,V=!1){let Y=V?0:2048,{h:z,r:Q}=this,J=Q[0],G=Q[1],W=Q[2],Z=Q[3],q=Q[4],P=Q[5],I=Q[6],K=Q[7],M=Q[8],H=Q[9],A=b(U,$+0),N=b(U,$+2),O=b(U,$+4),m=b(U,$+6),y=b(U,$+8),r=b(U,$+10),g=b(U,$+12),c=b(U,$+14),F=z[0]+(A&8191),D=z[1]+((A>>>13|N<<3)&8191),T=z[2]+((N>>>10|O<<6)&8191),w=z[3]+((O>>>7|m<<9)&8191),R=z[4]+((m>>>4|y<<12)&8191),B=z[5]+(y>>>1&8191),E=z[6]+((y>>>14|r<<2)&8191),C=z[7]+((r>>>11|g<<5)&8191),L=z[8]+((g>>>8|c<<8)&8191),j=z[9]+(c>>>5|Y),S=0,v=S+F*J+D*(5*H)+T*(5*M)+w*(5*K)+R*(5*I);S=v>>>13,v&=8191,v+=B*(5*P)+E*(5*q)+C*(5*Z)+L*(5*W)+j*(5*G),S+=v>>>13,v&=8191;let k=S+F*G+D*J+T*(5*H)+w*(5*M)+R*(5*K);S=k>>>13,k&=8191,k+=B*(5*I)+E*(5*P)+C*(5*q)+L*(5*Z)+j*(5*W),S+=k>>>13,k&=8191;let f=S+F*W+D*G+T*J+w*(5*H)+R*(5*M);S=f>>>13,f&=8191,f+=B*(5*K)+E*(5*I)+C*(5*P)+L*(5*q)+j*(5*Z),S+=f>>>13,f&=8191;let _=S+F*Z+D*W+T*G+w*J+R*(5*H);S=_>>>13,_&=8191,_+=B*(5*M)+E*(5*K)+C*(5*I)+L*(5*P)+j*(5*q),S+=_>>>13,_&=8191;let x=S+F*q+D*Z+T*W+w*G+R*J;S=x>>>13,x&=8191,x+=B*(5*H)+E*(5*M)+C*(5*K)+L*(5*I)+j*(5*P),S+=x>>>13,x&=8191;let Y0=S+F*P+D*q+T*Z+w*W+R*G;S=Y0>>>13,Y0&=8191,Y0+=B*J+E*(5*H)+C*(5*M)+L*(5*K)+j*(5*I),S+=Y0>>>13,Y0&=8191;let z0=S+F*I+D*P+T*q+w*Z+R*W;S=z0>>>13,z0&=8191,z0+=B*G+E*J+C*(5*H)+L*(5*M)+j*(5*K),S+=z0>>>13,z0&=8191;let J0=S+F*K+D*I+T*P+w*q+R*Z;S=J0>>>13,J0&=8191,J0+=B*W+E*G+C*J+L*(5*H)+j*(5*M),S+=J0>>>13,J0&=8191;let Q0=S+F*M+D*K+T*I+w*P+R*q;S=Q0>>>13,Q0&=8191,Q0+=B*Z+E*W+C*G+L*J+j*(5*H),S+=Q0>>>13,Q0&=8191;let G0=S+F*H+D*M+T*K+w*I+R*P;S=G0>>>13,G0&=8191,G0+=B*q+E*Z+C*W+L*G+j*J,S+=G0>>>13,G0&=8191,S=(S<<2)+S|0,S=S+v|0,v=S&8191,S=S>>>13,k+=S,z[0]=v,z[1]=k,z[2]=f,z[3]=_,z[4]=x,z[5]=Y0,z[6]=z0,z[7]=J0,z[8]=Q0,z[9]=G0}finalize(){let{h:U,pad:$}=this,V=new Uint16Array(10),Y=U[1]>>>13;U[1]&=8191;for(let J=2;J<10;J++)U[J]+=Y,Y=U[J]>>>13,U[J]&=8191;U[0]+=Y*5,Y=U[0]>>>13,U[0]&=8191,U[1]+=Y,Y=U[1]>>>13,U[1]&=8191,U[2]+=Y,V[0]=U[0]+5,Y=V[0]>>>13,V[0]&=8191;for(let J=1;J<10;J++)V[J]=U[J]+Y,Y=V[J]>>>13,V[J]&=8191;V[9]-=8192;let z=(Y^1)-1;for(let J=0;J<10;J++)V[J]&=z;z=~z;for(let J=0;J<10;J++)U[J]=U[J]&z|V[J];U[0]=(U[0]|U[1]<<13)&65535,U[1]=(U[1]>>>3|U[2]<<10)&65535,U[2]=(U[2]>>>6|U[3]<<7)&65535,U[3]=(U[3]>>>9|U[4]<<4)&65535,U[4]=(U[4]>>>12|U[5]<<1|U[6]<<14)&65535,U[5]=(U[6]>>>2|U[7]<<11)&65535,U[6]=(U[7]>>>5|U[8]<<8)&65535,U[7]=(U[8]>>>8|U[9]<<5)&65535;let Q=U[0]+$[0];U[0]=Q&65535;for(let J=1;J<8;J++)Q=(U[J]+$[J]|0)+(Q>>>16)|0,U[J]=Q&65535;s(V)}update(U){f0(this),U=D0(U),l(U);let{buffer:$,blockLen:V}=this,Y=U.length;for(let z=0;z<Y;){let Q=Math.min(V-this.pos,Y-z);if(Q===V){for(;V<=Y-z;z+=V)this.process(U,z);continue}if($.set(U.subarray(z,z+Q),this.pos),this.pos+=Q,z+=Q,this.pos===V)this.process($,0,!1),this.pos=0}return this}destroy(){s(this.h,this.r,this.buffer,this.pad)}digestInto(U){f0(this),UU(U,this),this.finished=!0;let{buffer:$,h:V}=this,{pos:Y}=this;if(Y){$[Y++]=1;for(;Y<16;Y++)$[Y]=0;this.process($,0,!0)}this.finalize();let z=0;for(let Q=0;Q<8;Q++)U[z++]=V[Q]>>>0,U[z++]=V[Q]>>>8;return U}digest(){let{buffer:U,outputLen:$}=this;this.digestInto(U);let V=U.slice(0,$);return this.destroy(),V}}function J$(U){let $=(Y,z)=>U(z).update(D0(Y)).digest(),V=U(new Uint8Array(32));return $.outputLen=V.outputLen,$.blockLen=V.blockLen,$.create=(Y)=>U(Y),$}var WU=J$((U)=>new GU(U));function qU(U,$,V,Y,z,Q=20){let J=U[0],G=U[1],W=U[2],Z=U[3],q=$[0],P=$[1],I=$[2],K=$[3],M=$[4],H=$[5],A=$[6],N=$[7],O=z,m=V[0],y=V[1],r=V[2],g=J,c=G,F=W,D=Z,T=q,w=P,R=I,B=K,E=M,C=H,L=A,j=N,S=O,v=m,k=y,f=r;for(let x=0;x<Q;x+=2)g=g+T|0,S=X(S^g,16),E=E+S|0,T=X(T^E,12),g=g+T|0,S=X(S^g,8),E=E+S|0,T=X(T^E,7),c=c+w|0,v=X(v^c,16),C=C+v|0,w=X(w^C,12),c=c+w|0,v=X(v^c,8),C=C+v|0,w=X(w^C,7),F=F+R|0,k=X(k^F,16),L=L+k|0,R=X(R^L,12),F=F+R|0,k=X(k^F,8),L=L+k|0,R=X(R^L,7),D=D+B|0,f=X(f^D,16),j=j+f|0,B=X(B^j,12),D=D+B|0,f=X(f^D,8),j=j+f|0,B=X(B^j,7),g=g+w|0,f=X(f^g,16),L=L+f|0,w=X(w^L,12),g=g+w|0,f=X(f^g,8),L=L+f|0,w=X(w^L,7),c=c+R|0,S=X(S^c,16),j=j+S|0,R=X(R^j,12),c=c+R|0,S=X(S^c,8),j=j+S|0,R=X(R^j,7),F=F+B|0,v=X(v^F,16),E=E+v|0,B=X(B^E,12),F=F+B|0,v=X(v^F,8),E=E+v|0,B=X(B^E,7),D=D+T|0,k=X(k^D,16),C=C+k|0,T=X(T^C,12),D=D+T|0,k=X(k^D,8),C=C+k|0,T=X(T^C,7);let _=0;Y[_++]=J+g|0,Y[_++]=G+c|0,Y[_++]=W+F|0,Y[_++]=Z+D|0,Y[_++]=q+T|0,Y[_++]=P+w|0,Y[_++]=I+R|0,Y[_++]=K+B|0,Y[_++]=M+E|0,Y[_++]=H+C|0,Y[_++]=A+L|0,Y[_++]=N+j|0,Y[_++]=O+S|0,Y[_++]=m+v|0,Y[_++]=y+k|0,Y[_++]=r+f|0}function Q$(U,$,V,Y){let z=U[0],Q=U[1],J=U[2],G=U[3],W=$[0],Z=$[1],q=$[2],P=$[3],I=$[4],K=$[5],M=$[6],H=$[7],A=V[0],N=V[1],O=V[2],m=V[3];for(let r=0;r<20;r+=2)z=z+W|0,A=X(A^z,16),I=I+A|0,W=X(W^I,12),z=z+W|0,A=X(A^z,8),I=I+A|0,W=X(W^I,7),Q=Q+Z|0,N=X(N^Q,16),K=K+N|0,Z=X(Z^K,12),Q=Q+Z|0,N=X(N^Q,8),K=K+N|0,Z=X(Z^K,7),J=J+q|0,O=X(O^J,16),M=M+O|0,q=X(q^M,12),J=J+q|0,O=X(O^J,8),M=M+O|0,q=X(q^M,7),G=G+P|0,m=X(m^G,16),H=H+m|0,P=X(P^H,12),G=G+P|0,m=X(m^G,8),H=H+m|0,P=X(P^H,7),z=z+Z|0,m=X(m^z,16),M=M+m|0,Z=X(Z^M,12),z=z+Z|0,m=X(m^z,8),M=M+m|0,Z=X(Z^M,7),Q=Q+q|0,A=X(A^Q,16),H=H+A|0,q=X(q^H,12),Q=Q+q|0,A=X(A^Q,8),H=H+A|0,q=X(q^H,7),J=J+P|0,N=X(N^J,16),I=I+N|0,P=X(P^I,12),J=J+P|0,N=X(N^J,8),I=I+N|0,P=X(P^I,7),G=G+W|0,O=X(O^G,16),K=K+O|0,W=X(W^K,12),G=G+W|0,O=X(O^G,8),K=K+O|0,W=X(W^K,7);let y=0;Y[y++]=z,Y[y++]=Q,Y[y++]=J,Y[y++]=G,Y[y++]=A,Y[y++]=N,Y[y++]=O,Y[y++]=m}var G$=c0(qU,{counterRight:!1,counterLength:4,allowShortKeys:!1}),W$=c0(qU,{counterRight:!1,counterLength:8,extendNonceFn:Q$,allowShortKeys:!1});var Z$=new Uint8Array(16),ZU=(U,$)=>{U.update($);let V=$.length%16;if(V)U.update(Z$.subarray(V))},X$=new Uint8Array(32);function XU(U,$,V,Y,z){let Q=U($,V,X$),J=WU.create(Q);if(z)ZU(J,z);ZU(J,Y);let G=YU(Y.length,z?z.length:0,!0);J.update(G);let W=J.digest();return s(Q,G),W}var PU=(U)=>($,V,Y)=>{return{encrypt(Q,J){let G=Q.length;J=b0(G+16,J,!1),J.set(Q);let W=J.subarray(0,-16);U($,V,W,W,1);let Z=XU(U,$,V,W,Y);return J.set(Z,G),s(Z),J},decrypt(Q,J){J=b0(Q.length-16,J,!1);let G=Q.subarray(0,-16),W=Q.subarray(-16),Z=XU(U,$,V,G,Y);if(!VU(W,Z))throw new Error("invalid tag");return J.set(Q.subarray(0,-16)),U($,V,J,J,1),s(Z),J}}},JV=y0({blockSize:64,nonceLength:12,tagLength:16},PU(G$)),l0=y0({blockSize:64,nonceLength:24,tagLength:16},PU(W$));class d0{p;key;constructor(U){this.p=U}async setKey(U){this.key=new Uint8Array(await this.p.subtle.exportKey("raw",U))}async encryptChunk(U){let $=this.p.getRandomValues(new Uint8Array(24)),Y=l0(this.key,$).encrypt(U),z=new Uint8Array($.length+Y.length);return z.set($,0),z.set(Y,$.length),z}async decryptChunk(U){let $=U.slice(0,24),V=U.slice(24),Y=l0(this.key,$);try{return Y.decrypt(V)}catch{throw new n("Decryption failed: wrong passphrase or corrupted ciphertext")}}}import*as C0 from"argon2-browser";async function gU(U,$,V,Y){if(Y==="node"){let z=await Promise.resolve().then(() => iU(bU(),1)),Q=typeof U==="string"?Buffer.from(U,"utf8"):Buffer.from(U),J=Buffer.from($),G=await z.hash(Q,{salt:J,timeCost:V.time,memoryCost:V.mem,parallelism:V.parallelism,hashLength:32,raw:!0,type:z.argon2id});return{hash:new Uint8Array(G)}}if(Y==="browser"){if(!("loadArgon2WasmBinary"in globalThis))globalThis.loadArgon2WasmBinary=()=>{let z=new URL("argon2.wasm",import.meta.url).href;return fetch(z).then((Q)=>{if(!Q.ok)throw new Error("Failed to load argon2.wasm");return Q.arrayBuffer()}).then((Q)=>new Uint8Array(Q))};return C0.hash({pass:U,salt:$,time:V.time,mem:V.mem,parallelism:V.parallelism,hashLen:32,type:C0.ArgonType.Argon2id}).then((z)=>{if(!z||!z.hash)throw new Error("Failed to produce key derivation");return{hash:z.hash}}).catch((z)=>{let Q=z instanceof Error?z.message:typeof z==="string"?z:"Unknown error";throw new e(`argon2-browser failure: ${Q}`)})}throw new Error(`Unsupported environment: ${Y}`)}class L0{presets;exportExtractable;name="argon2id";constructor(U,$=!1){this.presets=U;this.exportExtractable=$}async derive(U,$,V,Y){let{hash:z}=await gU(U,$,this.presets[V],Y.isNode?"node":"browser");if(this.exportExtractable)return Y.subtle.importKey("raw",z,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]);else return Y.subtle.importKey("raw",z,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}}var j0={low:{time:5,mem:65536,parallelism:1},middle:{time:20,mem:65536,parallelism:1},high:{time:40,mem:65536,parallelism:1}},c$={id:0,cipher:k0,kdf:new L0(j0),saltLengths:{low:12,high:16},difficulties:j0,defaultChunkSize:524288},l$={id:1,cipher:d0,kdf:new L0(j0,!0),saltLengths:{low:12,high:16},difficulties:j0,defaultChunkSize:524288};d.register(c$);d.register(l$);var _0=1;function cU(){return typeof process!=="undefined"&&typeof process.versions==="object"&&!0}function I0(...U){let $=U.reduce((z,Q)=>z+Q.byteLength,0),V=new Uint8Array($),Y=0;for(let z of U)V.set(z,Y),Y+=z.byteLength;return V}function M0(...U){try{let $=I0(...U);if(cU())return Buffer.from($).toString("base64");let V="";for(let Y=0;Y<$.length;Y++)V+=String.fromCharCode($[Y]);return btoa(V)}catch($){throw new m0("Base64 Enconding Error")}}function r0(U){try{if(!/^[A-Za-z0-9+/]+={0,2}$/.test(U)||U.length%4!==0)throw new Error("invalid base64");if(cU())return new Uint8Array(Buffer.from(U,"base64"));let $=atob(U),V=new Uint8Array($.length);for(let Y=0;Y<$.length;Y++)V[Y]=$.charCodeAt(Y);return V}catch($){throw new q0("Base64 Decoding Error")}}function v0(U,$,V,Y){let z={low:0,middle:1,high:2}[$]??0,Q=U<<5|(V==="high"?1:0)<<2|z;return I0(new Uint8Array([_0,Q]),Y)}function $0(U){if(U[0]!==_0)throw new a("Invalid input format. The input is unknown.");try{let $=U[1],V=$>>5,Y=$>>2&1?"high":"low",z=$&3,Q=["low","middle","high"][z],J=d.get(V).saltLengths[Y],G=U.slice(2,2+J);return{version:V,difficulty:Q,saltStrength:Y,salt:G,headerLen:2+J}}catch($){throw new W0($ instanceof Error?$.message:String($))}}class H0{engine;chunkSize;buffer=new Uint8Array(0);constructor(U,$=524288){this.engine=U;this.chunkSize=$}toTransformStream(){return new TransformStream({transform:async(U,$)=>{await this.transform(await this.asUint8Array(U),$)},flush:async(U)=>this.flush(U)})}async transform(U,$){let V=new Uint8Array(this.buffer.length+U.length);V.set(this.buffer),V.set(U,this.buffer.length);let Y=0;while(V.length-Y>=this.chunkSize){let z=V.slice(Y,Y+this.chunkSize);Y+=this.chunkSize;let Q=await this.engine.encryptChunk(z),J=new Uint8Array(4);new DataView(J.buffer).setUint32(0,Q.length,!1);let G=new Uint8Array(4+Q.length);G.set(J),G.set(Q,J.length),$.enqueue(G)}this.buffer=V.slice(Y)}async flush(U){if(!this.buffer.length)return;let $=await this.engine.encryptChunk(this.buffer),V=new Uint8Array(4);new DataView(V.buffer).setUint32(0,$.length,!1);let Y=new Uint8Array(4+$.length);Y.set(V),Y.set($,4),U.enqueue(Y),this.buffer=new Uint8Array(0)}async asUint8Array(U){if(U instanceof Uint8Array)return U;if(U instanceof ArrayBuffer)return new Uint8Array(U);return new Uint8Array(await U.arrayBuffer())}}class Z0{engine;chunkSize;buffer=new Uint8Array(0);constructor(U,$=524288){this.engine=U;this.chunkSize=$}toTransformStream(){return new TransformStream({transform:async(U,$)=>{await this.transform(await this.asUint8Array(U),$)},flush:async(U)=>this.flush(U)})}async transform(U,$){let V=new Uint8Array(this.buffer.length+U.length);V.set(this.buffer),V.set(U,this.buffer.length);let Y=0;while(!0){if(V.length-Y<4)break;let z=new DataView(V.buffer,V.byteOffset+Y,4).getUint32(0,!1);if(V.length-Y-4<z)break;Y+=4;let Q=V.slice(Y,Y+z);Y+=z;try{let J=await this.engine.decryptChunk(Q);$.enqueue(J)}catch(J){throw J instanceof n?J:new n("Decryption failed: Wrong passphrase or corrupted ciphertext")}}this.buffer=V.slice(Y)}async flush(U){await this.transform(new Uint8Array(0),U),this.buffer=new Uint8Array(0)}async asUint8Array(U){if(U instanceof Uint8Array)return U;if(U instanceof ArrayBuffer)return new Uint8Array(U);return new Uint8Array(await U.arrayBuffer())}}class X0{engine;chunkSize;constructor(U,$=524288){this.engine=U;this.chunkSize=$}encryptionStream(){let U=new H0(this.engine,this.chunkSize).toTransformStream();return{writable:U.writable,readable:U.readable}}decryptionStream(U){let $=U,V=new TransformStream({transform(z,Q){if($===0){Q.enqueue(z);return}if(z.byteLength<=$){$-=z.byteLength;return}Q.enqueue(z.slice($)),$=0}}),Y=new Z0(this.engine,this.chunkSize).toTransformStream();return{writable:V.writable,readable:V.readable.pipeThrough(Y)}}async collect(U,$,V=null){let Y=U.pipeThrough($).getReader(),z=[];if(V?.length)z.push(V);while(!0){let{value:W,done:Z}=await Y.read();if(Z)break;z.push(W)}let Q=z.reduce((W,Z)=>W+Z.byteLength,0),J=new Uint8Array(Q),G=0;for(let W of z)J.set(W,G),G+=W.byteLength;return J}}function lU(U=0,$=console.info){return{level:U,log(V,Y){if(V<=U)$(`${V}| ${Y}`)}}}var dU=new Map;class t{static getEngine(U,$){let V=dU.get($);if(V)return V;let Y=d.get($),z=new Y.cipher(U),Q=Y.kdf,J=Y.defaultChunkSize;return V={desc:Y,cipher:z,kdf:Q,chunkSize:J,provider:U},dU.set($,V),V}static async deriveKey(U,$,V,Y){try{let z=await U.kdf.derive($,V,Y,U.provider);U.cipher.setKey(z)}catch(z){let Q=z instanceof Error?z.message:String(z);throw new e(Q)}}}class V0{provider;v;cipher;kdf;chunkSize;stream;difficulty;saltStrength;engines=new Map;log;constructor(U,$={}){this.provider=U;this.v=d.get($.version??d.current.id),this.cipher=new this.v.cipher(U),this.kdf=this.v.kdf,this.chunkSize=$.chunkSize??this.v.defaultChunkSize,this.stream=new X0(this.cipher,this.chunkSize),this.difficulty=$.difficulty??"middle",this.saltStrength=$.saltStrength??"high",this.log=lU($.verbose??0,$.logger)}static async isEncrypted(U){try{return await V0.peekHeader(U),!0}catch{return!1}}static async headerDecode(U){let $=await V0.peekHeader(U),V=$0($);return{version:V.version,difficulty:V.difficulty,salt:M0(V.salt),saltLength:V.salt.byteLength}}setDifficulty(U){this.difficulty=U}getDifficulty(){return this.difficulty}setVersion(U){this.v=d.get(U),this.cipher=new this.v.cipher(this.provider),this.kdf=this.v.kdf,this.stream=new X0(this.cipher,this.chunkSize)}getVersion(){return this.v.id}setSaltDifficulty(U){this.saltStrength=U}getSaltDifficulty(){return this.saltStrength}setChunkSize(U){this.chunkSize=U,this.stream=new X0(this.cipher,this.chunkSize)}getChunkSize(){return this.chunkSize}setVerbose(U){this.log.level=U}getVerbose(){return this.log.level}async encryptText(U,$){try{this.log.log(1,`Start text encryption, Version ${this.getVersion()}`),this.log.log(2,"Deriving key for text encryption");let V=this.genSalt();await this.deriveKey($,V),this.log.log(3,`Salt generated: ${M0(V)}, KDF difficulty: ${this.difficulty}`),this.log.log(2,"Encrypting text data");let Y=await this.cipher.encryptChunk(typeof U==="string"?new TextEncoder().encode(U):U);this.log.log(3,"Encoding header");let z=v0(this.v.id,this.difficulty,this.saltStrength,V);this.log.log(3,"Encoding text");let Q=M0(z,Y);return this.log.log(1,"Decryption finished"),Q}catch(V){throw new A0(V instanceof Error?V.message:String(V))}}async decryptText(U,$){try{this.log.log(1,`Start text decryption, Version ${this.getVersion()}`),this.log.log(3,"Start text decoding");let V=r0(U);this.log.log(3,"Start header decoding"),await V0.peekHeader(U);let Y=$0(V);this.log.log(3,"Trying to get engine");let z=t.getEngine(this.provider,Y.version);this.log.log(2,"Deriving key via engine for text decryption"),this.log.log(3,`Salt use: ${M0(Y.salt)}, KDF difficulty: ${Y.difficulty}`),await t.deriveKey(z,$,Y.salt,Y.difficulty),this.log.log(2,"Decrypting text data");let Q=await z.cipher.decryptChunk(V.slice(Y.headerLen));this.log.log(3,"Decoding text");let J=new TextDecoder().decode(Q);return this.log.log(1,"Decryption finished"),J}catch(V){if(V instanceof n||V instanceof a||V instanceof W0||V instanceof q0||V instanceof e)throw V;throw new n("Decryption failed: wrong passphrase or corrupted ciphertext")}}async encryptFile(U,$){try{this.log.log(2,"Deriving key for file encryption");let V=this.genSalt();await this.deriveKey($,V);let Y=v0(this.v.id,this.difficulty,this.saltStrength,V),z=await this.stream.collect(U.stream(),new H0(this.cipher,this.chunkSize).toTransformStream(),Y);return new Blob([z],{type:"application/octet-stream"})}catch(V){throw new A0(V instanceof Error?V.message:String(V))}}async decryptFile(U,$){try{let V=await V0.peekHeader(U),Y=$0(V),z=t.getEngine(this.provider,Y.version);await t.deriveKey(z,$,Y.salt,Y.difficulty),this.log.log(2,"Decrypting file data");let J=await new X0(z.cipher,z.chunkSize).collect(U.slice(Y.headerLen).stream(),new Z0(z.cipher,z.chunkSize).toTransformStream());return new Blob([J],{type:"application/octet-stream"})}catch(V){if(V instanceof n)throw V;throw new n(V instanceof Error?V.message:String(V))}}async createEncryptionStream(U){this.log.log(2,"Deriving key for stream encryption");let $=this.genSalt();await this.deriveKey(U,$);let V=v0(this.v.id,this.difficulty,this.saltStrength,$),Y=this.stream.encryptionStream();return{header:V,writable:Y.writable,readable:Y.readable}}async createDecryptionStream(U){let $=this,V=new Uint8Array(0),Y=null;async function z(Q,J){let G=Q.getReader();while(!0){let{value:W,done:Z}=await G.read();if(Z)break;J.enqueue(W)}}return new TransformStream({async transform(Q,J){if(!Y){if(V=I0(V,Q),V.length<2)return;let W=V.slice(0,30),{salt:Z,difficulty:q}=$0(W),P=V[1]>>5,I=V[1]>>2&1?"high":"low",M=2+d.get(P).saltLengths[I];if(V.length<M)return;let H=t.getEngine($.provider,P);await t.deriveKey(H,U,Z,q),Y=new Z0(H.cipher,H.chunkSize).toTransformStream(),z(Y.readable,J);let A=V.slice(M);if(A.length){let N=Y.writable.getWriter();await N.write(A),N.releaseLock()}return}let G=Y.writable.getWriter();await G.write(Q),G.releaseLock()},async flush(){if(Y){let Q=Y.writable.getWriter();await Q.close(),Q.releaseLock()}}})}async deriveKey(U,$,V=this.difficulty){let Y=performance.now();try{let z=await this.kdf.derive(U,$,V,this.provider);this.cipher.setKey(z),this.log.log(3,`Key derivation completed in ${(performance.now()-Y).toFixed(1)} ms`)}catch(z){throw new e(z instanceof Error?z.message:String(z))}}genSalt(){let U=this.v.saltLengths[this.saltStrength];return this.provider.getRandomValues(new Uint8Array(U))}static async peekHeader(U){if(typeof U==="string")U=r0(U);if(U instanceof Uint8Array){if(U.length<2)throw new a("Input too short");let{headerLen:$}=$0(U.length>=16?U:Uint8Array.from(U));if(U.length<$)throw new a("Incomplete header");return U.slice(0,$)}if(U instanceof Blob){let $=new Uint8Array(await U.slice(0,2).arrayBuffer());if($[0]!==1)throw new a("Invalid input format. The input is unknown.");let V=$[1],Y=V>>5,z=V>>2&1?"high":"low",Q=d.get(Y).saltLengths[z],J=new Uint8Array(await U.slice(0,2+Q).arrayBuffer());return $0(J),J}throw new W0("Unsupported input type")}}import{webcrypto as d$,randomFillSync as n$}from"node:crypto";var nU={subtle:d$.subtle,getRandomValues(U){return n$(U),U},isNode:!0};function GY(U){return new V0(nU,U)}export{GY as createCryptit};

//# debugId=682619A192E62E6E64756E2164756E21
