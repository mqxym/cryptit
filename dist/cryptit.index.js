import{createRequire as V$}from"node:module";var J$=Object.create;var{getPrototypeOf:Q$,defineProperty:W0,getOwnPropertyNames:W$}=Object;var Z$=Object.prototype.hasOwnProperty;var xU=(U,$,Q)=>{Q=U!=null?J$(Q$(U)):{};let J=$||!U||!U.__esModule?W0(Q,"default",{value:U,enumerable:!0}):Q;for(let W of W$(U))if(!Z$.call(J,W))W0(J,W,{get:()=>U[W],enumerable:!0});return J};var LU=(U,$)=>()=>($||U(($={exports:{}}).exports,$),$.exports);var p=V$(import.meta.url);var A0=LU((BJ,S0)=>{var kU=/^[a-z0-9-]{1,32}$/,bU=/^[a-z0-9-]{1,32}$/,gU=/^[a-zA-Z0-9/+.-]+$/,w0=/^([a-zA-Z0-9/+.-]+|)$/,A$=/^((-)?[1-9]\d*|0)$/,oU=/^v=(\d+)$/;function B$(U){return HU(U).map(($)=>[$,U[$]].join("=")).join(",")}function D$(U){let $={};return U.split(",").forEach((Q)=>{let J=Q.split("=");if(J.length<2)throw new TypeError("params must be in the format name=value");$[J.shift()]=J.join("=")}),$}function HU(U){return Object.keys(U)}function H0(U){if(typeof Object.values==="function")return Object.values(U);return HU(U).map(($)=>U[$])}function R$(U){let $=[""];if(typeof U!=="object"||U===null)throw new TypeError("opts must be an object");if(typeof U.id!=="string")throw new TypeError("id must be a string");if(!kU.test(U.id))throw new TypeError(`id must satisfy ${kU}`);if($.push(U.id),typeof U.version!=="undefined"){if(typeof U.version!=="number"||U.version<0||!Number.isInteger(U.version))throw new TypeError("version must be a positive integer number");$.push(`v=${U.version}`)}if(typeof U.params!=="undefined"){if(typeof U.params!=="object"||U.params===null)throw new TypeError("params must be an object");let J=HU(U.params);if(!J.every((V)=>bU.test(V)))throw new TypeError(`params names must satisfy ${bU}`);J.forEach((V)=>{if(typeof U.params[V]==="number")U.params[V]=U.params[V].toString();else if(Buffer.isBuffer(U.params[V]))U.params[V]=U.params[V].toString("base64").split("=")[0]});let W=H0(U.params);if(!W.every((V)=>typeof V==="string"))throw new TypeError("params values must be strings");if(!W.every((V)=>gU.test(V)))throw new TypeError(`params values must satisfy ${gU}`);let Z=B$(U.params);$.push(Z)}if(typeof U.salt!=="undefined"){if(!Buffer.isBuffer(U.salt))throw new TypeError("salt must be a Buffer");if($.push(U.salt.toString("base64").split("=")[0]),typeof U.hash!=="undefined"){if(!Buffer.isBuffer(U.hash))throw new TypeError("hash must be a Buffer");$.push(U.hash.toString("base64").split("=")[0])}}return $.join("$")}function L$(U){if(typeof U!=="string"||U==="")throw new TypeError("pchstr must be a non-empty string");if(U[0]!=="$")throw new TypeError("pchstr must contain a $ as first char");let $=U.split("$");$.shift();let Q=5;if(!oU.test($[1]))Q--;if($.length>Q)throw new TypeError(`pchstr contains too many fileds: ${$.length}/${Q}`);let J=$.shift();if(!kU.test(J))throw new TypeError(`id must satisfy ${kU}`);let W;if(oU.test($[0]))W=parseInt($.shift().match(oU)[1],10);let Z,V;if(w0.test($[$.length-1]))if($.length>1&&w0.test($[$.length-2]))Z=Buffer.from($.pop(),"base64"),V=Buffer.from($.pop(),"base64");else V=Buffer.from($.pop(),"base64");let q;if($.length>0){let G=$.pop();if(q=D$(G),!HU(q).every((P)=>bU.test(P)))throw new TypeError(`params names must satisfy ${bU}`);if(!H0(q).every((P)=>gU.test(P)))throw new TypeError(`params values must satisfy ${gU}`);HU(q).forEach((P)=>{q[P]=A$.test(q[P])?parseInt(q[P],10):q[P]})}if($.length>0)throw new TypeError(`pchstr contains unrecognized fileds: ${$}`);let Y={id:J};if(W)Y.version=W;if(q)Y.params=q;if(V)Y.salt=V;if(Z)Y.hash=Z;return Y}S0.exports={serialize:R$,deserialize:L$}});var l0=LU((DJ,f0)=>{var L0=p("fs"),$U=p("path"),j0=p("os"),_0=typeof __webpack_require__==="function"?__non_webpack_require__:p,j$=process.config&&process.config.variables||{},_$=!!process.env.PREBUILDS_ONLY,B0=process.versions.modules,sU=E$()?"electron":C$()?"node-webkit":"node",rU=process.env.npm_config_arch||j0.arch(),aU=process.env.npm_config_platform||j0.platform(),v0=process.env.LIBC||(m$(aU)?"musl":"glibc"),tU=process.env.ARM_VERSION||(rU==="arm64"?"8":j$.arm_version)||"",C0=(process.versions.uv||"").split(".")[0];f0.exports=i;function i(U){return _0(i.resolve(U))}i.resolve=i.path=function(U){U=$U.resolve(U||".");try{var $=_0($U.join(U,"package.json")).name.toUpperCase().replace(/-/g,"_");if(process.env[$+"_PREBUILD"])U=process.env[$+"_PREBUILD"]}catch(Y){}if(!_$){var Q=D0($U.join(U,"build/Release"),R0);if(Q)return Q;var J=D0($U.join(U,"build/Debug"),R0);if(J)return J}var W=q(U);if(W)return W;var Z=q($U.dirname(process.execPath));if(Z)return Z;var V=["platform="+aU,"arch="+rU,"runtime="+sU,"abi="+B0,"uv="+C0,tU?"armv="+tU:"","libc="+v0,"node="+process.versions.node,process.versions.electron?"electron="+process.versions.electron:"",typeof __webpack_require__==="function"?"webpack=true":""].filter(Boolean).join(" ");throw new Error("No native build was found for "+V+`
    loaded from: `+U+`
`);function q(Y){var G=eU($U.join(Y,"prebuilds")).map(E0),K=G.filter(m0(aU,rU)).sort(k0)[0];if(!K)return;var X=$U.join(Y,"prebuilds",K.name),P=eU(X).map(b0),z=P.filter(g0(sU,B0)),F=z.sort(y0(sU))[0];if(F)return $U.join(X,F.file)}};function eU(U){try{return L0.readdirSync(U)}catch($){return[]}}function D0(U,$){var Q=eU(U).filter($);return Q[0]&&$U.join(U,Q[0])}function R0(U){return/\.node$/.test(U)}function E0(U){var $=U.split("-");if($.length!==2)return;var Q=$[0],J=$[1].split("+");if(!Q)return;if(!J.length)return;if(!J.every(Boolean))return;return{name:U,platform:Q,architectures:J}}function m0(U,$){return function(Q){if(Q==null)return!1;if(Q.platform!==U)return!1;return Q.architectures.includes($)}}function k0(U,$){return U.architectures.length-$.architectures.length}function b0(U){var $=U.split("."),Q=$.pop(),J={file:U,specificity:0};if(Q!=="node")return;for(var W=0;W<$.length;W++){var Z=$[W];if(Z==="node"||Z==="electron"||Z==="node-webkit")J.runtime=Z;else if(Z==="napi")J.napi=!0;else if(Z.slice(0,3)==="abi")J.abi=Z.slice(3);else if(Z.slice(0,2)==="uv")J.uv=Z.slice(2);else if(Z.slice(0,4)==="armv")J.armv=Z.slice(4);else if(Z==="glibc"||Z==="musl")J.libc=Z;else continue;J.specificity++}return J}function g0(U,$){return function(Q){if(Q==null)return!1;if(Q.runtime&&Q.runtime!==U&&!v$(Q))return!1;if(Q.abi&&Q.abi!==$&&!Q.napi)return!1;if(Q.uv&&Q.uv!==C0)return!1;if(Q.armv&&Q.armv!==tU)return!1;if(Q.libc&&Q.libc!==v0)return!1;return!0}}function v$(U){return U.runtime==="node"&&U.napi}function y0(U){return function($,Q){if($.runtime!==Q.runtime)return $.runtime===U?-1:1;else if($.abi!==Q.abi)return $.abi?-1:1;else if($.specificity!==Q.specificity)return $.specificity>Q.specificity?-1:1;else return 0}}function C$(){return!!(process.versions&&process.versions.nw)}function E$(){if(process.versions&&process.versions.electron)return!0;if(process.env.ELECTRON_RUN_AS_NODE)return!0;return typeof window!=="undefined"&&window.process&&window.process.type==="renderer"}function m$(U){return U==="linux"&&L0.existsSync("/etc/alpine-release")}i.parseTags=b0;i.matchTags=g0;i.compareTags=y0;i.parseTuple=E0;i.matchTuple=m0;i.compareTuples=k0});var c0=LU((LJ,$0)=>{var U0=typeof __webpack_require__==="function"?__non_webpack_require__:p;if(typeof U0.addon==="function")$0.exports=U0.addon.bind(U0);else $0.exports=l0()});var d0=LU((d$,GU)=>{var __dirname="/Users/maxim/Projects/Private/Sites/cryptit/node_modules/argon2",_J=p("node:assert"),{randomBytes:k$,timingSafeEqual:b$}=p("node:crypto"),{promisify:g$}=p("node:util"),{deserialize:x0,serialize:y$}=A0(),f$=c0(),{hash:u0}=f$(__dirname),l$=g$(k$);d$.argon2d=0;d$.argon2i=1;d$.argon2id=2;var SU=Object.freeze({argon2d:0,argon2i:1,argon2id:2}),c$=Object.freeze({[SU.argon2d]:"argon2d",[SU.argon2i]:"argon2i",[SU.argon2id]:"argon2id"}),h0={hashLength:32,timeCost:3,memoryCost:65536,parallelism:4,type:2,version:19};async function x$(U,$){let{raw:Q,salt:J,...W}={...h0,...$};if(W.hashLength>4294967295)throw new RangeError("Hash length is too large");if(W.memoryCost>4294967295)throw new RangeError("Memory cost is too large");if(W.timeCost>4294967295)throw new RangeError("Time cost is too large");if(W.parallelism>16777215)throw new RangeError("Parallelism is too large");J=J??await l$(16);let{hashLength:Z,secret:V=Buffer.alloc(0),type:q,version:Y,memoryCost:G,timeCost:K,parallelism:X,associatedData:P=Buffer.alloc(0)}=W,z=await u0({password:Buffer.from(U),salt:J,secret:V,data:P,hashLength:Z,m:G,t:K,p:X,version:Y,type:q});if(Q)return z;return y$({id:c$[q],version:Y,params:{m:G,t:K,p:X,...P.byteLength>0?{data:P}:{}},salt:J,hash:z})}d$.hash=x$;function u$(U,$={}){let{memoryCost:Q,timeCost:J,parallelism:W,version:Z}={...h0,...$},{version:V,params:{m:q,t:Y,p:G}}=x0(U);return+V!==+Z||+q!==+Q||+Y!==+J||+G!==+W}d$.needsRehash=u$;async function h$(U,$,Q={}){let{id:J,...W}=x0(U);if(!(J in SU))return!1;let{version:Z=16,params:{m:V,t:q,p:Y,data:G=""},salt:K,hash:X}=W,{secret:P=Buffer.alloc(0)}=Q;return b$(await u0({password:Buffer.from($),salt:K,secret:P,data:Buffer.from(G,"base64"),hashLength:X.byteLength,m:+V,t:+q,p:+Y,version:+Z,type:SU[J]}),X)}d$.verify=h$});class r extends Error{constructor(U){super(U);Object.setPrototypeOf(this,new.target.prototype),this.name=new.target.name,this.stack=void 0}}class d extends r{}class FU extends r{}class uU extends r{}class jU extends r{}class VU extends r{}class a extends r{}class n extends r{}class u extends r{}class c{static byId=new Map;static register(U){if(this.byId.has(U.id))throw new jU(`Scheme ${U.id} already registered`);this.byId.set(U.id,U)}static get(U){let $=this.byId.get(U);if(!$)throw new jU(`Unknown scheme: ${U}`);return $}static get current(){return this.get(0)}}class YU{p;static IV_LENGTH=12;static TAG_LENGTH=16;IV_LENGTH=YU.IV_LENGTH;TAG_LENGTH=YU.TAG_LENGTH;key;aad=new Uint8Array(0);constructor(U){this.p=U}async setKey(U){this.key=U}async encryptChunk(U){let $=this.p.getRandomValues(new Uint8Array(YU.IV_LENGTH)),Q=this.aad.length?{name:"AES-GCM",iv:$,additionalData:this.aad}:{name:"AES-GCM",iv:$},J=await this.p.subtle.encrypt(Q,this.requireKey(),U),W=new Uint8Array(J);U.fill(0);let Z=new Uint8Array($.length+W.length);return Z.set($,0),Z.set(W,$.length),Z}async decryptChunk(U){let $=U.slice(0,YU.IV_LENGTH),Q=U.slice(YU.IV_LENGTH),J=this.aad.length?{name:"AES-GCM",iv:$,additionalData:this.aad}:{name:"AES-GCM",iv:$};try{let W=await this.p.subtle.decrypt(J,this.requireKey(),Q);return new Uint8Array(W)}catch{throw new u("Decryption failed: wrong passphrase or corrupted ciphertext")}}zeroKey(){this.key=null}setAAD(U){this.aad=U&&U.byteLength?new Uint8Array(U):new Uint8Array(0)}requireKey(){if(!this.key)throw new Error("Encryption key not set");return this.key}}/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function V0(U){return U instanceof Uint8Array||ArrayBuffer.isView(U)&&U.constructor.name==="Uint8Array"}function _U(U){if(typeof U!=="boolean")throw new Error(`boolean expected, not ${U}`)}function vU(U){if(!Number.isSafeInteger(U)||U<0)throw new Error("positive integer expected, got "+U)}function x(U,...$){if(!V0(U))throw new Error("Uint8Array expected");if($.length>0&&!$.includes(U.length))throw new Error("Uint8Array expected of length "+$+", got length="+U.length)}function hU(U,$=!0){if(U.destroyed)throw new Error("Hash instance has been destroyed");if($&&U.finished)throw new Error("Hash#digest() has already been called")}function Y0(U,$){x(U);let Q=$.outputLen;if(U.length<Q)throw new Error("digestInto() expects output buffer of length at least "+Q)}function t(U){return new Uint32Array(U.buffer,U.byteOffset,Math.floor(U.byteLength/4))}function e(...U){for(let $=0;$<U.length;$++)U[$].fill(0)}function Y$(U){return new DataView(U.buffer,U.byteOffset,U.byteLength)}var q$=(()=>new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68)();function G$(U){if(typeof U!=="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(U))}function CU(U){if(typeof U==="string")U=G$(U);else if(V0(U))U=EU(U);else throw new Error("Uint8Array expected, got "+typeof U);return U}function q0(U,$){if($==null||typeof $!=="object")throw new Error("options must be defined");return Object.assign(U,$)}function G0(U,$){if(U.length!==$.length)return!1;let Q=0;for(let J=0;J<U.length;J++)Q|=U[J]^$[J];return Q===0}var dU=(U,$)=>{function Q(J,...W){if(x(J),!q$)throw new Error("Non little-endian hardware is not yet supported");if(U.nonceLength!==void 0){let K=W[0];if(!K)throw new Error("nonce / iv required");if(U.varSizeNonce)x(K);else x(K,U.nonceLength)}let Z=U.tagLength;if(Z&&W[1]!==void 0)x(W[1]);let V=$(J,...W),q=(K,X)=>{if(X!==void 0){if(K!==2)throw new Error("cipher output not supported");x(X)}},Y=!1;return{encrypt(K,X){if(Y)throw new Error("cannot encrypt() twice with same key + nonce");return Y=!0,x(K),q(V.encrypt.length,X),V.encrypt(K,X)},decrypt(K,X){if(x(K),Z&&K.length<Z)throw new Error("invalid ciphertext length: smaller than tagLength="+Z);return q(V.decrypt.length,X),V.decrypt(K,X)}}}return Object.assign(Q,U),Q};function pU(U,$,Q=!0){if($===void 0)return new Uint8Array(U);if($.length!==U)throw new Error("invalid output length, expected "+U+", got: "+$.length);if(Q&&!K$($))throw new Error("invalid output, must be aligned");return $}function Z0(U,$,Q,J){if(typeof U.setBigUint64==="function")return U.setBigUint64($,Q,J);let W=BigInt(32),Z=BigInt(4294967295),V=Number(Q>>W&Z),q=Number(Q&Z),Y=J?4:0,G=J?0:4;U.setUint32($+Y,V,J),U.setUint32($+G,q,J)}function K0(U,$,Q){_U(Q);let J=new Uint8Array(16),W=Y$(J);return Z0(W,0,BigInt($),Q),Z0(W,8,BigInt(U),Q),J}function K$(U){return U.byteOffset%4===0}function EU(U){return Uint8Array.from(U)}var X0=(U)=>Uint8Array.from(U.split("").map(($)=>$.charCodeAt(0))),N$=X0("expand 16-byte k"),X$=X0("expand 32-byte k"),P$=t(N$),O$=t(X$);function N(U,$){return U<<$|U>>>32-$}function nU(U){return U.byteOffset%4===0}var mU=64,F$=16,P0=4294967295,N0=new Uint32Array;function z$(U,$,Q,J,W,Z,V,q){let Y=W.length,G=new Uint8Array(mU),K=t(G),X=nU(W)&&nU(Z),P=X?t(W):N0,z=X?t(Z):N0;for(let F=0;F<Y;V++){if(U($,Q,J,K,V,q),V>=P0)throw new Error("arx: counter overflow");let I=Math.min(mU,Y-F);if(X&&I===mU){let T=F/4;if(F%4!==0)throw new Error("arx: invalid block position");for(let M=0,H;M<F$;M++)H=T+M,z[H]=P[H]^K[M];F+=mU;continue}for(let T=0,M;T<I;T++)M=F+T,Z[M]=W[M]^G[T];F+=I}}function iU(U,$){let{allowShortKeys:Q,extendNonceFn:J,counterLength:W,counterRight:Z,rounds:V}=q0({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},$);if(typeof U!=="function")throw new Error("core must be a function");return vU(W),vU(V),_U(Z),_U(Q),(q,Y,G,K,X=0)=>{x(q),x(Y),x(G);let P=G.length;if(K===void 0)K=new Uint8Array(P);if(x(K),vU(X),X<0||X>=P0)throw new Error("arx: counter overflow");if(K.length<P)throw new Error(`arx: output (${K.length}) is shorter than data (${P})`);let z=[],F=q.length,I,T;if(F===32)z.push(I=EU(q)),T=O$;else if(F===16&&Q)I=new Uint8Array(32),I.set(q),I.set(q,16),T=P$,z.push(I);else throw new Error(`arx: invalid 32-byte key, got length=${F}`);if(!nU(Y))z.push(Y=EU(Y));let M=t(I);if(J){if(Y.length!==24)throw new Error("arx: extended nonce must be 24 bytes");J(T,M,t(Y.subarray(0,16)),M),Y=Y.subarray(16)}let H=16-W;if(H!==Y.length)throw new Error(`arx: nonce must be ${H} or 16 bytes`);if(H!==12){let g=new Uint8Array(12);g.set(Y,Z?0:12-Y.length),Y=g,z.push(Y)}let w=t(Y);return z$(U,T,M,w,G,K,X,V),e(...z),K}}var y=(U,$)=>U[$++]&255|(U[$++]&255)<<8;class O0{constructor(U){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,U=CU(U),x(U,32);let $=y(U,0),Q=y(U,2),J=y(U,4),W=y(U,6),Z=y(U,8),V=y(U,10),q=y(U,12),Y=y(U,14);this.r[0]=$&8191,this.r[1]=($>>>13|Q<<3)&8191,this.r[2]=(Q>>>10|J<<6)&7939,this.r[3]=(J>>>7|W<<9)&8191,this.r[4]=(W>>>4|Z<<12)&255,this.r[5]=Z>>>1&8190,this.r[6]=(Z>>>14|V<<2)&8191,this.r[7]=(V>>>11|q<<5)&8065,this.r[8]=(q>>>8|Y<<8)&8191,this.r[9]=Y>>>5&127;for(let G=0;G<8;G++)this.pad[G]=y(U,16+2*G)}process(U,$,Q=!1){let J=Q?0:2048,{h:W,r:Z}=this,V=Z[0],q=Z[1],Y=Z[2],G=Z[3],K=Z[4],X=Z[5],P=Z[6],z=Z[7],F=Z[8],I=Z[9],T=y(U,$+0),M=y(U,$+2),H=y(U,$+4),w=y(U,$+6),g=y(U,$+8),ZU=y(U,$+10),f=y(U,$+12),l=y(U,$+14),S=W[0]+(T&8191),A=W[1]+((T>>>13|M<<3)&8191),B=W[2]+((M>>>10|H<<6)&8191),D=W[3]+((H>>>7|w<<9)&8191),R=W[4]+((w>>>4|g<<12)&8191),L=W[5]+(g>>>1&8191),j=W[6]+((g>>>14|ZU<<2)&8191),_=W[7]+((ZU>>>11|f<<5)&8191),v=W[8]+((f>>>8|l<<8)&8191),C=W[9]+(l>>>5|J),O=0,m=O+S*V+A*(5*I)+B*(5*F)+D*(5*z)+R*(5*P);O=m>>>13,m&=8191,m+=L*(5*X)+j*(5*K)+_*(5*G)+v*(5*Y)+C*(5*q),O+=m>>>13,m&=8191;let k=O+S*q+A*V+B*(5*I)+D*(5*F)+R*(5*z);O=k>>>13,k&=8191,k+=L*(5*P)+j*(5*X)+_*(5*K)+v*(5*G)+C*(5*Y),O+=k>>>13,k&=8191;let b=O+S*Y+A*q+B*V+D*(5*I)+R*(5*F);O=b>>>13,b&=8191,b+=L*(5*z)+j*(5*P)+_*(5*X)+v*(5*K)+C*(5*G),O+=b>>>13,b&=8191;let E=O+S*G+A*Y+B*q+D*V+R*(5*I);O=E>>>13,E&=8191,E+=L*(5*F)+j*(5*z)+_*(5*P)+v*(5*X)+C*(5*K),O+=E>>>13,E&=8191;let s=O+S*K+A*G+B*Y+D*q+R*V;O=s>>>13,s&=8191,s+=L*(5*I)+j*(5*F)+_*(5*z)+v*(5*P)+C*(5*X),O+=s>>>13,s&=8191;let KU=O+S*X+A*K+B*G+D*Y+R*q;O=KU>>>13,KU&=8191,KU+=L*V+j*(5*I)+_*(5*F)+v*(5*z)+C*(5*P),O+=KU>>>13,KU&=8191;let NU=O+S*P+A*X+B*K+D*G+R*Y;O=NU>>>13,NU&=8191,NU+=L*q+j*V+_*(5*I)+v*(5*F)+C*(5*z),O+=NU>>>13,NU&=8191;let XU=O+S*z+A*P+B*X+D*K+R*G;O=XU>>>13,XU&=8191,XU+=L*Y+j*q+_*V+v*(5*I)+C*(5*F),O+=XU>>>13,XU&=8191;let PU=O+S*F+A*z+B*P+D*X+R*K;O=PU>>>13,PU&=8191,PU+=L*G+j*Y+_*q+v*V+C*(5*I),O+=PU>>>13,PU&=8191;let OU=O+S*I+A*F+B*z+D*P+R*X;O=OU>>>13,OU&=8191,OU+=L*K+j*G+_*Y+v*q+C*V,O+=OU>>>13,OU&=8191,O=(O<<2)+O|0,O=O+m|0,m=O&8191,O=O>>>13,k+=O,W[0]=m,W[1]=k,W[2]=b,W[3]=E,W[4]=s,W[5]=KU,W[6]=NU,W[7]=XU,W[8]=PU,W[9]=OU}finalize(){let{h:U,pad:$}=this,Q=new Uint16Array(10),J=U[1]>>>13;U[1]&=8191;for(let V=2;V<10;V++)U[V]+=J,J=U[V]>>>13,U[V]&=8191;U[0]+=J*5,J=U[0]>>>13,U[0]&=8191,U[1]+=J,J=U[1]>>>13,U[1]&=8191,U[2]+=J,Q[0]=U[0]+5,J=Q[0]>>>13,Q[0]&=8191;for(let V=1;V<10;V++)Q[V]=U[V]+J,J=Q[V]>>>13,Q[V]&=8191;Q[9]-=8192;let W=(J^1)-1;for(let V=0;V<10;V++)Q[V]&=W;W=~W;for(let V=0;V<10;V++)U[V]=U[V]&W|Q[V];U[0]=(U[0]|U[1]<<13)&65535,U[1]=(U[1]>>>3|U[2]<<10)&65535,U[2]=(U[2]>>>6|U[3]<<7)&65535,U[3]=(U[3]>>>9|U[4]<<4)&65535,U[4]=(U[4]>>>12|U[5]<<1|U[6]<<14)&65535,U[5]=(U[6]>>>2|U[7]<<11)&65535,U[6]=(U[7]>>>5|U[8]<<8)&65535,U[7]=(U[8]>>>8|U[9]<<5)&65535;let Z=U[0]+$[0];U[0]=Z&65535;for(let V=1;V<8;V++)Z=(U[V]+$[V]|0)+(Z>>>16)|0,U[V]=Z&65535;e(Q)}update(U){hU(this),U=CU(U),x(U);let{buffer:$,blockLen:Q}=this,J=U.length;for(let W=0;W<J;){let Z=Math.min(Q-this.pos,J-W);if(Z===Q){for(;Q<=J-W;W+=Q)this.process(U,W);continue}if($.set(U.subarray(W,W+Z),this.pos),this.pos+=Z,W+=Z,this.pos===Q)this.process($,0,!1),this.pos=0}return this}destroy(){e(this.h,this.r,this.buffer,this.pad)}digestInto(U){hU(this),Y0(U,this),this.finished=!0;let{buffer:$,h:Q}=this,{pos:J}=this;if(J){$[J++]=1;for(;J<16;J++)$[J]=0;this.process($,0,!0)}this.finalize();let W=0;for(let Z=0;Z<8;Z++)U[W++]=Q[Z]>>>0,U[W++]=Q[Z]>>>8;return U}digest(){let{buffer:U,outputLen:$}=this;this.digestInto(U);let Q=U.slice(0,$);return this.destroy(),Q}}function I$(U){let $=(J,W)=>U(W).update(CU(J)).digest(),Q=U(new Uint8Array(32));return $.outputLen=Q.outputLen,$.blockLen=Q.blockLen,$.create=(J)=>U(J),$}var F0=I$((U)=>new O0(U));function M0(U,$,Q,J,W,Z=20){let V=U[0],q=U[1],Y=U[2],G=U[3],K=$[0],X=$[1],P=$[2],z=$[3],F=$[4],I=$[5],T=$[6],M=$[7],H=W,w=Q[0],g=Q[1],ZU=Q[2],f=V,l=q,S=Y,A=G,B=K,D=X,R=P,L=z,j=F,_=I,v=T,C=M,O=H,m=w,k=g,b=ZU;for(let s=0;s<Z;s+=2)f=f+B|0,O=N(O^f,16),j=j+O|0,B=N(B^j,12),f=f+B|0,O=N(O^f,8),j=j+O|0,B=N(B^j,7),l=l+D|0,m=N(m^l,16),_=_+m|0,D=N(D^_,12),l=l+D|0,m=N(m^l,8),_=_+m|0,D=N(D^_,7),S=S+R|0,k=N(k^S,16),v=v+k|0,R=N(R^v,12),S=S+R|0,k=N(k^S,8),v=v+k|0,R=N(R^v,7),A=A+L|0,b=N(b^A,16),C=C+b|0,L=N(L^C,12),A=A+L|0,b=N(b^A,8),C=C+b|0,L=N(L^C,7),f=f+D|0,b=N(b^f,16),v=v+b|0,D=N(D^v,12),f=f+D|0,b=N(b^f,8),v=v+b|0,D=N(D^v,7),l=l+R|0,O=N(O^l,16),C=C+O|0,R=N(R^C,12),l=l+R|0,O=N(O^l,8),C=C+O|0,R=N(R^C,7),S=S+L|0,m=N(m^S,16),j=j+m|0,L=N(L^j,12),S=S+L|0,m=N(m^S,8),j=j+m|0,L=N(L^j,7),A=A+B|0,k=N(k^A,16),_=_+k|0,B=N(B^_,12),A=A+B|0,k=N(k^A,8),_=_+k|0,B=N(B^_,7);let E=0;J[E++]=V+f|0,J[E++]=q+l|0,J[E++]=Y+S|0,J[E++]=G+A|0,J[E++]=K+B|0,J[E++]=X+D|0,J[E++]=P+R|0,J[E++]=z+L|0,J[E++]=F+j|0,J[E++]=I+_|0,J[E++]=T+v|0,J[E++]=M+C|0,J[E++]=H+O|0,J[E++]=w+m|0,J[E++]=g+k|0,J[E++]=ZU+b|0}function M$(U,$,Q,J){let W=U[0],Z=U[1],V=U[2],q=U[3],Y=$[0],G=$[1],K=$[2],X=$[3],P=$[4],z=$[5],F=$[6],I=$[7],T=Q[0],M=Q[1],H=Q[2],w=Q[3];for(let ZU=0;ZU<20;ZU+=2)W=W+Y|0,T=N(T^W,16),P=P+T|0,Y=N(Y^P,12),W=W+Y|0,T=N(T^W,8),P=P+T|0,Y=N(Y^P,7),Z=Z+G|0,M=N(M^Z,16),z=z+M|0,G=N(G^z,12),Z=Z+G|0,M=N(M^Z,8),z=z+M|0,G=N(G^z,7),V=V+K|0,H=N(H^V,16),F=F+H|0,K=N(K^F,12),V=V+K|0,H=N(H^V,8),F=F+H|0,K=N(K^F,7),q=q+X|0,w=N(w^q,16),I=I+w|0,X=N(X^I,12),q=q+X|0,w=N(w^q,8),I=I+w|0,X=N(X^I,7),W=W+G|0,w=N(w^W,16),F=F+w|0,G=N(G^F,12),W=W+G|0,w=N(w^W,8),F=F+w|0,G=N(G^F,7),Z=Z+K|0,T=N(T^Z,16),I=I+T|0,K=N(K^I,12),Z=Z+K|0,T=N(T^Z,8),I=I+T|0,K=N(K^I,7),V=V+X|0,M=N(M^V,16),P=P+M|0,X=N(X^P,12),V=V+X|0,M=N(M^V,8),P=P+M|0,X=N(X^P,7),q=q+Y|0,H=N(H^q,16),z=z+H|0,Y=N(Y^z,12),q=q+Y|0,H=N(H^q,8),z=z+H|0,Y=N(Y^z,7);let g=0;J[g++]=W,J[g++]=Z,J[g++]=V,J[g++]=q,J[g++]=T,J[g++]=M,J[g++]=H,J[g++]=w}var T$=iU(M0,{counterRight:!1,counterLength:4,allowShortKeys:!1}),w$=iU(M0,{counterRight:!1,counterLength:8,extendNonceFn:M$,allowShortKeys:!1});var H$=new Uint8Array(16),z0=(U,$)=>{U.update($);let Q=$.length%16;if(Q)U.update(H$.subarray(Q))},S$=new Uint8Array(32);function I0(U,$,Q,J,W){let Z=U($,Q,S$),V=F0.create(Z);if(W)z0(V,W);z0(V,J);let q=K0(J.length,W?W.length:0,!0);V.update(q);let Y=V.digest();return e(Z,q),Y}var T0=(U)=>($,Q,J)=>{return{encrypt(Z,V){let q=Z.length;V=pU(q+16,V,!1),V.set(Z);let Y=V.subarray(0,-16);U($,Q,Y,Y,1);let G=I0(U,$,Q,Y,J);return V.set(G,q),e(G),V},decrypt(Z,V){V=pU(Z.length-16,V,!1);let q=Z.subarray(0,-16),Y=Z.subarray(-16),G=I0(U,$,Q,q,J);if(!G0(Y,G))throw new Error("invalid tag");return V.set(Z.subarray(0,-16)),U($,Q,V,V,1),e(G),V}}},TJ=dU({blockSize:64,nonceLength:12,tagLength:16},T0(T$)),wU=dU({blockSize:64,nonceLength:24,tagLength:16},T0(w$));class UU{p;static IV_LENGTH=24;static TAG_LENGTH=16;IV_LENGTH=UU.IV_LENGTH;TAG_LENGTH=UU.TAG_LENGTH;key;aad=new Uint8Array(0);constructor(U){this.p=U}async setKey(U){this.key=new Uint8Array(await this.p.subtle.exportKey("raw",U))}async encryptChunk(U){if(!this.key)throw new Error("Key not set");let $=this.p.getRandomValues(new Uint8Array(UU.IV_LENGTH)),J=(this.aad.length?wU(this.key,$,this.aad):wU(this.key,$)).encrypt(U);U.fill(0);let W=new Uint8Array($.length+J.length);return W.set($,0),W.set(J,$.length),W}async decryptChunk(U){if(!this.key)throw new Error("Key not set");if(U.byteLength<UU.IV_LENGTH+16)throw new u("Invalid ciphertext: too short.");let $=U.slice(0,UU.IV_LENGTH),Q=U.slice(UU.IV_LENGTH),J=this.aad.length?wU(this.key,$,this.aad):wU(this.key,$);try{return J.decrypt(Q)}catch{throw new u("Decryption failed: wrong passphrase or corrupted ciphertext")}}zeroKey(){if(this.key)this.key.fill(0)}setAAD(U){this.aad=U&&U.byteLength?new Uint8Array(U):new Uint8Array(0)}}import*as yU from"argon2-browser";async function a$(){if(typeof window!=="undefined")return;if(globalThis.loadArgon2WasmModule)return;try{let{createRequire:U}=await import("node:module"),{readFile:$}=await import("node:fs/promises"),Q=U(import.meta.url),J=Q.resolve("argon2-browser/dist/argon2.js"),W=Q.resolve("argon2-browser/dist/argon2.wasm");globalThis.loadArgon2WasmModule=async()=>{let Z=new Uint8Array(await $(W));return globalThis.Module={wasmBinary:Z,locateFile:(V)=>V==="argon2.wasm"?W:V},Q(J)}}catch{}}async function p0(U,$,Q,J){if(J==="node"){let W=await Promise.resolve().then(() => xU(d0(),1)),Z=typeof U==="string"?Buffer.from(U,"utf8"):Buffer.from(U),V=Buffer.from($),q=await W.hash(Z,{salt:V,timeCost:Q.time,memoryCost:Q.mem,parallelism:Q.parallelism,hashLength:32,raw:!0,type:W.argon2id});return V.fill(0),Z.fill(0),{hash:new Uint8Array(q)}}if(J==="browser")return await a$(),yU.hash({pass:U,salt:$,time:Q.time,mem:Q.mem,parallelism:Q.parallelism,hashLen:32,type:yU.ArgonType.Argon2id}).then((W)=>{if(!W||!W.hash)throw new a("Failed to produce key derivation");return{hash:W.hash}}).catch((W)=>{let Z=W instanceof Error?W.message:typeof W==="string"?W:"Unknown error";throw new a(`argon2-browser failure: ${Z}`)});throw new Error(`Unsupported environment: ${J}`)}class fU{presets;exportExtractable;name="argon2id";constructor(U,$=!1){this.presets=U;this.exportExtractable=$}async derive(U,$,Q,J){let{hash:W}=await p0(U,$,this.presets[Q],J.isNode?"node":"browser");if(this.exportExtractable)return J.subtle.importKey("raw",W,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]);else return J.subtle.importKey("raw",W,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}}var n0={low:{time:5,mem:65536,parallelism:1},middle:{time:20,mem:65536,parallelism:1},high:{time:40,mem:65536,parallelism:1}},t$={id:0,cipher:YU,kdf:new fU(n0),saltLengths:{low:12,high:16},difficulties:n0,defaultChunkSize:524288};c.register(t$);var i0={low:{time:5,mem:65536,parallelism:2},middle:{time:10,mem:98304,parallelism:4},high:{time:20,mem:98304,parallelism:4}},e$={id:1,cipher:UU,kdf:new fU(i0,!0),saltLengths:{low:12,high:16},difficulties:i0,defaultChunkSize:524288};c.register(e$);var lU=1;function o0(){return typeof process!=="undefined"&&typeof process.versions==="object"&&!0}function zU(...U){let $=U.reduce((W,Z)=>W+Z.byteLength,0),Q=new Uint8Array($),J=0;for(let W of U)Q.set(W,J),J+=W.byteLength;return Q}function IU(...U){try{let $=zU(...U);if(o0())return Buffer.from($).toString("base64");let Q="";for(let J=0;J<$.length;J++)Q+=String.fromCharCode($[J]);return btoa(Q)}catch{throw new uU("Base64 Encoding Error")}}function AU(U){try{if(!/^[A-Za-z0-9+/]+={0,2}$/.test(U)||U.length%4!==0)throw new Error("Invalid Base64");if(o0())return new Uint8Array(Buffer.from(U,"base64"));let $=atob(U),Q=new Uint8Array($.length);for(let J=0;J<$.length;J++)Q[J]=$.charCodeAt(J);return Q}catch{throw new FU(`Invalid Base64: length=${U.length}, content='${U.slice(0,12)}…'`)}}function h(U){let $=U.value.length,Q=new Array($).fill("\x00").join("");U.value=Q}function BU(U,$,Q,J,W){let Z={low:0,middle:1,high:2};if(!($ in Z))throw new TypeError(`Unsupported difficulty: ${$}`);let V=Z[$],q=U<<5|(Q==="high"?1:0)<<2|V,Y=zU(new Uint8Array([lU,q]),J);if(W)W.setAAD(Y);return Y}function o(U,$){if(U[0]!==lU)throw new d("Invalid input format. The input is unknown.");if(U.length<14)throw new d("Invalid input format. Header too short.");try{let Q=U[1],J=Q>>5,W=Q>>2&1?"high":"low",Z=Q&3,V=["low","middle","high"][Z],q=c.get(J).saltLengths[W],Y=2+q;if(U.length<Y)throw new d("Invalid input format. Header truncated.");if($)$.setAAD(U.subarray(0,Y));let G=U.slice(2,2+q);return{scheme:J,difficulty:V,saltStrength:W,salt:G,headerLen:Y}}catch(Q){throw new VU(Q instanceof Error?Q.message:String(Q))}}async function cU(U){if(U instanceof Uint8Array)return U;if(U instanceof ArrayBuffer)return new Uint8Array(U);return new Uint8Array(await U.arrayBuffer())}function J0(U){let $=new Uint8Array(4);return new DataView($.buffer).setUint32(0,U,!1),$}function s0(U,$=0){if(U.length-$<4)throw new RangeError("Not enough bytes for frame header");return new DataView(U.buffer,U.byteOffset+$,4).getUint32(0,!1)}var JU=4;class DU{engine;chunkSize;buffer=new Uint8Array(0);constructor(U,$=524288){this.engine=U;this.chunkSize=$}toTransformStream(){return new TransformStream({transform:async(U,$)=>{await this.transform(await cU(U),$)},flush:async(U)=>this.flush(U)})}async transform(U,$){if(U.length>Math.min(this.chunkSize*4,67108864))throw new RangeError(`Input block (${U.length} B) exceeds maximum allowed ${Math.min(this.chunkSize*4,67108864)} B`);let J=new Uint8Array(this.buffer.length+U.length);J.set(this.buffer),J.set(U,this.buffer.length);let W=0;while(J.length-W>=this.chunkSize){let Z=J.slice(W,W+this.chunkSize);W+=this.chunkSize;let V=await this.engine.encryptChunk(Z),q=new Uint8Array(JU+V.length);q.set(J0(V.length)),q.set(V,JU),$.enqueue(q)}this.buffer=J.slice(W)}async flush(U){if(!this.buffer.length)return;let $=await this.engine.encryptChunk(this.buffer),Q=new Uint8Array(JU+$.length);Q.set(J0($.length)),Q.set($,JU),U.enqueue(Q),this.buffer=new Uint8Array(0),this.engine.zeroKey()}}class MU{engine;chunkSize;buffer=new Uint8Array(0);constructor(U,$=524288){this.engine=U;this.chunkSize=$}toTransformStream(){return new TransformStream({transform:async(U,$)=>{await this.transform(await cU(U),$)},flush:async(U)=>this.flush(U)})}async transform(U,$){let Q=new Uint8Array(this.buffer.length+U.length);Q.set(this.buffer),Q.set(U,this.buffer.length);let J=0;while(!0){if(Q.length-J<JU)break;let W=s0(Q,J);if(W>this.chunkSize*2)throw new u(`Frame length ${W} exceeds …`);if(Q.length-J-JU<W)break;J+=JU;let Z=Q.slice(J,J+W);J+=W;try{let V=await this.engine.decryptChunk(Z);$.enqueue(V)}catch(V){throw V instanceof u?V:new u("Decryption failed: Wrong passphrase or corrupted ciphertext")}}this.buffer=Q.slice(J)}async flush(U){await this.transform(new Uint8Array(0),U),this.buffer=new Uint8Array(0),this.engine.zeroKey()}}async function r0(U,$){let Q=U.getReader(),J=$&&$.length?[$]:[];try{while(!0){let{value:q,done:Y}=await Q.read();if(Y)break;J.push(q)}}finally{Q.releaseLock()}let W=J.reduce((q,Y)=>q+Y.byteLength,0),Z=new Uint8Array(W),V=0;for(let q of J)Z.set(q,V),V+=q.byteLength;return Z}class TU{engine;chunkSize;constructor(U,$=524288){this.engine=U;this.chunkSize=$}encryptionStream(){let U=new DU(this.engine,this.chunkSize).toTransformStream();return{writable:U.writable,readable:U.readable}}decryptionStream(U){let $=U,Q=new TransformStream({transform(W,Z){if($===0){Z.enqueue(W);return}if(W.byteLength<=$){$-=W.byteLength;return}Z.enqueue(W.slice($)),$=0}}),J=new MU(this.engine,this.chunkSize).toTransformStream();return{writable:Q.writable,readable:Q.readable.pipeThrough(J)}}async collect(U,$,Q=null){return r0(U.pipeThrough($),Q??void 0)}getEngine(){return this.engine}}function a0(U){try{if(U)U.fill(0)}catch{}}function UJ(U){let $="";for(let Q=0;Q<U.length;Q++){let J=U[Q].toString(16).padStart(2,"0");$+=J}return $}class QU{bytes;destroyed=!1;static from(U){if(U instanceof QU)return U;if(typeof U==="string")return new QU(new TextEncoder().encode(U));if(U instanceof Uint8Array)return new QU(U);throw new TypeError("ConvertibleInput: unsupported input type")}constructor(U){this.bytes=U}toUint8Array(){if(this.destroyed)throw new Error("ConvertibleInput: already cleared");return this.bytes}clear(){if(!this.destroyed)a0(this.bytes),this.bytes=new Uint8Array(0),this.destroyed=!0}}class RU{bytes;destroyed=!1;constructor(U){this.bytes=U}get uint8array(){if(this.destroyed)throw new Error("ConvertibleOutput: already cleared");return this.bytes}get base64(){if(this.destroyed)throw new Error("ConvertibleOutput: already cleared");return IU(this.bytes)}get hex(){if(this.destroyed)throw new Error("ConvertibleOutput: already cleared");return UJ(this.bytes)}get text(){if(this.destroyed)throw new Error("ConvertibleOutput: already cleared");return new TextDecoder().decode(this.bytes)}clear(){if(!this.destroyed)a0(this.bytes),this.bytes=new Uint8Array(0),this.destroyed=!0}toString(){return this.base64}}function t0(U=0,$=console.info){return{level:U,log(Q,J){if(Q<=U)$(`${Q}| ${J}`)}}}function e0(U,$,Q){if($<0||Q<0||$+Q>U)throw new RangeError("read() slice exceeds data bounds")}class Q0{src;#U=null;constructor(U){this.src=U}get length(){if(this.src instanceof Uint8Array)return this.src.byteLength;if(this.src instanceof Blob)return this.src.size;return this.ensureUint8().byteLength}async read(U,$){if(e0(this.length,U,$),this.src instanceof Uint8Array)return this.src.slice(U,U+$);if(this.src instanceof Blob){let Q=await this.src.slice(U,U+$).arrayBuffer();return new Uint8Array(Q)}return this.ensureUint8().slice(U,U+$)}ensureUint8(){if(!this.#U)this.#U=AU(this.src);return this.#U}}var U$=new WeakMap;class qU{static getEngine(U,$){let Q=U$.get(U);if(!Q)Q=new Map,U$.set(U,Q);let J=Q.get($);if(J)return J;let W=c.get($);return J={desc:W,cipher:new W.cipher(U),kdf:W.kdf,chunkSize:W.defaultChunkSize,provider:U},Q.set($,J),J}static async deriveKey(U,$,Q,J){try{let W=await U.kdf.derive($.value,Q,J,U.provider);await U.cipher.setKey(W)}catch(W){let Z=W instanceof Error?W.message:String(W);throw new a(Z)}finally{h($)}}}class WU{provider;v;cipher;kdf;chunkSize;stream;difficulty;saltStrength;engines=new Map;log;constructor(U,$={}){this.provider=U;this.v=c.get($.scheme??c.current.id),this.cipher=new this.v.cipher(U),this.kdf=this.v.kdf,this.chunkSize=this.setChunkSize($.chunkSize??this.v.defaultChunkSize),this.stream=new TU(this.cipher,this.chunkSize),this.difficulty=$.difficulty??"middle",this.saltStrength=$.saltStrength??"high",this.log=t0($.verbose??0,$.logger)}static async isEncrypted(U){try{return await WU.peekHeader(U),!0}catch{return!1}}static async decodeHeader(U){let $=await WU.peekHeader(U),Q=o($);return{scheme:Q.scheme,difficulty:Q.difficulty,salt:IU(Q.salt),saltBytes:Q.salt,saltLength:Q.salt.byteLength}}static async headerDecode(U){return this.decodeHeader(U)}static isRandomAccessSource(U){return typeof U==="object"&&U!==null&&typeof U.read==="function"}static async decodeData(U){let $=WU.isRandomAccessSource(U)?U:new Q0(U),Q=await $.read(0,Math.min(256,$.length)),J=await WU.peekHeader(Q),{scheme:W,headerLen:Z}=o(J),V=$.length,q=V-Z;if(q<=0)throw new d("Payload is empty");let Y=await $.read(Z,4),G=new DataView(Y.buffer,Y.byteOffset,4).getUint32(0,!1);if(G+4<=q&&G>=28){let F=G,I=Z,T=0,M=0;while(I+4<=V){let H=await $.read(I,4),w=new DataView(H.buffer,H.byteOffset,4).getUint32(0,!1);if(w===0||I+4+w>V)break;T++,M+=w,I+=4+w}return{isChunked:!0,chunks:{chunkSize:F,count:T,totalPayload:M}}}let X=await $.read(Z,q),P=c.get(W).cipher.IV_LENGTH,z=c.get(W).cipher.TAG_LENGTH;if(X.length<P+z)throw new d("Ciphertext too short for IV & tag");return{isChunked:!1,payloadLength:q-P-z,params:{iv:X.slice(0,P),ivLength:P,tag:X.slice(X.length-z),tagLength:z}}}setDifficulty(U){this.difficulty=U}getDifficulty(){return this.difficulty}setScheme(U){this.v=c.get(U),this.cipher=new this.v.cipher(this.provider),this.kdf=this.v.kdf,this.stream=new TU(this.cipher,this.chunkSize)}getScheme(){return this.v.id}setSaltDifficulty(U){this.saltStrength=U}getSaltDifficulty(){return this.saltStrength}setChunkSize(U){let Q=U,J;if(Q==null)J=this.v.defaultChunkSize;else{if(J=Number(Q),!Number.isInteger(J)||J<1)throw new Error(`Invalid chunkSize: ${Q}. Must be a positive integer.`);if(J>134217728)throw new RangeError("chunkSize cannot exceed 134217728 bytes.")}if(this.chunkSize=J,this.stream)this.stream=new TU(this.cipher,this.chunkSize);return J}getChunkSize(){return this.chunkSize}setVerbose(U){this.log.level=U}getVerbose(){return this.log.level}async encryptText(U,$){if($===null)throw new n("Password can't be null");let Q={value:$};try{if($==="")this.log.log(0,"Empty passphrase provided to encryptText");this.log.log(1,`Start text encryption, scheme: ${this.getScheme()}`);let J=QU.from(U),W=J.toUint8Array();this.log.log(2,"Deriving key for text encryption");let Z=this.genSalt();await this.deriveKey(Q,Z),h(Q),$=null,this.log.log(3,`Salt generated: ${IU(Z)}, KDF difficulty: ${this.difficulty}`),this.log.log(3,"Encoding header");let V=BU(this.v.id,this.difficulty,this.saltStrength,Z,this.cipher);this.log.log(2,"Encrypting text data");let q=await this.cipher.encryptChunk(W);this.cipher.zeroKey();try{J.clear()}catch{}let Y=zU(V,q);return this.log.log(1,"Encryption finished"),new RU(Y)}catch(J){throw new n(J instanceof Error?J.message:String(J))}}async decryptText(U,$){if($===null)throw new n("Password can't be null");let Q={value:$};try{if($==="")this.log.log(0,"Empty passphrase provided to decryptText");this.log.log(1,`Start text decryption, Version ${this.getScheme()}`);let J;if(typeof U==="string")this.log.log(3,"Decoding Base64 ciphertext"),J=AU(U);else if(U instanceof Uint8Array)J=U;else if(U instanceof QU)J=U.toUint8Array();else throw new FU("Unsupported ciphertext input type");this.log.log(3,"Start header decoding");let W=o(J);this.log.log(3,"Selecting decryption engine");let Z=qU.getEngine(this.provider,W.scheme);this.log.log(2,`Deriving key via engine for scheme: ${W.scheme}`),this.log.log(3,`Salt use: ${IU(W.salt)}, KDF difficulty: ${W.difficulty}`);try{await qU.deriveKey(Z,Q,W.salt,W.difficulty)}finally{h(Q),$=null}this.log.log(2,"Decrypting text data"),o(J,Z.cipher);let V=await Z.cipher.decryptChunk(J.slice(W.headerLen));if(Z.cipher.zeroKey(),U instanceof QU)try{U.clear()}catch{}return this.log.log(1,"Decryption finished"),new RU(V)}catch(J){if(J instanceof u||J instanceof d||J instanceof VU||J instanceof FU||J instanceof a)throw J;throw new u("Decryption failed: wrong passphrase or corrupted ciphertext")}}async encryptFile(U,$){if($===null)throw new n("Password can't be null");let Q={value:$};try{if(U.size===0){let V=this.genSalt();await this.deriveKey(Q,V),h(Q),$=null;let q=BU(this.v.id,this.difficulty,this.saltStrength,V);return new Blob([q],{type:"application/octet-stream"})}this.log.log(2,"Deriving key for file encryption");let J=this.genSalt();await this.deriveKey(Q,J),h(Q),$=null;let W=BU(this.v.id,this.difficulty,this.saltStrength,J,this.stream.getEngine()),Z=await this.stream.collect(U.stream(),new DU(this.cipher,this.chunkSize).toTransformStream(),W);return new Blob([Z],{type:"application/octet-stream"})}catch(J){throw new n(J instanceof Error?J.message:String(J))}}async decryptFile(U,$){if($===null)throw new n("Password can't be null");let Q={value:$};try{let J=await WU.peekHeader(U),W=o(J),Z=qU.getEngine(this.provider,W.scheme);try{await qU.deriveKey(Z,Q,W.salt,W.difficulty)}finally{h(Q),$=null}if(U.size===W.headerLen)return new Blob([],{type:"application/octet-stream"});this.log.log(2,"Decrypting file data");let V=new TU(Z.cipher,Z.chunkSize);o(J,V.getEngine());let q=await V.collect(U.slice(W.headerLen).stream(),new MU(Z.cipher,Z.chunkSize).toTransformStream());return new Blob([q],{type:"application/octet-stream"})}catch(J){if(J instanceof u)throw J;throw new u(J instanceof Error?J.message:String(J))}}async createEncryptionStream(U){if(U===null)throw new n("Password can't be null");let $={value:U};this.log.log(2,"Deriving key for stream encryption");let Q=this.genSalt();await this.deriveKey($,Q),h($),U=null;let J=BU(this.v.id,this.difficulty,this.saltStrength,Q,this.stream.getEngine()),W=this.stream.encryptionStream();return{header:J,writable:W.writable,readable:W.readable}}async createDecryptionStream(U){if(U===null)throw new n("Password can't be null");let $=this.provider,Q={value:U},J=new Uint8Array(0),W=null,Z=65536,V=14,q=async(Y,G)=>{let K=Y.getReader();while(!0){let{value:X,done:P}=await K.read();if(P)break;G.enqueue(X)}};return new TransformStream({transform:async(Y,G)=>{if(!W){if(Y&&Y.byteLength){if(J.byteLength+Y.byteLength>Z){h(Q),G.error(new d(`Header not found within ${Z} bytes`));return}J=zU(J,Y)}if(J.byteLength<V)return;let X=J[1],P=X>>5,z=X>>2&1?"high":"low",F=0;try{F=2+c.get(P).saltLengths[z]}catch(w){h(Q),G.error(new VU(w instanceof Error?w.message:String(w)));return}if(J.byteLength<F)return;let I=J.subarray(0,F),T;try{T=o(I)}catch(w){h(Q),G.error(w instanceof Error?w:new VU("Invalid header"));return}let M=qU.getEngine($,T.scheme);try{await qU.deriveKey(M,Q,T.salt,T.difficulty)}finally{h(Q),U=null}o(I,M.cipher),W=new MU(M.cipher,M.chunkSize).toTransformStream(),q(W.readable,G).catch((w)=>G.error(w));let H=J.subarray(F);if(J=new Uint8Array(0),H.byteLength){let w=W.writable.getWriter();await w.write(H),w.releaseLock()}return}let K=W.writable.getWriter();await K.write(Y),K.releaseLock()},flush:async()=>{if(!W)throw h(Q),new d("Header not found before end of stream");let Y=W.writable.getWriter();await Y.close(),Y.releaseLock()}})}async deriveKey(U,$,Q=this.difficulty){let J=performance.now();try{let W=await this.kdf.derive(U.value,$,Q,this.provider);h(U),await this.cipher.setKey(W),this.log.log(3,`Key derivation completed in ${(performance.now()-J).toFixed(1)} ms`)}catch(W){throw new a(W instanceof Error?W.message:String(W))}}genSalt(U=this.saltStrength){let $=this.v.saltLengths[U];return this.provider.getRandomValues(new Uint8Array($))}static async peekHeader(U){let $=await this.readAsUint8(U);if($ instanceof Uint8Array){if($.length<2)throw new d("Input too short");let{headerLen:Q}=o($.length>=16?$:Uint8Array.from($));if($.length<Q)throw new d("Incomplete header");return $.slice(0,Q)}throw new VU("Unsupported input type")}static async readAsUint8(U){if(typeof U==="string")return AU(U);if(U instanceof Blob){let $=U.slice(0,64);return new Uint8Array(await $.arrayBuffer())}return U}}import{webcrypto as $J,randomFillSync as JJ}from"node:crypto";var $$={subtle:$J.subtle,getRandomValues(U){return JJ(U),U},isNode:!0};function lQ(U){return new WU($$,U)}export{lQ as createCryptit,WU as Cryptit,RU as ConvertibleOutput,QU as ConvertibleInput};

//# debugId=44519819E746321B64756E2164756E21
