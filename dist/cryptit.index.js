import{createRequire as Q$}from"node:module";var e0=Object.create;var{getPrototypeOf:U$,defineProperty:J0,getOwnPropertyNames:$$}=Object;var J$=Object.prototype.hasOwnProperty;var cU=(U,$,Q)=>{Q=U!=null?e0(U$(U)):{};let J=$||!U||!U.__esModule?J0(Q,"default",{value:U,enumerable:!0}):Q;for(let W of $$(U))if(!J$.call(J,W))J0(J,W,{get:()=>U[W],enumerable:!0});return J};var BU=(U,$)=>()=>($||U(($={exports:{}}).exports,$),$.exports);var d=Q$(import.meta.url);var H0=BU((TJ,T0)=>{var _U=/^[a-z0-9-]{1,32}$/,mU=/^[a-z0-9-]{1,32}$/,kU=/^[a-zA-Z0-9/+.-]+$/,M0=/^([a-zA-Z0-9/+.-]+|)$/,T$=/^((-)?[1-9]\d*|0)$/,hU=/^v=(\d+)$/;function H$(U){return zU(U).map(($)=>[$,U[$]].join("=")).join(",")}function S$(U){let $={};return U.split(",").forEach((Q)=>{let J=Q.split("=");if(J.length<2)throw new TypeError("params must be in the format name=value");$[J.shift()]=J.join("=")}),$}function zU(U){return Object.keys(U)}function w0(U){if(typeof Object.values==="function")return Object.values(U);return zU(U).map(($)=>U[$])}function A$(U){let $=[""];if(typeof U!=="object"||U===null)throw new TypeError("opts must be an object");if(typeof U.id!=="string")throw new TypeError("id must be a string");if(!_U.test(U.id))throw new TypeError(`id must satisfy ${_U}`);if($.push(U.id),typeof U.version!=="undefined"){if(typeof U.version!=="number"||U.version<0||!Number.isInteger(U.version))throw new TypeError("version must be a positive integer number");$.push(`v=${U.version}`)}if(typeof U.params!=="undefined"){if(typeof U.params!=="object"||U.params===null)throw new TypeError("params must be an object");let J=zU(U.params);if(!J.every((Z)=>mU.test(Z)))throw new TypeError(`params names must satisfy ${mU}`);J.forEach((Z)=>{if(typeof U.params[Z]==="number")U.params[Z]=U.params[Z].toString();else if(Buffer.isBuffer(U.params[Z]))U.params[Z]=U.params[Z].toString("base64").split("=")[0]});let W=w0(U.params);if(!W.every((Z)=>typeof Z==="string"))throw new TypeError("params values must be strings");if(!W.every((Z)=>kU.test(Z)))throw new TypeError(`params values must satisfy ${kU}`);let V=H$(U.params);$.push(V)}if(typeof U.salt!=="undefined"){if(!Buffer.isBuffer(U.salt))throw new TypeError("salt must be a Buffer");if($.push(U.salt.toString("base64").split("=")[0]),typeof U.hash!=="undefined"){if(!Buffer.isBuffer(U.hash))throw new TypeError("hash must be a Buffer");$.push(U.hash.toString("base64").split("=")[0])}}return $.join("$")}function B$(U){if(typeof U!=="string"||U==="")throw new TypeError("pchstr must be a non-empty string");if(U[0]!=="$")throw new TypeError("pchstr must contain a $ as first char");let $=U.split("$");$.shift();let Q=5;if(!hU.test($[1]))Q--;if($.length>Q)throw new TypeError(`pchstr contains too many fileds: ${$.length}/${Q}`);let J=$.shift();if(!_U.test(J))throw new TypeError(`id must satisfy ${_U}`);let W;if(hU.test($[0]))W=parseInt($.shift().match(hU)[1],10);let V,Z;if(M0.test($[$.length-1]))if($.length>1&&M0.test($[$.length-2]))V=Buffer.from($.pop(),"base64"),Z=Buffer.from($.pop(),"base64");else Z=Buffer.from($.pop(),"base64");let Y;if($.length>0){let G=$.pop();if(Y=S$(G),!zU(Y).every((O)=>mU.test(O)))throw new TypeError(`params names must satisfy ${mU}`);if(!w0(Y).every((O)=>kU.test(O)))throw new TypeError(`params values must satisfy ${kU}`);zU(Y).forEach((O)=>{Y[O]=T$.test(Y[O])?parseInt(Y[O],10):Y[O]})}if($.length>0)throw new TypeError(`pchstr contains unrecognized fileds: ${$}`);let q={id:J};if(W)q.version=W;if(Y)q.params=Y;if(Z)q.salt=Z;if(V)q.hash=V;return q}T0.exports={serialize:A$,deserialize:B$}});var g0=BU((HJ,y0)=>{var D0=d("fs"),UU=d("path"),R0=d("os"),j0=typeof __webpack_require__==="function"?__non_webpack_require__:d,D$=process.config&&process.config.variables||{},R$=!!process.env.PREBUILDS_ONLY,S0=process.versions.modules,iU=C$()?"electron":L$()?"node-webkit":"node",oU=process.env.npm_config_arch||R0.arch(),sU=process.env.npm_config_platform||R0.platform(),L0=process.env.LIBC||(v$(sU)?"musl":"glibc"),rU=process.env.ARM_VERSION||(oU==="arm64"?"8":D$.arm_version)||"",C0=(process.versions.uv||"").split(".")[0];y0.exports=h;function h(U){return j0(h.resolve(U))}h.resolve=h.path=function(U){U=UU.resolve(U||".");try{var $=j0(UU.join(U,"package.json")).name.toUpperCase().replace(/-/g,"_");if(process.env[$+"_PREBUILD"])U=process.env[$+"_PREBUILD"]}catch(q){}if(!R$){var Q=A0(UU.join(U,"build/Release"),B0);if(Q)return Q;var J=A0(UU.join(U,"build/Debug"),B0);if(J)return J}var W=Y(U);if(W)return W;var V=Y(UU.dirname(process.execPath));if(V)return V;var Z=["platform="+sU,"arch="+oU,"runtime="+iU,"abi="+S0,"uv="+C0,rU?"armv="+rU:"","libc="+L0,"node="+process.versions.node,process.versions.electron?"electron="+process.versions.electron:"",typeof __webpack_require__==="function"?"webpack=true":""].filter(Boolean).join(" ");throw new Error("No native build was found for "+Z+`
    loaded from: `+U+`
`);function Y(q){var G=aU(UU.join(q,"prebuilds")).map(v0),K=G.filter(E0(sU,oU)).sort(_0)[0];if(!K)return;var X=UU.join(q,"prebuilds",K.name),O=aU(X).map(m0),F=O.filter(k0(iU,S0)),P=F.sort(b0(iU))[0];if(P)return UU.join(X,P.file)}};function aU(U){try{return D0.readdirSync(U)}catch($){return[]}}function A0(U,$){var Q=aU(U).filter($);return Q[0]&&UU.join(U,Q[0])}function B0(U){return/\.node$/.test(U)}function v0(U){var $=U.split("-");if($.length!==2)return;var Q=$[0],J=$[1].split("+");if(!Q)return;if(!J.length)return;if(!J.every(Boolean))return;return{name:U,platform:Q,architectures:J}}function E0(U,$){return function(Q){if(Q==null)return!1;if(Q.platform!==U)return!1;return Q.architectures.includes($)}}function _0(U,$){return U.architectures.length-$.architectures.length}function m0(U){var $=U.split("."),Q=$.pop(),J={file:U,specificity:0};if(Q!=="node")return;for(var W=0;W<$.length;W++){var V=$[W];if(V==="node"||V==="electron"||V==="node-webkit")J.runtime=V;else if(V==="napi")J.napi=!0;else if(V.slice(0,3)==="abi")J.abi=V.slice(3);else if(V.slice(0,2)==="uv")J.uv=V.slice(2);else if(V.slice(0,4)==="armv")J.armv=V.slice(4);else if(V==="glibc"||V==="musl")J.libc=V;else continue;J.specificity++}return J}function k0(U,$){return function(Q){if(Q==null)return!1;if(Q.runtime&&Q.runtime!==U&&!j$(Q))return!1;if(Q.abi&&Q.abi!==$&&!Q.napi)return!1;if(Q.uv&&Q.uv!==C0)return!1;if(Q.armv&&Q.armv!==rU)return!1;if(Q.libc&&Q.libc!==L0)return!1;return!0}}function j$(U){return U.runtime==="node"&&U.napi}function b0(U){return function($,Q){if($.runtime!==Q.runtime)return $.runtime===U?-1:1;else if($.abi!==Q.abi)return $.abi?-1:1;else if($.specificity!==Q.specificity)return $.specificity>Q.specificity?-1:1;else return 0}}function L$(){return!!(process.versions&&process.versions.nw)}function C$(){if(process.versions&&process.versions.electron)return!0;if(process.env.ELECTRON_RUN_AS_NODE)return!0;return typeof window!=="undefined"&&window.process&&window.process.type==="renderer"}function v$(U){return U==="linux"&&D0.existsSync("/etc/alpine-release")}h.parseTags=m0;h.matchTags=k0;h.compareTags=b0;h.parseTuple=v0;h.matchTuple=E0;h.compareTuples=_0});var f0=BU((AJ,eU)=>{var tU=typeof __webpack_require__==="function"?__non_webpack_require__:d;if(typeof tU.addon==="function")eU.exports=tU.addon.bind(tU);else eU.exports=g0()});var x0=BU((l$,VU)=>{var __dirname="/Users/maxim/Projects/Private/Sites/cryptit/node_modules/argon2",DJ=d("node:assert"),{randomBytes:E$,timingSafeEqual:_$}=d("node:crypto"),{promisify:m$}=d("node:util"),{deserialize:c0,serialize:k$}=H0(),b$=f0(),{hash:u0}=b$(__dirname),y$=m$(E$);l$.argon2d=0;l$.argon2i=1;l$.argon2id=2;var MU=Object.freeze({argon2d:0,argon2i:1,argon2id:2}),g$=Object.freeze({[MU.argon2d]:"argon2d",[MU.argon2i]:"argon2i",[MU.argon2id]:"argon2id"}),l0={hashLength:32,timeCost:3,memoryCost:65536,parallelism:4,type:2,version:19};async function f$(U,$){let{raw:Q,salt:J,...W}={...l0,...$};if(W.hashLength>4294967295)throw new RangeError("Hash length is too large");if(W.memoryCost>4294967295)throw new RangeError("Memory cost is too large");if(W.timeCost>4294967295)throw new RangeError("Time cost is too large");if(W.parallelism>16777215)throw new RangeError("Parallelism is too large");J=J??await y$(16);let{hashLength:V,secret:Z=Buffer.alloc(0),type:Y,version:q,memoryCost:G,timeCost:K,parallelism:X,associatedData:O=Buffer.alloc(0)}=W,F=await u0({password:Buffer.from(U),salt:J,secret:Z,data:O,hashLength:V,m:G,t:K,p:X,version:q,type:Y});if(Q)return F;return k$({id:g$[Y],version:q,params:{m:G,t:K,p:X,...O.byteLength>0?{data:O}:{}},salt:J,hash:F})}l$.hash=f$;function c$(U,$={}){let{memoryCost:Q,timeCost:J,parallelism:W,version:V}={...l0,...$},{version:Z,params:{m:Y,t:q,p:G}}=c0(U);return+Z!==+V||+Y!==+Q||+q!==+J||+G!==+W}l$.needsRehash=c$;async function u$(U,$,Q={}){let{id:J,...W}=c0(U);if(!(J in MU))return!1;let{version:V=16,params:{m:Z,t:Y,p:q,data:G=""},salt:K,hash:X}=W,{secret:O=Buffer.alloc(0)}=Q;return _$(await u0({password:Buffer.from($),salt:K,secret:O,data:Buffer.from(G,"base64"),hashLength:X.byteLength,m:+Z,t:+Y,p:+q,version:+V,type:MU[J]}),X)}l$.verify=u$});class s extends Error{constructor(U){super(U);Object.setPrototypeOf(this,new.target.prototype),this.name=new.target.name,this.stack=void 0}}class n extends s{}class PU extends s{}class uU extends s{}class DU extends s{}class QU extends s{}class r extends s{}class RU extends s{}class x extends s{}class u{static byId=new Map;static register(U){if(this.byId.has(U.id))throw new DU(`Scheme ${U.id} already registered`);this.byId.set(U.id,U)}static get(U){let $=this.byId.get(U);if(!$)throw new DU(`Unknown scheme: ${U}`);return $}static get current(){return this.get(0)}}class WU{p;static IV_LENGTH=12;static TAG_LENGTH=16;IV_LENGTH=WU.IV_LENGTH;TAG_LENGTH=WU.TAG_LENGTH;key;aad=new Uint8Array(0);constructor(U){this.p=U}async setKey(U){this.key=U}async encryptChunk(U){let $=this.p.getRandomValues(new Uint8Array(WU.IV_LENGTH)),Q=this.aad.length?{name:"AES-GCM",iv:$,additionalData:this.aad}:{name:"AES-GCM",iv:$},J=await this.p.subtle.encrypt(Q,this.requireKey(),U),W=new Uint8Array(J);U.fill(0);let V=new Uint8Array($.length+W.length);return V.set($,0),V.set(W,$.length),V}async decryptChunk(U){let $=U.slice(0,WU.IV_LENGTH),Q=U.slice(WU.IV_LENGTH),J=this.aad.length?{name:"AES-GCM",iv:$,additionalData:this.aad}:{name:"AES-GCM",iv:$};try{let W=await this.p.subtle.decrypt(J,this.requireKey(),Q);return new Uint8Array(W)}catch{throw new x("Decryption failed: wrong passphrase or corrupted ciphertext")}}zeroKey(){this.key=null}setAAD(U){this.aad=U&&U.byteLength?new Uint8Array(U):new Uint8Array(0)}requireKey(){if(!this.key)throw new Error("Encryption key not set");return this.key}}/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function W0(U){return U instanceof Uint8Array||ArrayBuffer.isView(U)&&U.constructor.name==="Uint8Array"}function jU(U){if(typeof U!=="boolean")throw new Error(`boolean expected, not ${U}`)}function LU(U){if(!Number.isSafeInteger(U)||U<0)throw new Error("positive integer expected, got "+U)}function l(U,...$){if(!W0(U))throw new Error("Uint8Array expected");if($.length>0&&!$.includes(U.length))throw new Error("Uint8Array expected of length "+$+", got length="+U.length)}function lU(U,$=!0){if(U.destroyed)throw new Error("Hash instance has been destroyed");if($&&U.finished)throw new Error("Hash#digest() has already been called")}function Z0(U,$){l(U);let Q=$.outputLen;if(U.length<Q)throw new Error("digestInto() expects output buffer of length at least "+Q)}function a(U){return new Uint32Array(U.buffer,U.byteOffset,Math.floor(U.byteLength/4))}function t(...U){for(let $=0;$<U.length;$++)U[$].fill(0)}function W$(U){return new DataView(U.buffer,U.byteOffset,U.byteLength)}var Z$=(()=>new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68)();function V$(U){if(typeof U!=="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(U))}function CU(U){if(typeof U==="string")U=V$(U);else if(W0(U))U=vU(U);else throw new Error("Uint8Array expected, got "+typeof U);return U}function V0(U,$){if($==null||typeof $!=="object")throw new Error("options must be defined");return Object.assign(U,$)}function Y0(U,$){if(U.length!==$.length)return!1;let Q=0;for(let J=0;J<U.length;J++)Q|=U[J]^$[J];return Q===0}var xU=(U,$)=>{function Q(J,...W){if(l(J),!Z$)throw new Error("Non little-endian hardware is not yet supported");if(U.nonceLength!==void 0){let K=W[0];if(!K)throw new Error("nonce / iv required");if(U.varSizeNonce)l(K);else l(K,U.nonceLength)}let V=U.tagLength;if(V&&W[1]!==void 0)l(W[1]);let Z=$(J,...W),Y=(K,X)=>{if(X!==void 0){if(K!==2)throw new Error("cipher output not supported");l(X)}},q=!1;return{encrypt(K,X){if(q)throw new Error("cannot encrypt() twice with same key + nonce");return q=!0,l(K),Y(Z.encrypt.length,X),Z.encrypt(K,X)},decrypt(K,X){if(l(K),V&&K.length<V)throw new Error("invalid ciphertext length: smaller than tagLength="+V);return Y(Z.decrypt.length,X),Z.decrypt(K,X)}}}return Object.assign(Q,U),Q};function pU(U,$,Q=!0){if($===void 0)return new Uint8Array(U);if($.length!==U)throw new Error("invalid output length, expected "+U+", got: "+$.length);if(Q&&!Y$($))throw new Error("invalid output, must be aligned");return $}function Q0(U,$,Q,J){if(typeof U.setBigUint64==="function")return U.setBigUint64($,Q,J);let W=BigInt(32),V=BigInt(4294967295),Z=Number(Q>>W&V),Y=Number(Q&V),q=J?4:0,G=J?0:4;U.setUint32($+q,Z,J),U.setUint32($+G,Y,J)}function q0(U,$,Q){jU(Q);let J=new Uint8Array(16),W=W$(J);return Q0(W,0,BigInt($),Q),Q0(W,8,BigInt(U),Q),J}function Y$(U){return U.byteOffset%4===0}function vU(U){return Uint8Array.from(U)}var K0=(U)=>Uint8Array.from(U.split("").map(($)=>$.charCodeAt(0))),q$=K0("expand 16-byte k"),G$=K0("expand 32-byte k"),K$=a(q$),N$=a(G$);function N(U,$){return U<<$|U>>>32-$}function nU(U){return U.byteOffset%4===0}var EU=64,X$=16,N0=4294967295,G0=new Uint32Array;function O$(U,$,Q,J,W,V,Z,Y){let q=W.length,G=new Uint8Array(EU),K=a(G),X=nU(W)&&nU(V),O=X?a(W):G0,F=X?a(V):G0;for(let P=0;P<q;Z++){if(U($,Q,J,K,Z,Y),Z>=N0)throw new Error("arx: counter overflow");let z=Math.min(EU,q-P);if(X&&z===EU){let w=P/4;if(P%4!==0)throw new Error("arx: invalid block position");for(let M=0,H;M<X$;M++)H=w+M,F[H]=O[H]^K[M];P+=EU;continue}for(let w=0,M;w<z;w++)M=P+w,V[M]=W[M]^G[w];P+=z}}function dU(U,$){let{allowShortKeys:Q,extendNonceFn:J,counterLength:W,counterRight:V,rounds:Z}=V0({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},$);if(typeof U!=="function")throw new Error("core must be a function");return LU(W),LU(Z),jU(V),jU(Q),(Y,q,G,K,X=0)=>{l(Y),l(q),l(G);let O=G.length;if(K===void 0)K=new Uint8Array(O);if(l(K),LU(X),X<0||X>=N0)throw new Error("arx: counter overflow");if(K.length<O)throw new Error(`arx: output (${K.length}) is shorter than data (${O})`);let F=[],P=Y.length,z,w;if(P===32)F.push(z=vU(Y)),w=N$;else if(P===16&&Q)z=new Uint8Array(32),z.set(Y),z.set(Y,16),w=K$,F.push(z);else throw new Error(`arx: invalid 32-byte key, got length=${P}`);if(!nU(q))F.push(q=vU(q));let M=a(z);if(J){if(q.length!==24)throw new Error("arx: extended nonce must be 24 bytes");J(w,M,a(q.subarray(0,16)),M),q=q.subarray(16)}let H=16-W;if(H!==q.length)throw new Error(`arx: nonce must be ${H} or 16 bytes`);if(H!==12){let y=new Uint8Array(12);y.set(q,V?0:12-q.length),q=y,F.push(q)}let T=a(q);return O$(U,w,M,T,G,K,X,Z),t(...F),K}}var g=(U,$)=>U[$++]&255|(U[$++]&255)<<8;class X0{constructor(U){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,U=CU(U),l(U,32);let $=g(U,0),Q=g(U,2),J=g(U,4),W=g(U,6),V=g(U,8),Z=g(U,10),Y=g(U,12),q=g(U,14);this.r[0]=$&8191,this.r[1]=($>>>13|Q<<3)&8191,this.r[2]=(Q>>>10|J<<6)&7939,this.r[3]=(J>>>7|W<<9)&8191,this.r[4]=(W>>>4|V<<12)&255,this.r[5]=V>>>1&8190,this.r[6]=(V>>>14|Z<<2)&8191,this.r[7]=(Z>>>11|Y<<5)&8065,this.r[8]=(Y>>>8|q<<8)&8191,this.r[9]=q>>>5&127;for(let G=0;G<8;G++)this.pad[G]=g(U,16+2*G)}process(U,$,Q=!1){let J=Q?0:2048,{h:W,r:V}=this,Z=V[0],Y=V[1],q=V[2],G=V[3],K=V[4],X=V[5],O=V[6],F=V[7],P=V[8],z=V[9],w=g(U,$+0),M=g(U,$+2),H=g(U,$+4),T=g(U,$+6),y=g(U,$+8),JU=g(U,$+10),f=g(U,$+12),c=g(U,$+14),S=W[0]+(w&8191),A=W[1]+((w>>>13|M<<3)&8191),B=W[2]+((M>>>10|H<<6)&8191),D=W[3]+((H>>>7|T<<9)&8191),R=W[4]+((T>>>4|y<<12)&8191),j=W[5]+(y>>>1&8191),L=W[6]+((y>>>14|JU<<2)&8191),C=W[7]+((JU>>>11|f<<5)&8191),v=W[8]+((f>>>8|c<<8)&8191),E=W[9]+(c>>>5|J),I=0,m=I+S*Z+A*(5*z)+B*(5*P)+D*(5*F)+R*(5*O);I=m>>>13,m&=8191,m+=j*(5*X)+L*(5*K)+C*(5*G)+v*(5*q)+E*(5*Y),I+=m>>>13,m&=8191;let k=I+S*Y+A*Z+B*(5*z)+D*(5*P)+R*(5*F);I=k>>>13,k&=8191,k+=j*(5*O)+L*(5*X)+C*(5*K)+v*(5*G)+E*(5*q),I+=k>>>13,k&=8191;let b=I+S*q+A*Y+B*Z+D*(5*z)+R*(5*P);I=b>>>13,b&=8191,b+=j*(5*F)+L*(5*O)+C*(5*X)+v*(5*K)+E*(5*G),I+=b>>>13,b&=8191;let _=I+S*G+A*q+B*Y+D*Z+R*(5*z);I=_>>>13,_&=8191,_+=j*(5*P)+L*(5*F)+C*(5*O)+v*(5*X)+E*(5*K),I+=_>>>13,_&=8191;let o=I+S*K+A*G+B*q+D*Y+R*Z;I=o>>>13,o&=8191,o+=j*(5*z)+L*(5*P)+C*(5*F)+v*(5*O)+E*(5*X),I+=o>>>13,o&=8191;let qU=I+S*X+A*K+B*G+D*q+R*Y;I=qU>>>13,qU&=8191,qU+=j*Z+L*(5*z)+C*(5*P)+v*(5*F)+E*(5*O),I+=qU>>>13,qU&=8191;let GU=I+S*O+A*X+B*K+D*G+R*q;I=GU>>>13,GU&=8191,GU+=j*Y+L*Z+C*(5*z)+v*(5*P)+E*(5*F),I+=GU>>>13,GU&=8191;let KU=I+S*F+A*O+B*X+D*K+R*G;I=KU>>>13,KU&=8191,KU+=j*q+L*Y+C*Z+v*(5*z)+E*(5*P),I+=KU>>>13,KU&=8191;let NU=I+S*P+A*F+B*O+D*X+R*K;I=NU>>>13,NU&=8191,NU+=j*G+L*q+C*Y+v*Z+E*(5*z),I+=NU>>>13,NU&=8191;let XU=I+S*z+A*P+B*F+D*O+R*X;I=XU>>>13,XU&=8191,XU+=j*K+L*G+C*q+v*Y+E*Z,I+=XU>>>13,XU&=8191,I=(I<<2)+I|0,I=I+m|0,m=I&8191,I=I>>>13,k+=I,W[0]=m,W[1]=k,W[2]=b,W[3]=_,W[4]=o,W[5]=qU,W[6]=GU,W[7]=KU,W[8]=NU,W[9]=XU}finalize(){let{h:U,pad:$}=this,Q=new Uint16Array(10),J=U[1]>>>13;U[1]&=8191;for(let Z=2;Z<10;Z++)U[Z]+=J,J=U[Z]>>>13,U[Z]&=8191;U[0]+=J*5,J=U[0]>>>13,U[0]&=8191,U[1]+=J,J=U[1]>>>13,U[1]&=8191,U[2]+=J,Q[0]=U[0]+5,J=Q[0]>>>13,Q[0]&=8191;for(let Z=1;Z<10;Z++)Q[Z]=U[Z]+J,J=Q[Z]>>>13,Q[Z]&=8191;Q[9]-=8192;let W=(J^1)-1;for(let Z=0;Z<10;Z++)Q[Z]&=W;W=~W;for(let Z=0;Z<10;Z++)U[Z]=U[Z]&W|Q[Z];U[0]=(U[0]|U[1]<<13)&65535,U[1]=(U[1]>>>3|U[2]<<10)&65535,U[2]=(U[2]>>>6|U[3]<<7)&65535,U[3]=(U[3]>>>9|U[4]<<4)&65535,U[4]=(U[4]>>>12|U[5]<<1|U[6]<<14)&65535,U[5]=(U[6]>>>2|U[7]<<11)&65535,U[6]=(U[7]>>>5|U[8]<<8)&65535,U[7]=(U[8]>>>8|U[9]<<5)&65535;let V=U[0]+$[0];U[0]=V&65535;for(let Z=1;Z<8;Z++)V=(U[Z]+$[Z]|0)+(V>>>16)|0,U[Z]=V&65535;t(Q)}update(U){lU(this),U=CU(U),l(U);let{buffer:$,blockLen:Q}=this,J=U.length;for(let W=0;W<J;){let V=Math.min(Q-this.pos,J-W);if(V===Q){for(;Q<=J-W;W+=Q)this.process(U,W);continue}if($.set(U.subarray(W,W+V),this.pos),this.pos+=V,W+=V,this.pos===Q)this.process($,0,!1),this.pos=0}return this}destroy(){t(this.h,this.r,this.buffer,this.pad)}digestInto(U){lU(this),Z0(U,this),this.finished=!0;let{buffer:$,h:Q}=this,{pos:J}=this;if(J){$[J++]=1;for(;J<16;J++)$[J]=0;this.process($,0,!0)}this.finalize();let W=0;for(let V=0;V<8;V++)U[W++]=Q[V]>>>0,U[W++]=Q[V]>>>8;return U}digest(){let{buffer:U,outputLen:$}=this;this.digestInto(U);let Q=U.slice(0,$);return this.destroy(),Q}}function I$(U){let $=(J,W)=>U(W).update(CU(J)).digest(),Q=U(new Uint8Array(32));return $.outputLen=Q.outputLen,$.blockLen=Q.blockLen,$.create=(J)=>U(J),$}var O0=I$((U)=>new X0(U));function F0(U,$,Q,J,W,V=20){let Z=U[0],Y=U[1],q=U[2],G=U[3],K=$[0],X=$[1],O=$[2],F=$[3],P=$[4],z=$[5],w=$[6],M=$[7],H=W,T=Q[0],y=Q[1],JU=Q[2],f=Z,c=Y,S=q,A=G,B=K,D=X,R=O,j=F,L=P,C=z,v=w,E=M,I=H,m=T,k=y,b=JU;for(let o=0;o<V;o+=2)f=f+B|0,I=N(I^f,16),L=L+I|0,B=N(B^L,12),f=f+B|0,I=N(I^f,8),L=L+I|0,B=N(B^L,7),c=c+D|0,m=N(m^c,16),C=C+m|0,D=N(D^C,12),c=c+D|0,m=N(m^c,8),C=C+m|0,D=N(D^C,7),S=S+R|0,k=N(k^S,16),v=v+k|0,R=N(R^v,12),S=S+R|0,k=N(k^S,8),v=v+k|0,R=N(R^v,7),A=A+j|0,b=N(b^A,16),E=E+b|0,j=N(j^E,12),A=A+j|0,b=N(b^A,8),E=E+b|0,j=N(j^E,7),f=f+D|0,b=N(b^f,16),v=v+b|0,D=N(D^v,12),f=f+D|0,b=N(b^f,8),v=v+b|0,D=N(D^v,7),c=c+R|0,I=N(I^c,16),E=E+I|0,R=N(R^E,12),c=c+R|0,I=N(I^c,8),E=E+I|0,R=N(R^E,7),S=S+j|0,m=N(m^S,16),L=L+m|0,j=N(j^L,12),S=S+j|0,m=N(m^S,8),L=L+m|0,j=N(j^L,7),A=A+B|0,k=N(k^A,16),C=C+k|0,B=N(B^C,12),A=A+B|0,k=N(k^A,8),C=C+k|0,B=N(B^C,7);let _=0;J[_++]=Z+f|0,J[_++]=Y+c|0,J[_++]=q+S|0,J[_++]=G+A|0,J[_++]=K+B|0,J[_++]=X+D|0,J[_++]=O+R|0,J[_++]=F+j|0,J[_++]=P+L|0,J[_++]=z+C|0,J[_++]=w+v|0,J[_++]=M+E|0,J[_++]=H+I|0,J[_++]=T+m|0,J[_++]=y+k|0,J[_++]=JU+b|0}function P$(U,$,Q,J){let W=U[0],V=U[1],Z=U[2],Y=U[3],q=$[0],G=$[1],K=$[2],X=$[3],O=$[4],F=$[5],P=$[6],z=$[7],w=Q[0],M=Q[1],H=Q[2],T=Q[3];for(let JU=0;JU<20;JU+=2)W=W+q|0,w=N(w^W,16),O=O+w|0,q=N(q^O,12),W=W+q|0,w=N(w^W,8),O=O+w|0,q=N(q^O,7),V=V+G|0,M=N(M^V,16),F=F+M|0,G=N(G^F,12),V=V+G|0,M=N(M^V,8),F=F+M|0,G=N(G^F,7),Z=Z+K|0,H=N(H^Z,16),P=P+H|0,K=N(K^P,12),Z=Z+K|0,H=N(H^Z,8),P=P+H|0,K=N(K^P,7),Y=Y+X|0,T=N(T^Y,16),z=z+T|0,X=N(X^z,12),Y=Y+X|0,T=N(T^Y,8),z=z+T|0,X=N(X^z,7),W=W+G|0,T=N(T^W,16),P=P+T|0,G=N(G^P,12),W=W+G|0,T=N(T^W,8),P=P+T|0,G=N(G^P,7),V=V+K|0,w=N(w^V,16),z=z+w|0,K=N(K^z,12),V=V+K|0,w=N(w^V,8),z=z+w|0,K=N(K^z,7),Z=Z+X|0,M=N(M^Z,16),O=O+M|0,X=N(X^O,12),Z=Z+X|0,M=N(M^Z,8),O=O+M|0,X=N(X^O,7),Y=Y+q|0,H=N(H^Y,16),F=F+H|0,q=N(q^F,12),Y=Y+q|0,H=N(H^Y,8),F=F+H|0,q=N(q^F,7);let y=0;J[y++]=W,J[y++]=V,J[y++]=Z,J[y++]=Y,J[y++]=w,J[y++]=M,J[y++]=H,J[y++]=T}var F$=dU(F0,{counterRight:!1,counterLength:4,allowShortKeys:!1}),z$=dU(F0,{counterRight:!1,counterLength:8,extendNonceFn:P$,allowShortKeys:!1});var M$=new Uint8Array(16),I0=(U,$)=>{U.update($);let Q=$.length%16;if(Q)U.update(M$.subarray(Q))},w$=new Uint8Array(32);function P0(U,$,Q,J,W){let V=U($,Q,w$),Z=O0.create(V);if(W)I0(Z,W);I0(Z,J);let Y=q0(J.length,W?W.length:0,!0);Z.update(Y);let q=Z.digest();return t(V,Y),q}var z0=(U)=>($,Q,J)=>{return{encrypt(V,Z){let Y=V.length;Z=pU(Y+16,Z,!1),Z.set(V);let q=Z.subarray(0,-16);U($,Q,q,q,1);let G=P0(U,$,Q,q,J);return Z.set(G,Y),t(G),Z},decrypt(V,Z){Z=pU(V.length-16,Z,!1);let Y=V.subarray(0,-16),q=V.subarray(-16),G=P0(U,$,Q,Y,J);if(!Y0(q,G))throw new Error("invalid tag");return Z.set(V.subarray(0,-16)),U($,Q,Z,Z,1),t(G),Z}}},PJ=xU({blockSize:64,nonceLength:12,tagLength:16},z0(F$)),FU=xU({blockSize:64,nonceLength:24,tagLength:16},z0(z$));class e{p;static IV_LENGTH=24;static TAG_LENGTH=16;IV_LENGTH=e.IV_LENGTH;TAG_LENGTH=e.TAG_LENGTH;key;aad=new Uint8Array(0);constructor(U){this.p=U}async setKey(U){this.key=new Uint8Array(await this.p.subtle.exportKey("raw",U))}async encryptChunk(U){if(!this.key)throw new Error("Key not set");let $=this.p.getRandomValues(new Uint8Array(e.IV_LENGTH)),J=(this.aad.length?FU(this.key,$,this.aad):FU(this.key,$)).encrypt(U);U.fill(0);let W=new Uint8Array($.length+J.length);return W.set($,0),W.set(J,$.length),W}async decryptChunk(U){if(!this.key)throw new Error("Key not set");if(U.byteLength<e.IV_LENGTH+16)throw new x("Invalid ciphertext: too short.");let $=U.slice(0,e.IV_LENGTH),Q=U.slice(e.IV_LENGTH),J=this.aad.length?FU(this.key,$,this.aad):FU(this.key,$);try{return J.decrypt(Q)}catch{throw new x("Decryption failed: wrong passphrase or corrupted ciphertext")}}zeroKey(){if(this.key)this.key.fill(0)}setAAD(U){this.aad=U&&U.byteLength?new Uint8Array(U):new Uint8Array(0)}}import*as bU from"argon2-browser";async function o$(){if(typeof window!=="undefined")return;if(globalThis.loadArgon2WasmModule)return;try{let{createRequire:U}=await import("node:module"),{readFile:$}=await import("node:fs/promises"),Q=U(import.meta.url),J=Q.resolve("argon2-browser/dist/argon2.js"),W=Q.resolve("argon2-browser/dist/argon2.wasm");globalThis.loadArgon2WasmModule=async()=>{let V=new Uint8Array(await $(W));return globalThis.Module={wasmBinary:V,locateFile:(Z)=>Z==="argon2.wasm"?W:Z},Q(J)}}catch{}}async function p0(U,$,Q,J){if(J==="node"){let W=await Promise.resolve().then(() => cU(x0(),1)),V=typeof U==="string"?Buffer.from(U,"utf8"):Buffer.from(U),Z=Buffer.from($),Y=await W.hash(V,{salt:Z,timeCost:Q.time,memoryCost:Q.mem,parallelism:Q.parallelism,hashLength:32,raw:!0,type:W.argon2id});return Z.fill(0),V.fill(0),{hash:new Uint8Array(Y)}}if(J==="browser")return await o$(),bU.hash({pass:U,salt:$,time:Q.time,mem:Q.mem,parallelism:Q.parallelism,hashLen:32,type:bU.ArgonType.Argon2id}).then((W)=>{if(!W||!W.hash)throw new r("Failed to produce key derivation");return{hash:W.hash}}).catch((W)=>{let V=W instanceof Error?W.message:typeof W==="string"?W:"Unknown error";throw new r(`argon2-browser failure: ${V}`)});throw new Error(`Unsupported environment: ${J}`)}class yU{presets;exportExtractable;name="argon2id";constructor(U,$=!1){this.presets=U;this.exportExtractable=$}async derive(U,$,Q,J){let{hash:W}=await p0(U,$,this.presets[Q],J.isNode?"node":"browser");if(this.exportExtractable)return J.subtle.importKey("raw",W,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]);else return J.subtle.importKey("raw",W,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}}var n0={low:{time:5,mem:65536,parallelism:1},middle:{time:20,mem:65536,parallelism:1},high:{time:40,mem:65536,parallelism:1}},s$={id:0,cipher:WU,kdf:new yU(n0),saltLengths:{low:12,high:16},difficulties:n0,defaultChunkSize:524288};u.register(s$);var d0={low:{time:5,mem:65536,parallelism:2},middle:{time:10,mem:98304,parallelism:4},high:{time:20,mem:98304,parallelism:4}},r$={id:1,cipher:e,kdf:new yU(d0,!0),saltLengths:{low:12,high:16},difficulties:d0,defaultChunkSize:524288};u.register(r$);var gU=1;function h0(){return typeof process!=="undefined"&&typeof process.versions==="object"&&!0}function wU(...U){let $=U.reduce((W,V)=>W+V.byteLength,0),Q=new Uint8Array($),J=0;for(let W of U)Q.set(W,J),J+=W.byteLength;return Q}function TU(...U){try{let $=wU(...U);if(h0())return Buffer.from($).toString("base64");let Q="";for(let J=0;J<$.length;J++)Q+=String.fromCharCode($[J]);return btoa(Q)}catch{throw new uU("Base64 Encoding Error")}}function HU(U){try{if(!/^[A-Za-z0-9+/]+={0,2}$/.test(U)||U.length%4!==0)throw new Error("Invalid Base64");if(h0())return new Uint8Array(Buffer.from(U,"base64"));let $=atob(U),Q=new Uint8Array($.length);for(let J=0;J<$.length;J++)Q[J]=$.charCodeAt(J);return Q}catch{throw new PU(`Invalid Base64: length=${U.length}, content='${U.slice(0,12)}…'`)}}function p(U){let $=U.value.length,Q=new Array($).fill("\x00").join("");U.value=Q}function SU(U,$,Q,J,W){let V={low:0,middle:1,high:2};if(!($ in V))throw new TypeError(`Unsupported difficulty: ${$}`);let Z=V[$],Y=U<<5|(Q==="high"?1:0)<<2|Z,q=wU(new Uint8Array([gU,Y]),J);if(W)W.setAAD(q);return q}function i(U,$){if(U[0]!==gU)throw new n("Invalid input format. The input is unknown.");if(U.length<14)throw new n("Invalid input format. Header too short.");try{let Q=U[1],J=Q>>5,W=Q>>2&1?"high":"low",V=Q&3,Z=["low","middle","high"][V],Y=u.get(J).saltLengths[W],q=2+Y;if(U.length<q)throw new n("Invalid input format. Header truncated.");if($)$.setAAD(U.subarray(0,q));let G=U.slice(2,2+Y);return{scheme:J,difficulty:Z,saltStrength:W,salt:G,headerLen:q}}catch(Q){throw new QU(Q instanceof Error?Q.message:String(Q))}}async function fU(U){if(U instanceof Uint8Array)return U;if(U instanceof ArrayBuffer)return new Uint8Array(U);return new Uint8Array(await U.arrayBuffer())}function U0(U){let $=new Uint8Array(4);return new DataView($.buffer).setUint32(0,U,!1),$}function i0(U,$=0){if(U.length-$<4)throw new RangeError("Not enough bytes for frame header");return new DataView(U.buffer,U.byteOffset+$,4).getUint32(0,!1)}var $U=4;class AU{engine;chunkSize;buffer=new Uint8Array(0);constructor(U,$=524288){this.engine=U;this.chunkSize=$}toTransformStream(){return new TransformStream({transform:async(U,$)=>{await this.transform(await fU(U),$)},flush:async(U)=>this.flush(U)})}async transform(U,$){if(U.length>Math.min(this.chunkSize*4,67108864))throw new RangeError(`Input block (${U.length} B) exceeds maximum allowed ${Math.min(this.chunkSize*4,67108864)} B`);let J=new Uint8Array(this.buffer.length+U.length);J.set(this.buffer),J.set(U,this.buffer.length);let W=0;while(J.length-W>=this.chunkSize){let V=J.slice(W,W+this.chunkSize);W+=this.chunkSize;let Z=await this.engine.encryptChunk(V),Y=new Uint8Array($U+Z.length);Y.set(U0(Z.length)),Y.set(Z,$U),$.enqueue(Y)}this.buffer=J.slice(W)}async flush(U){if(!this.buffer.length)return;let $=await this.engine.encryptChunk(this.buffer),Q=new Uint8Array($U+$.length);Q.set(U0($.length)),Q.set($,$U),U.enqueue(Q),this.buffer=new Uint8Array(0),this.engine.zeroKey()}}class OU{engine;chunkSize;buffer=new Uint8Array(0);constructor(U,$=524288){this.engine=U;this.chunkSize=$}toTransformStream(){return new TransformStream({transform:async(U,$)=>{await this.transform(await fU(U),$)},flush:async(U)=>this.flush(U)})}async transform(U,$){let Q=new Uint8Array(this.buffer.length+U.length);Q.set(this.buffer),Q.set(U,this.buffer.length);let J=0;while(!0){if(Q.length-J<$U)break;let W=i0(Q,J);if(W>this.chunkSize*2)throw new x(`Frame length ${W} exceeds …`);if(Q.length-J-$U<W)break;J+=$U;let V=Q.slice(J,J+W);J+=W;try{let Z=await this.engine.decryptChunk(V);$.enqueue(Z)}catch(Z){throw Z instanceof x?Z:new x("Decryption failed: Wrong passphrase or corrupted ciphertext")}}this.buffer=Q.slice(J)}async flush(U){await this.transform(new Uint8Array(0),U),this.buffer=new Uint8Array(0),this.engine.zeroKey()}}async function o0(U,$){let Q=U.getReader(),J=$&&$.length?[$]:[];try{while(!0){let{value:Y,done:q}=await Q.read();if(q)break;J.push(Y)}}finally{Q.releaseLock()}let W=J.reduce((Y,q)=>Y+q.byteLength,0),V=new Uint8Array(W),Z=0;for(let Y of J)V.set(Y,Z),Z+=Y.byteLength;return V}class IU{engine;chunkSize;constructor(U,$=524288){this.engine=U;this.chunkSize=$}encryptionStream(){let U=new AU(this.engine,this.chunkSize).toTransformStream();return{writable:U.writable,readable:U.readable}}decryptionStream(U){let $=U,Q=new TransformStream({transform(W,V){if($===0){V.enqueue(W);return}if(W.byteLength<=$){$-=W.byteLength;return}V.enqueue(W.slice($)),$=0}}),J=new OU(this.engine,this.chunkSize).toTransformStream();return{writable:Q.writable,readable:Q.readable.pipeThrough(J)}}async collect(U,$,Q=null){return o0(U.pipeThrough($),Q??void 0)}getEngine(){return this.engine}}function s0(U=0,$=console.info){return{level:U,log(Q,J){if(Q<=U)$(`${Q}| ${J}`)}}}function r0(U,$,Q){if($<0||Q<0||$+Q>U)throw new RangeError("read() slice exceeds data bounds")}class $0{src;#U=null;constructor(U){this.src=U}get length(){if(this.src instanceof Uint8Array)return this.src.byteLength;if(this.src instanceof Blob)return this.src.size;return this.ensureUint8().byteLength}async read(U,$){if(r0(this.length,U,$),this.src instanceof Uint8Array)return this.src.slice(U,U+$);if(this.src instanceof Blob){let Q=await this.src.slice(U,U+$).arrayBuffer();return new Uint8Array(Q)}return this.ensureUint8().slice(U,U+$)}ensureUint8(){if(!this.#U)this.#U=HU(this.src);return this.#U}}var a0=new WeakMap;class ZU{static getEngine(U,$){let Q=a0.get(U);if(!Q)Q=new Map,a0.set(U,Q);let J=Q.get($);if(J)return J;let W=u.get($);return J={desc:W,cipher:new W.cipher(U),kdf:W.kdf,chunkSize:W.defaultChunkSize,provider:U},Q.set($,J),J}static async deriveKey(U,$,Q,J){try{let W=await U.kdf.derive($.value,Q,J,U.provider);await U.cipher.setKey(W)}catch(W){let V=W instanceof Error?W.message:String(W);throw new r(V)}finally{p($)}}}class YU{provider;v;cipher;kdf;chunkSize;stream;difficulty;saltStrength;engines=new Map;log;constructor(U,$={}){this.provider=U;this.v=u.get($.scheme??u.current.id),this.cipher=new this.v.cipher(U),this.kdf=this.v.kdf,this.chunkSize=this.setChunkSize($.chunkSize??this.v.defaultChunkSize),this.stream=new IU(this.cipher,this.chunkSize),this.difficulty=$.difficulty??"middle",this.saltStrength=$.saltStrength??"high",this.log=s0($.verbose??0,$.logger)}static async isEncrypted(U){try{return await YU.peekHeader(U),!0}catch{return!1}}static async headerDecode(U){let $=await YU.peekHeader(U),Q=i($);return{scheme:Q.scheme,difficulty:Q.difficulty,salt:TU(Q.salt),saltLength:Q.salt.byteLength}}static async decodeData(U){let $=typeof U?.read==="function"?U:new $0(U),Q=await $.read(0,Math.min(256,$.length)),J=await YU.peekHeader(Q),{scheme:W,headerLen:V}=i(J),Z=$.length,Y=Z-V;if(Y<=0)throw new n("Payload is empty");let q=await $.read(V,4),G=new DataView(q.buffer,q.byteOffset,4).getUint32(0,!1);if(G+4<=Y&&G>=28){let P=G,z=V,w=0,M=0;while(z+4<=Z){let H=await $.read(z,4),T=new DataView(H.buffer,H.byteOffset,4).getUint32(0,!1);if(T===0||z+4+T>Z)break;w++,M+=T,z+=4+T}return{isChunked:!0,chunks:{chunkSize:P,count:w,totalPayload:M}}}let X=await $.read(V,Y),O=u.get(W).cipher.IV_LENGTH,F=u.get(W).cipher.TAG_LENGTH;if(X.length<O+F)throw new n("Ciphertext too short for IV & tag");return{isChunked:!1,payloadLength:Y-O-F,params:{iv:X.slice(0,O),ivLength:O,tag:X.slice(X.length-F),tagLength:F}}}setDifficulty(U){this.difficulty=U}getDifficulty(){return this.difficulty}setScheme(U){this.v=u.get(U),this.cipher=new this.v.cipher(this.provider),this.kdf=this.v.kdf,this.stream=new IU(this.cipher,this.chunkSize)}getScheme(){return this.v.id}setSaltDifficulty(U){this.saltStrength=U}getSaltDifficulty(){return this.saltStrength}setChunkSize(U){let $=U,Q;if($==null)Q=this.v.defaultChunkSize;else if(Q=Number($),!Number.isInteger(Q)||Q<1)throw new Error(`Invalid chunkSize: ${$}. Must be a positive integer.`);return this.chunkSize=Q,this.stream=new IU(this.cipher,this.chunkSize),Q}getChunkSize(){return this.chunkSize}setVerbose(U){this.log.level=U}getVerbose(){return this.log.level}async encryptText(U,$){let Q={value:$};try{this.log.log(1,`Start text encryption, scheme: ${this.getScheme()}`),this.log.log(2,"Deriving key for text encryption");let J=this.genSalt();await this.deriveKey(Q,J),p(Q),$=null,this.log.log(3,`Salt generated: ${TU(J)}, KDF difficulty: ${this.difficulty}`),this.log.log(3,"Encoding header");let W=SU(this.v.id,this.difficulty,this.saltStrength,J,this.cipher);this.log.log(2,"Encrypting text data");let V=await this.cipher.encryptChunk(typeof U==="string"?new TextEncoder().encode(U):U);this.cipher.zeroKey(),this.log.log(3,"Encoding text");let Z=TU(W,V);return this.log.log(1,"Decryption finished"),Z}catch(J){throw new RU(J instanceof Error?J.message:String(J))}}async decryptText(U,$){let Q={value:$};try{this.log.log(1,`Start text decryption, Version ${this.getScheme()}`),this.log.log(3,"Start text decoding");let J=HU(U);this.log.log(3,"Start header decoding");let W=i(J);this.log.log(3,"Selecting decryption engine");let V=ZU.getEngine(this.provider,W.scheme);this.log.log(2,`Deriving key via engine for scheme: ${W.scheme}`),this.log.log(3,`Salt use: ${TU(W.salt)}, KDF difficulty: ${W.difficulty}`);try{await ZU.deriveKey(V,Q,W.salt,W.difficulty)}finally{p(Q),$=null}this.log.log(2,"Decrypting text data"),i(J,V.cipher);let Z=await V.cipher.decryptChunk(J.slice(W.headerLen));V.cipher.zeroKey(),this.log.log(3,"Decoding text");let Y=new TextDecoder().decode(Z);return this.log.log(1,"Decryption finished"),Y}catch(J){if(J instanceof x||J instanceof n||J instanceof QU||J instanceof PU||J instanceof r)throw J;throw new x("Decryption failed: wrong passphrase or corrupted ciphertext")}}async encryptFile(U,$){let Q={value:$};try{if(U.size===0){let Z=this.genSalt();await this.deriveKey(Q,Z),p(Q),$=null;let Y=SU(this.v.id,this.difficulty,this.saltStrength,Z);return new Blob([Y],{type:"application/octet-stream"})}this.log.log(2,"Deriving key for file encryption");let J=this.genSalt();await this.deriveKey(Q,J),p(Q),$=null;let W=SU(this.v.id,this.difficulty,this.saltStrength,J,this.stream.getEngine()),V=await this.stream.collect(U.stream(),new AU(this.cipher,this.chunkSize).toTransformStream(),W);return new Blob([V],{type:"application/octet-stream"})}catch(J){throw new RU(J instanceof Error?J.message:String(J))}}async decryptFile(U,$){let Q={value:$};try{let J=await YU.peekHeader(U),W=i(J),V=ZU.getEngine(this.provider,W.scheme);try{await ZU.deriveKey(V,Q,W.salt,W.difficulty)}finally{p(Q),$=null}if(U.size===W.headerLen)return new Blob([],{type:"application/octet-stream"});this.log.log(2,"Decrypting file data");let Z=new IU(V.cipher,V.chunkSize);i(J,Z.getEngine());let Y=await Z.collect(U.slice(W.headerLen).stream(),new OU(V.cipher,V.chunkSize).toTransformStream());return new Blob([Y],{type:"application/octet-stream"})}catch(J){if(J instanceof x)throw J;throw new x(J instanceof Error?J.message:String(J))}}async createEncryptionStream(U){let $={value:U};this.log.log(2,"Deriving key for stream encryption");let Q=this.genSalt();await this.deriveKey($,Q),p($),U=null;let J=SU(this.v.id,this.difficulty,this.saltStrength,Q,this.stream.getEngine()),W=this.stream.encryptionStream();return{header:J,writable:W.writable,readable:W.readable}}async createDecryptionStream(U){let $={value:U},Q=this,J=new Uint8Array(0),W=null,V=65536,Z=14;async function Y(q,G){let K=q.getReader();while(!0){let{value:X,done:O}=await K.read();if(O)break;G.enqueue(X)}}return new TransformStream({async transform(q,G){if(!W){if(q&&q.byteLength){if(J.byteLength+q.byteLength>V){p($),G.error(new n(`Header not found within ${V} bytes`));return}J=wU(J,q)}if(J.byteLength<Z)return;let X=J[1],O=X>>5,F=X>>2&1?"high":"low",P=0;try{P=2+u.get(O).saltLengths[F]}catch(T){p($),G.error(new QU(T instanceof Error?T.message:String(T)));return}if(J.byteLength<P)return;let z=J.subarray(0,P),w;try{w=i(z)}catch(T){p($),G.error(T instanceof Error?T:new QU("Invalid header"));return}let M=ZU.getEngine(Q.provider,w.scheme);try{await ZU.deriveKey(M,$,w.salt,w.difficulty)}finally{p($),U=null}i(z,M.cipher),W=new OU(M.cipher,M.chunkSize).toTransformStream(),Y(W.readable,G).catch((T)=>G.error(T));let H=J.subarray(P);if(J=new Uint8Array(0),H.byteLength){let T=W.writable.getWriter();await T.write(H),T.releaseLock()}return}let K=W.writable.getWriter();await K.write(q),K.releaseLock()},async flush(){if(!W)throw p($),new n("Header not found before end of stream");let q=W.writable.getWriter();await q.close(),q.releaseLock()}})}async deriveKey(U,$,Q=this.difficulty){let J=performance.now();try{let W=await this.kdf.derive(U.value,$,Q,this.provider);p(U),await this.cipher.setKey(W),this.log.log(3,`Key derivation completed in ${(performance.now()-J).toFixed(1)} ms`)}catch(W){throw new r(W instanceof Error?W.message:String(W))}}genSalt(U=this.saltStrength){let $=this.v.saltLengths[this.saltStrength];return this.provider.getRandomValues(new Uint8Array($))}static async peekHeader(U){let $=await this.readAsUint8(U);if($ instanceof Uint8Array){if($.length<2)throw new n("Input too short");let{headerLen:Q}=i($.length>=16?$:Uint8Array.from($));if($.length<Q)throw new n("Incomplete header");return $.slice(0,Q)}throw new QU("Unsupported input type")}static async readAsUint8(U){if(typeof U==="string")return HU(U);if(U instanceof Blob){let $=U.slice(0,64);return new Uint8Array(await $.arrayBuffer())}return U}}import{webcrypto as a$,randomFillSync as t$}from"node:crypto";var t0={subtle:a$.subtle,getRandomValues(U){return t$(U),U},isNode:!0};function _Q(U){return new YU(t0,U)}export{_Q as createCryptit};

//# debugId=FB777F95803BCED864756E2164756E21
