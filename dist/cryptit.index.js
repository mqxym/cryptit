import{createRequire as sU}from"node:module";var xU=Object.create;var{getPrototypeOf:iU,defineProperty:a0,getOwnPropertyNames:pU}=Object;var oU=Object.prototype.hasOwnProperty;var rU=(U,$,Y)=>{Y=U!=null?xU(iU(U)):{};let z=$||!U||!U.__esModule?a0(Y,"default",{value:U,enumerable:!0}):Y;for(let J of pU(U))if(!oU.call(z,J))a0(z,J,{get:()=>U[J],enumerable:!0});return z};var F0=(U,$)=>()=>($||U(($={exports:{}}).exports,$),$.exports);var u=sU(import.meta.url);var HU=F0((PY,IU)=>{var E0=/^[a-z0-9-]{1,32}$/,C0=/^[a-z0-9-]{1,32}$/,L0=/^[a-zA-Z0-9/+.-]+$/,MU=/^([a-zA-Z0-9/+.-]+|)$/,M$=/^((-)?[1-9]\d*|0)$/,d0=/^v=(\d+)$/;function S$(U){return M0(U).map(($)=>[$,U[$]].join("=")).join(",")}function I$(U){let $={};return U.split(",").forEach((Y)=>{let z=Y.split("=");if(z.length<2)throw new TypeError("params must be in the format name=value");$[z.shift()]=z.join("=")}),$}function M0(U){return Object.keys(U)}function SU(U){if(typeof Object.values==="function")return Object.values(U);return M0(U).map(($)=>U[$])}function H$(U){let $=[""];if(typeof U!=="object"||U===null)throw new TypeError("opts must be an object");if(typeof U.id!=="string")throw new TypeError("id must be a string");if(!E0.test(U.id))throw new TypeError(`id must satisfy ${E0}`);if($.push(U.id),typeof U.version!=="undefined"){if(typeof U.version!=="number"||U.version<0||!Number.isInteger(U.version))throw new TypeError("version must be a positive integer number");$.push(`v=${U.version}`)}if(typeof U.params!=="undefined"){if(typeof U.params!=="object"||U.params===null)throw new TypeError("params must be an object");let z=M0(U.params);if(!z.every((Q)=>C0.test(Q)))throw new TypeError(`params names must satisfy ${C0}`);z.forEach((Q)=>{if(typeof U.params[Q]==="number")U.params[Q]=U.params[Q].toString();else if(Buffer.isBuffer(U.params[Q]))U.params[Q]=U.params[Q].toString("base64").split("=")[0]});let J=SU(U.params);if(!J.every((Q)=>typeof Q==="string"))throw new TypeError("params values must be strings");if(!J.every((Q)=>L0.test(Q)))throw new TypeError(`params values must satisfy ${L0}`);let W=S$(U.params);$.push(W)}if(typeof U.salt!=="undefined"){if(!Buffer.isBuffer(U.salt))throw new TypeError("salt must be a Buffer");if($.push(U.salt.toString("base64").split("=")[0]),typeof U.hash!=="undefined"){if(!Buffer.isBuffer(U.hash))throw new TypeError("hash must be a Buffer");$.push(U.hash.toString("base64").split("=")[0])}}return $.join("$")}function K$(U){if(typeof U!=="string"||U==="")throw new TypeError("pchstr must be a non-empty string");if(U[0]!=="$")throw new TypeError("pchstr must contain a $ as first char");let $=U.split("$");$.shift();let Y=5;if(!d0.test($[1]))Y--;if($.length>Y)throw new TypeError(`pchstr contains too many fileds: ${$.length}/${Y}`);let z=$.shift();if(!E0.test(z))throw new TypeError(`id must satisfy ${E0}`);let J;if(d0.test($[0]))J=parseInt($.shift().match(d0)[1],10);let W,Q;if(MU.test($[$.length-1]))if($.length>1&&MU.test($[$.length-2]))W=Buffer.from($.pop(),"base64"),Q=Buffer.from($.pop(),"base64");else Q=Buffer.from($.pop(),"base64");let G;if($.length>0){let X=$.pop();if(G=I$(X),!M0(G).every((S)=>C0.test(S)))throw new TypeError(`params names must satisfy ${C0}`);if(!SU(G).every((S)=>L0.test(S)))throw new TypeError(`params values must satisfy ${L0}`);M0(G).forEach((S)=>{G[S]=M$.test(G[S])?parseInt(G[S],10):G[S]})}if($.length>0)throw new TypeError(`pchstr contains unrecognized fileds: ${$}`);let Z={id:z};if(J)Z.version=J;if(G)Z.params=G;if(Q)Z.salt=Q;if(W)Z.hash=W;return Z}IU.exports={serialize:H$,deserialize:K$}});var vU=F0((MY,_U)=>{var NU=u("fs"),a=u("path"),TU=u("os"),DU=typeof __webpack_require__==="function"?__non_webpack_require__:u,A$=process.config&&process.config.variables||{},F$=!!process.env.PREBUILDS_ONLY,KU=process.versions.modules,n0=D$()?"electron":T$()?"node-webkit":"node",u0=process.env.npm_config_arch||TU.arch(),x0=process.env.npm_config_platform||TU.platform(),OU=process.env.LIBC||(O$(x0)?"musl":"glibc"),i0=process.env.ARM_VERSION||(u0==="arm64"?"8":A$.arm_version)||"",RU=(process.versions.uv||"").split(".")[0];_U.exports=x;function x(U){return DU(x.resolve(U))}x.resolve=x.path=function(U){U=a.resolve(U||".");try{var $=DU(a.join(U,"package.json")).name.toUpperCase().replace(/-/g,"_");if(process.env[$+"_PREBUILD"])U=process.env[$+"_PREBUILD"]}catch(Z){}if(!F$){var Y=AU(a.join(U,"build/Release"),FU);if(Y)return Y;var z=AU(a.join(U,"build/Debug"),FU);if(z)return z}var J=G(U);if(J)return J;var W=G(a.dirname(process.execPath));if(W)return W;var Q=["platform="+x0,"arch="+u0,"runtime="+n0,"abi="+KU,"uv="+RU,i0?"armv="+i0:"","libc="+OU,"node="+process.versions.node,process.versions.electron?"electron="+process.versions.electron:"",typeof __webpack_require__==="function"?"webpack=true":""].filter(Boolean).join(" ");throw new Error("No native build was found for "+Q+`
    loaded from: `+U+`
`);function G(Z){var X=p0(a.join(Z,"prebuilds")).map(wU),V=X.filter(BU(x0,u0)).sort(EU)[0];if(!V)return;var P=a.join(Z,"prebuilds",V.name),S=p0(P).map(CU),K=S.filter(LU(n0,KU)),I=K.sort(jU(n0))[0];if(I)return a.join(P,I.file)}};function p0(U){try{return NU.readdirSync(U)}catch($){return[]}}function AU(U,$){var Y=p0(U).filter($);return Y[0]&&a.join(U,Y[0])}function FU(U){return/\.node$/.test(U)}function wU(U){var $=U.split("-");if($.length!==2)return;var Y=$[0],z=$[1].split("+");if(!Y)return;if(!z.length)return;if(!z.every(Boolean))return;return{name:U,platform:Y,architectures:z}}function BU(U,$){return function(Y){if(Y==null)return!1;if(Y.platform!==U)return!1;return Y.architectures.includes($)}}function EU(U,$){return U.architectures.length-$.architectures.length}function CU(U){var $=U.split("."),Y=$.pop(),z={file:U,specificity:0};if(Y!=="node")return;for(var J=0;J<$.length;J++){var W=$[J];if(W==="node"||W==="electron"||W==="node-webkit")z.runtime=W;else if(W==="napi")z.napi=!0;else if(W.slice(0,3)==="abi")z.abi=W.slice(3);else if(W.slice(0,2)==="uv")z.uv=W.slice(2);else if(W.slice(0,4)==="armv")z.armv=W.slice(4);else if(W==="glibc"||W==="musl")z.libc=W;else continue;z.specificity++}return z}function LU(U,$){return function(Y){if(Y==null)return!1;if(Y.runtime&&Y.runtime!==U&&!N$(Y))return!1;if(Y.abi&&Y.abi!==$&&!Y.napi)return!1;if(Y.uv&&Y.uv!==RU)return!1;if(Y.armv&&Y.armv!==i0)return!1;if(Y.libc&&Y.libc!==OU)return!1;return!0}}function N$(U){return U.runtime==="node"&&U.napi}function jU(U){return function($,Y){if($.runtime!==Y.runtime)return $.runtime===U?-1:1;else if($.abi!==Y.abi)return $.abi?-1:1;else if($.specificity!==Y.specificity)return $.specificity>Y.specificity?-1:1;else return 0}}function T$(){return!!(process.versions&&process.versions.nw)}function D$(){if(process.versions&&process.versions.electron)return!0;if(process.env.ELECTRON_RUN_AS_NODE)return!0;return typeof window!=="undefined"&&window.process&&window.process.type==="renderer"}function O$(U){return U==="linux"&&NU.existsSync("/etc/alpine-release")}x.parseTags=CU;x.matchTags=LU;x.compareTags=jU;x.parseTuple=wU;x.matchTuple=BU;x.compareTuples=EU});var mU=F0((IY,r0)=>{var o0=typeof __webpack_require__==="function"?__non_webpack_require__:u;if(typeof o0.addon==="function")r0.exports=o0.addon.bind(o0);else r0.exports=vU()});var bU=F0((k$,$0)=>{var __dirname="/Users/maxim/Projects/Private/Sites/cryptit/node_modules/argon2",KY=u("node:assert"),{randomBytes:R$,timingSafeEqual:w$}=u("node:crypto"),{promisify:B$}=u("node:util"),{deserialize:kU,serialize:E$}=HU(),C$=mU(),{hash:fU}=C$(__dirname),L$=B$(R$);k$.argon2d=0;k$.argon2i=1;k$.argon2id=2;var S0=Object.freeze({argon2d:0,argon2i:1,argon2id:2}),j$=Object.freeze({[S0.argon2d]:"argon2d",[S0.argon2i]:"argon2i",[S0.argon2id]:"argon2id"}),yU={hashLength:32,timeCost:3,memoryCost:65536,parallelism:4,type:2,version:19};async function _$(U,$){let{raw:Y,salt:z,...J}={...yU,...$};if(J.hashLength>4294967295)throw new RangeError("Hash length is too large");if(J.memoryCost>4294967295)throw new RangeError("Memory cost is too large");if(J.timeCost>4294967295)throw new RangeError("Time cost is too large");if(J.parallelism>16777215)throw new RangeError("Parallelism is too large");z=z??await L$(16);let{hashLength:W,secret:Q=Buffer.alloc(0),type:G,version:Z,memoryCost:X,timeCost:V,parallelism:P,associatedData:S=Buffer.alloc(0)}=J,K=await fU({password:Buffer.from(U),salt:z,secret:Q,data:S,hashLength:W,m:X,t:V,p:P,version:Z,type:G});if(Y)return K;return E$({id:j$[G],version:Z,params:{m:X,t:V,p:P,...S.byteLength>0?{data:S}:{}},salt:z,hash:K})}k$.hash=_$;function v$(U,$={}){let{memoryCost:Y,timeCost:z,parallelism:J,version:W}={...yU,...$},{version:Q,params:{m:G,t:Z,p:X}}=kU(U);return+Q!==+W||+G!==+Y||+Z!==+z||+X!==+J}k$.needsRehash=v$;async function m$(U,$,Y={}){let{id:z,...J}=kU(U);if(!(z in S0))return!1;let{version:W=16,params:{m:Q,t:G,p:Z,data:X=""},salt:V,hash:P}=J,{secret:S=Buffer.alloc(0)}=Y;return w$(await fU({password:Buffer.from($),salt:V,secret:S,data:Buffer.from(X,"base64"),hashLength:P.byteLength,m:+Q,t:+G,p:+Z,version:+W,type:S0[z]}),P)}k$.verify=m$});class p extends Error{constructor(U){super(U);Object.setPrototypeOf(this,new.target.prototype),this.name=new.target.name,this.stack=void 0}}class t extends p{}class P0 extends p{}class m0 extends p{}class N0 extends p{}class X0 extends p{}class o extends p{}class T0 extends p{}class d extends p{}class h{static byId=new Map;static register(U){if(this.byId.has(U.id))throw new N0(`Scheme ${U.id} already registered`);this.byId.set(U.id,U)}static get(U){let $=this.byId.get(U);if(!$)throw new N0(`Unknown scheme: ${U}`);return $}static get current(){return this.get(0)}}class k0{p;key;constructor(U){this.p=U}async setKey(U){this.key=U}async encryptChunk(U){let $=this.p.getRandomValues(new Uint8Array(12)),Y=new Uint8Array(await this.p.subtle.encrypt({name:"AES-GCM",iv:$},this.key,U));U.fill(0);let z=new Uint8Array($.length+Y.length);return z.set($),z.set(Y,$.length),z}async decryptChunk(U){let $=U.slice(0,12),Y=U.slice(12);try{let z=await this.p.subtle.decrypt({name:"AES-GCM",iv:$},this.key,Y);return new Uint8Array(z)}catch{throw new d("Decryption failed: wrong passphrase or corrupted ciphertext")}}}/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function t0(U){return U instanceof Uint8Array||ArrayBuffer.isView(U)&&U.constructor.name==="Uint8Array"}function D0(U){if(typeof U!=="boolean")throw new Error(`boolean expected, not ${U}`)}function O0(U){if(!Number.isSafeInteger(U)||U<0)throw new Error("positive integer expected, got "+U)}function l(U,...$){if(!t0(U))throw new Error("Uint8Array expected");if($.length>0&&!$.includes(U.length))throw new Error("Uint8Array expected of length "+$+", got length="+U.length)}function f0(U,$=!0){if(U.destroyed)throw new Error("Hash instance has been destroyed");if($&&U.finished)throw new Error("Hash#digest() has already been called")}function UU(U,$){l(U);let Y=$.outputLen;if(U.length<Y)throw new Error("digestInto() expects output buffer of length at least "+Y)}function r(U){return new Uint32Array(U.buffer,U.byteOffset,Math.floor(U.byteLength/4))}function s(...U){for(let $=0;$<U.length;$++)U[$].fill(0)}function aU(U){return new DataView(U.buffer,U.byteOffset,U.byteLength)}var eU=(()=>new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68)();function tU(U){if(typeof U!=="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(U))}function R0(U){if(typeof U==="string")U=tU(U);else if(t0(U))U=w0(U);else throw new Error("Uint8Array expected, got "+typeof U);return U}function $U(U,$){if($==null||typeof $!=="object")throw new Error("options must be defined");return Object.assign(U,$)}function YU(U,$){if(U.length!==$.length)return!1;let Y=0;for(let z=0;z<U.length;z++)Y|=U[z]^$[z];return Y===0}var y0=(U,$)=>{function Y(z,...J){if(l(z),!eU)throw new Error("Non little-endian hardware is not yet supported");if(U.nonceLength!==void 0){let V=J[0];if(!V)throw new Error("nonce / iv required");if(U.varSizeNonce)l(V);else l(V,U.nonceLength)}let W=U.tagLength;if(W&&J[1]!==void 0)l(J[1]);let Q=$(z,...J),G=(V,P)=>{if(P!==void 0){if(V!==2)throw new Error("cipher output not supported");l(P)}},Z=!1;return{encrypt(V,P){if(Z)throw new Error("cannot encrypt() twice with same key + nonce");return Z=!0,l(V),G(Q.encrypt.length,P),Q.encrypt(V,P)},decrypt(V,P){if(l(V),W&&V.length<W)throw new Error("invalid ciphertext length: smaller than tagLength="+W);return G(Q.decrypt.length,P),Q.decrypt(V,P)}}}return Object.assign(Y,U),Y};function b0(U,$,Y=!0){if($===void 0)return new Uint8Array(U);if($.length!==U)throw new Error("invalid output length, expected "+U+", got: "+$.length);if(Y&&!U$($))throw new Error("invalid output, must be aligned");return $}function e0(U,$,Y,z){if(typeof U.setBigUint64==="function")return U.setBigUint64($,Y,z);let J=BigInt(32),W=BigInt(4294967295),Q=Number(Y>>J&W),G=Number(Y&W),Z=z?4:0,X=z?0:4;U.setUint32($+Z,Q,z),U.setUint32($+X,G,z)}function zU(U,$,Y){D0(Y);let z=new Uint8Array(16),J=aU(z);return e0(J,0,BigInt($),Y),e0(J,8,BigInt(U),Y),z}function U$(U){return U.byteOffset%4===0}function w0(U){return Uint8Array.from(U)}var QU=(U)=>Uint8Array.from(U.split("").map(($)=>$.charCodeAt(0))),$$=QU("expand 16-byte k"),Y$=QU("expand 32-byte k"),z$=r($$),J$=r(Y$);function q(U,$){return U<<$|U>>>32-$}function g0(U){return U.byteOffset%4===0}var B0=64,Q$=16,WU=4294967295,JU=new Uint32Array;function W$(U,$,Y,z,J,W,Q,G){let Z=J.length,X=new Uint8Array(B0),V=r(X),P=g0(J)&&g0(W),S=P?r(J):JU,K=P?r(W):JU;for(let I=0;I<Z;Q++){if(U($,Y,z,V,Q,G),Q>=WU)throw new Error("arx: counter overflow");let H=Math.min(B0,Z-I);if(P&&H===B0){let F=I/4;if(I%4!==0)throw new Error("arx: invalid block position");for(let A=0,N;A<Q$;A++)N=F+A,K[N]=S[N]^V[A];I+=B0;continue}for(let F=0,A;F<H;F++)A=I+F,W[A]=J[A]^X[F];I+=H}}function c0(U,$){let{allowShortKeys:Y,extendNonceFn:z,counterLength:J,counterRight:W,rounds:Q}=$U({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},$);if(typeof U!=="function")throw new Error("core must be a function");return O0(J),O0(Q),D0(W),D0(Y),(G,Z,X,V,P=0)=>{l(G),l(Z),l(X);let S=X.length;if(V===void 0)V=new Uint8Array(S);if(l(V),O0(P),P<0||P>=WU)throw new Error("arx: counter overflow");if(V.length<S)throw new Error(`arx: output (${V.length}) is shorter than data (${S})`);let K=[],I=G.length,H,F;if(I===32)K.push(H=w0(G)),F=J$;else if(I===16&&Y)H=new Uint8Array(32),H.set(G),H.set(G,16),F=z$,K.push(H);else throw new Error(`arx: invalid 32-byte key, got length=${I}`);if(!g0(Z))K.push(Z=w0(Z));let A=r(H);if(z){if(Z.length!==24)throw new Error("arx: extended nonce must be 24 bytes");z(F,A,r(Z.subarray(0,16)),A),Z=Z.subarray(16)}let N=16-J;if(N!==Z.length)throw new Error(`arx: nonce must be ${N} or 16 bytes`);if(N!==12){let y=new Uint8Array(12);y.set(Z,W?0:12-Z.length),Z=y,K.push(Z)}let m=r(Z);return W$(U,F,A,m,X,V,P,Q),s(...K),V}}var b=(U,$)=>U[$++]&255|(U[$++]&255)<<8;class GU{constructor(U){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,U=R0(U),l(U,32);let $=b(U,0),Y=b(U,2),z=b(U,4),J=b(U,6),W=b(U,8),Q=b(U,10),G=b(U,12),Z=b(U,14);this.r[0]=$&8191,this.r[1]=($>>>13|Y<<3)&8191,this.r[2]=(Y>>>10|z<<6)&7939,this.r[3]=(z>>>7|J<<9)&8191,this.r[4]=(J>>>4|W<<12)&255,this.r[5]=W>>>1&8190,this.r[6]=(W>>>14|Q<<2)&8191,this.r[7]=(Q>>>11|G<<5)&8065,this.r[8]=(G>>>8|Z<<8)&8191,this.r[9]=Z>>>5&127;for(let X=0;X<8;X++)this.pad[X]=b(U,16+2*X)}process(U,$,Y=!1){let z=Y?0:2048,{h:J,r:W}=this,Q=W[0],G=W[1],Z=W[2],X=W[3],V=W[4],P=W[5],S=W[6],K=W[7],I=W[8],H=W[9],F=b(U,$+0),A=b(U,$+2),N=b(U,$+4),m=b(U,$+6),y=b(U,$+8),e=b(U,$+10),g=b(U,$+12),c=b(U,$+14),T=J[0]+(F&8191),D=J[1]+((F>>>13|A<<3)&8191),O=J[2]+((A>>>10|N<<6)&8191),R=J[3]+((N>>>7|m<<9)&8191),w=J[4]+((m>>>4|y<<12)&8191),B=J[5]+(y>>>1&8191),E=J[6]+((y>>>14|e<<2)&8191),C=J[7]+((e>>>11|g<<5)&8191),L=J[8]+((g>>>8|c<<8)&8191),j=J[9]+(c>>>5|z),M=0,v=M+T*Q+D*(5*H)+O*(5*I)+R*(5*K)+w*(5*S);M=v>>>13,v&=8191,v+=B*(5*P)+E*(5*V)+C*(5*X)+L*(5*Z)+j*(5*G),M+=v>>>13,v&=8191;let k=M+T*G+D*Q+O*(5*H)+R*(5*I)+w*(5*K);M=k>>>13,k&=8191,k+=B*(5*S)+E*(5*P)+C*(5*V)+L*(5*X)+j*(5*Z),M+=k>>>13,k&=8191;let f=M+T*Z+D*G+O*Q+R*(5*H)+w*(5*I);M=f>>>13,f&=8191,f+=B*(5*K)+E*(5*S)+C*(5*P)+L*(5*V)+j*(5*X),M+=f>>>13,f&=8191;let _=M+T*X+D*Z+O*G+R*Q+w*(5*H);M=_>>>13,_&=8191,_+=B*(5*I)+E*(5*K)+C*(5*S)+L*(5*P)+j*(5*V),M+=_>>>13,_&=8191;let i=M+T*V+D*X+O*Z+R*G+w*Q;M=i>>>13,i&=8191,i+=B*(5*H)+E*(5*I)+C*(5*K)+L*(5*S)+j*(5*P),M+=i>>>13,i&=8191;let J0=M+T*P+D*V+O*X+R*Z+w*G;M=J0>>>13,J0&=8191,J0+=B*Q+E*(5*H)+C*(5*I)+L*(5*K)+j*(5*S),M+=J0>>>13,J0&=8191;let Q0=M+T*S+D*P+O*V+R*X+w*Z;M=Q0>>>13,Q0&=8191,Q0+=B*G+E*Q+C*(5*H)+L*(5*I)+j*(5*K),M+=Q0>>>13,Q0&=8191;let W0=M+T*K+D*S+O*P+R*V+w*X;M=W0>>>13,W0&=8191,W0+=B*Z+E*G+C*Q+L*(5*H)+j*(5*I),M+=W0>>>13,W0&=8191;let G0=M+T*I+D*K+O*S+R*P+w*V;M=G0>>>13,G0&=8191,G0+=B*X+E*Z+C*G+L*Q+j*(5*H),M+=G0>>>13,G0&=8191;let Z0=M+T*H+D*I+O*K+R*S+w*P;M=Z0>>>13,Z0&=8191,Z0+=B*V+E*X+C*Z+L*G+j*Q,M+=Z0>>>13,Z0&=8191,M=(M<<2)+M|0,M=M+v|0,v=M&8191,M=M>>>13,k+=M,J[0]=v,J[1]=k,J[2]=f,J[3]=_,J[4]=i,J[5]=J0,J[6]=Q0,J[7]=W0,J[8]=G0,J[9]=Z0}finalize(){let{h:U,pad:$}=this,Y=new Uint16Array(10),z=U[1]>>>13;U[1]&=8191;for(let Q=2;Q<10;Q++)U[Q]+=z,z=U[Q]>>>13,U[Q]&=8191;U[0]+=z*5,z=U[0]>>>13,U[0]&=8191,U[1]+=z,z=U[1]>>>13,U[1]&=8191,U[2]+=z,Y[0]=U[0]+5,z=Y[0]>>>13,Y[0]&=8191;for(let Q=1;Q<10;Q++)Y[Q]=U[Q]+z,z=Y[Q]>>>13,Y[Q]&=8191;Y[9]-=8192;let J=(z^1)-1;for(let Q=0;Q<10;Q++)Y[Q]&=J;J=~J;for(let Q=0;Q<10;Q++)U[Q]=U[Q]&J|Y[Q];U[0]=(U[0]|U[1]<<13)&65535,U[1]=(U[1]>>>3|U[2]<<10)&65535,U[2]=(U[2]>>>6|U[3]<<7)&65535,U[3]=(U[3]>>>9|U[4]<<4)&65535,U[4]=(U[4]>>>12|U[5]<<1|U[6]<<14)&65535,U[5]=(U[6]>>>2|U[7]<<11)&65535,U[6]=(U[7]>>>5|U[8]<<8)&65535,U[7]=(U[8]>>>8|U[9]<<5)&65535;let W=U[0]+$[0];U[0]=W&65535;for(let Q=1;Q<8;Q++)W=(U[Q]+$[Q]|0)+(W>>>16)|0,U[Q]=W&65535;s(Y)}update(U){f0(this),U=R0(U),l(U);let{buffer:$,blockLen:Y}=this,z=U.length;for(let J=0;J<z;){let W=Math.min(Y-this.pos,z-J);if(W===Y){for(;Y<=z-J;J+=Y)this.process(U,J);continue}if($.set(U.subarray(J,J+W),this.pos),this.pos+=W,J+=W,this.pos===Y)this.process($,0,!1),this.pos=0}return this}destroy(){s(this.h,this.r,this.buffer,this.pad)}digestInto(U){f0(this),UU(U,this),this.finished=!0;let{buffer:$,h:Y}=this,{pos:z}=this;if(z){$[z++]=1;for(;z<16;z++)$[z]=0;this.process($,0,!0)}this.finalize();let J=0;for(let W=0;W<8;W++)U[J++]=Y[W]>>>0,U[J++]=Y[W]>>>8;return U}digest(){let{buffer:U,outputLen:$}=this;this.digestInto(U);let Y=U.slice(0,$);return this.destroy(),Y}}function G$(U){let $=(z,J)=>U(J).update(R0(z)).digest(),Y=U(new Uint8Array(32));return $.outputLen=Y.outputLen,$.blockLen=Y.blockLen,$.create=(z)=>U(z),$}var ZU=G$((U)=>new GU(U));function VU(U,$,Y,z,J,W=20){let Q=U[0],G=U[1],Z=U[2],X=U[3],V=$[0],P=$[1],S=$[2],K=$[3],I=$[4],H=$[5],F=$[6],A=$[7],N=J,m=Y[0],y=Y[1],e=Y[2],g=Q,c=G,T=Z,D=X,O=V,R=P,w=S,B=K,E=I,C=H,L=F,j=A,M=N,v=m,k=y,f=e;for(let i=0;i<W;i+=2)g=g+O|0,M=q(M^g,16),E=E+M|0,O=q(O^E,12),g=g+O|0,M=q(M^g,8),E=E+M|0,O=q(O^E,7),c=c+R|0,v=q(v^c,16),C=C+v|0,R=q(R^C,12),c=c+R|0,v=q(v^c,8),C=C+v|0,R=q(R^C,7),T=T+w|0,k=q(k^T,16),L=L+k|0,w=q(w^L,12),T=T+w|0,k=q(k^T,8),L=L+k|0,w=q(w^L,7),D=D+B|0,f=q(f^D,16),j=j+f|0,B=q(B^j,12),D=D+B|0,f=q(f^D,8),j=j+f|0,B=q(B^j,7),g=g+R|0,f=q(f^g,16),L=L+f|0,R=q(R^L,12),g=g+R|0,f=q(f^g,8),L=L+f|0,R=q(R^L,7),c=c+w|0,M=q(M^c,16),j=j+M|0,w=q(w^j,12),c=c+w|0,M=q(M^c,8),j=j+M|0,w=q(w^j,7),T=T+B|0,v=q(v^T,16),E=E+v|0,B=q(B^E,12),T=T+B|0,v=q(v^T,8),E=E+v|0,B=q(B^E,7),D=D+O|0,k=q(k^D,16),C=C+k|0,O=q(O^C,12),D=D+O|0,k=q(k^D,8),C=C+k|0,O=q(O^C,7);let _=0;z[_++]=Q+g|0,z[_++]=G+c|0,z[_++]=Z+T|0,z[_++]=X+D|0,z[_++]=V+O|0,z[_++]=P+R|0,z[_++]=S+w|0,z[_++]=K+B|0,z[_++]=I+E|0,z[_++]=H+C|0,z[_++]=F+L|0,z[_++]=A+j|0,z[_++]=N+M|0,z[_++]=m+v|0,z[_++]=y+k|0,z[_++]=e+f|0}function Z$(U,$,Y,z){let J=U[0],W=U[1],Q=U[2],G=U[3],Z=$[0],X=$[1],V=$[2],P=$[3],S=$[4],K=$[5],I=$[6],H=$[7],F=Y[0],A=Y[1],N=Y[2],m=Y[3];for(let e=0;e<20;e+=2)J=J+Z|0,F=q(F^J,16),S=S+F|0,Z=q(Z^S,12),J=J+Z|0,F=q(F^J,8),S=S+F|0,Z=q(Z^S,7),W=W+X|0,A=q(A^W,16),K=K+A|0,X=q(X^K,12),W=W+X|0,A=q(A^W,8),K=K+A|0,X=q(X^K,7),Q=Q+V|0,N=q(N^Q,16),I=I+N|0,V=q(V^I,12),Q=Q+V|0,N=q(N^Q,8),I=I+N|0,V=q(V^I,7),G=G+P|0,m=q(m^G,16),H=H+m|0,P=q(P^H,12),G=G+P|0,m=q(m^G,8),H=H+m|0,P=q(P^H,7),J=J+X|0,m=q(m^J,16),I=I+m|0,X=q(X^I,12),J=J+X|0,m=q(m^J,8),I=I+m|0,X=q(X^I,7),W=W+V|0,F=q(F^W,16),H=H+F|0,V=q(V^H,12),W=W+V|0,F=q(F^W,8),H=H+F|0,V=q(V^H,7),Q=Q+P|0,A=q(A^Q,16),S=S+A|0,P=q(P^S,12),Q=Q+P|0,A=q(A^Q,8),S=S+A|0,P=q(P^S,7),G=G+Z|0,N=q(N^G,16),K=K+N|0,Z=q(Z^K,12),G=G+Z|0,N=q(N^G,8),K=K+N|0,Z=q(Z^K,7);let y=0;z[y++]=J,z[y++]=W,z[y++]=Q,z[y++]=G,z[y++]=F,z[y++]=A,z[y++]=N,z[y++]=m}var X$=c0(VU,{counterRight:!1,counterLength:4,allowShortKeys:!1}),q$=c0(VU,{counterRight:!1,counterLength:8,extendNonceFn:Z$,allowShortKeys:!1});var V$=new Uint8Array(16),XU=(U,$)=>{U.update($);let Y=$.length%16;if(Y)U.update(V$.subarray(Y))},P$=new Uint8Array(32);function qU(U,$,Y,z,J){let W=U($,Y,P$),Q=ZU.create(W);if(J)XU(Q,J);XU(Q,z);let G=zU(z.length,J?J.length:0,!0);Q.update(G);let Z=Q.digest();return s(W,G),Z}var PU=(U)=>($,Y,z)=>{return{encrypt(W,Q){let G=W.length;Q=b0(G+16,Q,!1),Q.set(W);let Z=Q.subarray(0,-16);U($,Y,Z,Z,1);let X=qU(U,$,Y,Z,z);return Q.set(X,G),s(X),Q},decrypt(W,Q){Q=b0(W.length-16,Q,!1);let G=W.subarray(0,-16),Z=W.subarray(-16),X=qU(U,$,Y,G,z);if(!YU(Z,X))throw new Error("invalid tag");return Q.set(W.subarray(0,-16)),U($,Y,Q,Q,1),s(X),Q}}},GY=y0({blockSize:64,nonceLength:12,tagLength:16},PU(X$)),l0=y0({blockSize:64,nonceLength:24,tagLength:16},PU(q$));class h0{p;key;constructor(U){this.p=U}async setKey(U){this.key=new Uint8Array(await this.p.subtle.exportKey("raw",U))}async encryptChunk(U){let $=this.p.getRandomValues(new Uint8Array(24)),z=l0(this.key,$).encrypt(U);U.fill(0);let J=new Uint8Array($.length+z.length);return J.set($,0),J.set(z,$.length),J}async decryptChunk(U){let $=U.slice(0,24),Y=U.slice(24),z=l0(this.key,$);try{return z.decrypt(Y)}catch{throw new d("Decryption failed: wrong passphrase or corrupted ciphertext")}}}import*as j0 from"argon2-browser";async function gU(U,$,Y,z){if(z==="node"){let J=await Promise.resolve().then(() => rU(bU(),1)),W=typeof U==="string"?Buffer.from(U,"utf8"):Buffer.from(U),Q=Buffer.from($),G=await J.hash(W,{salt:Q,timeCost:Y.time,memoryCost:Y.mem,parallelism:Y.parallelism,hashLength:32,raw:!0,type:J.argon2id});return Q.fill(0),W.fill(0),{hash:new Uint8Array(G)}}if(z==="browser"){if(!("loadArgon2WasmBinary"in globalThis))globalThis.loadArgon2WasmBinary=()=>fetch("argon2.wasm").then((J)=>{if(!J.ok)throw new Error("Failed to load argon2.wasm");return J.arrayBuffer()}).then((J)=>new Uint8Array(J));return j0.hash({pass:U,salt:$,time:Y.time,mem:Y.mem,parallelism:Y.parallelism,hashLen:32,type:j0.ArgonType.Argon2id}).then((J)=>{if(!J||!J.hash)throw new o("Failed to produce key derivation");return{hash:J.hash}}).catch((J)=>{let W=J instanceof Error?J.message:typeof J==="string"?J:"Unknown error";throw new o(`argon2-browser failure: ${W}`)})}throw new Error(`Unsupported environment: ${z}`)}class _0{presets;exportExtractable;name="argon2id";constructor(U,$=!1){this.presets=U;this.exportExtractable=$}async derive(U,$,Y,z){let{hash:J}=await gU(U,$,this.presets[Y],z.isNode?"node":"browser");if(this.exportExtractable)return z.subtle.importKey("raw",J,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]);else return z.subtle.importKey("raw",J,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}}var cU={low:{time:5,mem:65536,parallelism:1},middle:{time:20,mem:65536,parallelism:1},high:{time:40,mem:65536,parallelism:1}},h$={id:0,cipher:k0,kdf:new _0(cU),saltLengths:{low:12,high:16},difficulties:cU,defaultChunkSize:524288};h.register(h$);var lU={low:{time:5,mem:65536,parallelism:2},middle:{time:10,mem:98304,parallelism:4},high:{time:20,mem:98304,parallelism:4}},d$={id:1,cipher:h0,kdf:new _0(lU,!0),saltLengths:{low:12,high:16},difficulties:lU,defaultChunkSize:524288};h.register(d$);var v0=1;function hU(){return typeof process!=="undefined"&&typeof process.versions==="object"&&!0}function I0(...U){let $=U.reduce((J,W)=>J+W.byteLength,0),Y=new Uint8Array($),z=0;for(let J of U)Y.set(J,z),z+=J.byteLength;return Y}function H0(...U){try{let $=I0(...U);if(hU())return Buffer.from($).toString("base64");let Y="";for(let z=0;z<$.length;z++)Y+=String.fromCharCode($[z]);return btoa(Y)}catch($){throw new m0("Base64 Enconding Error")}}function s0(U){try{if(!/^[A-Za-z0-9+/]+={0,2}$/.test(U)||U.length%4!==0)throw new Error("invalid base64");if(hU())return new Uint8Array(Buffer.from(U,"base64"));let $=atob(U),Y=new Uint8Array($.length);for(let z=0;z<$.length;z++)Y[z]=$.charCodeAt(z);return Y}catch($){throw new P0(`Invalid Base64: length=${U.length}, content='${U.slice(0,12)}â€¦'`)}}function n(U){let $=U.length,Y=new Uint8Array($);return crypto.getRandomValues(Y),Array.from(Y,(z)=>String.fromCharCode(33+z%94)).join("")}function K0(U,$,Y,z){let J={low:0,middle:1,high:2}[$]??0,W=U<<5|(Y==="high"?1:0)<<2|J;return I0(new Uint8Array([v0,W]),z)}function Y0(U){if(U[0]!==v0)throw new t("Invalid input format. The input is unknown.");try{let $=U[1],Y=$>>5,z=$>>2&1?"high":"low",J=$&3,W=["low","middle","high"][J],Q=h.get(Y).saltLengths[z],G=U.slice(2,2+Q);return{scheme:Y,difficulty:W,saltStrength:z,salt:G,headerLen:2+Q}}catch($){throw new X0($ instanceof Error?$.message:String($))}}class A0{engine;chunkSize;buffer=new Uint8Array(0);constructor(U,$=524288){this.engine=U;this.chunkSize=$}toTransformStream(){return new TransformStream({transform:async(U,$)=>{await this.transform(await this.asUint8Array(U),$)},flush:async(U)=>this.flush(U)})}async transform(U,$){let Y=new Uint8Array(this.buffer.length+U.length);Y.set(this.buffer),Y.set(U,this.buffer.length);let z=0;while(Y.length-z>=this.chunkSize){let J=Y.slice(z,z+this.chunkSize);z+=this.chunkSize;let W=await this.engine.encryptChunk(J),Q=new Uint8Array(4);new DataView(Q.buffer).setUint32(0,W.length,!1);let G=new Uint8Array(4+W.length);G.set(Q),G.set(W,Q.length),$.enqueue(G)}this.buffer=Y.slice(z)}async flush(U){if(!this.buffer.length)return;let $=await this.engine.encryptChunk(this.buffer),Y=new Uint8Array(4);new DataView(Y.buffer).setUint32(0,$.length,!1);let z=new Uint8Array(4+$.length);z.set(Y),z.set($,4),U.enqueue(z),this.buffer=new Uint8Array(0)}async asUint8Array(U){if(U instanceof Uint8Array)return U;if(U instanceof ArrayBuffer)return new Uint8Array(U);return new Uint8Array(await U.arrayBuffer())}}class q0{engine;chunkSize;buffer=new Uint8Array(0);constructor(U,$=524288){this.engine=U;this.chunkSize=$}toTransformStream(){return new TransformStream({transform:async(U,$)=>{await this.transform(await this.asUint8Array(U),$)},flush:async(U)=>this.flush(U)})}async transform(U,$){let Y=new Uint8Array(this.buffer.length+U.length);Y.set(this.buffer),Y.set(U,this.buffer.length);let z=0;while(!0){if(Y.length-z<4)break;let J=new DataView(Y.buffer,Y.byteOffset+z,4).getUint32(0,!1);if(J>this.chunkSize*2)throw new d(`Frame length ${J} exceeds maximum allowed ${this.chunkSize*2}`);if(Y.length-z-4<J)break;z+=4;let W=Y.slice(z,z+J);z+=J;try{let Q=await this.engine.decryptChunk(W);$.enqueue(Q)}catch(Q){throw Q instanceof d?Q:new d("Decryption failed: Wrong passphrase or corrupted ciphertext")}}this.buffer=Y.slice(z)}async flush(U){await this.transform(new Uint8Array(0),U),this.buffer=new Uint8Array(0)}async asUint8Array(U){if(U instanceof Uint8Array)return U;if(U instanceof ArrayBuffer)return new Uint8Array(U);return new Uint8Array(await U.arrayBuffer())}}class V0{engine;chunkSize;constructor(U,$=524288){this.engine=U;this.chunkSize=$}encryptionStream(){let U=new A0(this.engine,this.chunkSize).toTransformStream();return{writable:U.writable,readable:U.readable}}decryptionStream(U){let $=U,Y=new TransformStream({transform(J,W){if($===0){W.enqueue(J);return}if(J.byteLength<=$){$-=J.byteLength;return}W.enqueue(J.slice($)),$=0}}),z=new q0(this.engine,this.chunkSize).toTransformStream();return{writable:Y.writable,readable:Y.readable.pipeThrough(z)}}async collect(U,$,Y=null){let z=U.pipeThrough($).getReader(),J=[];if(Y?.length)J.push(Y);try{while(!0){let{value:Z,done:X}=await z.read();if(X)break;J.push(Z)}await z.closed}finally{z.releaseLock()}let W=J.reduce((Z,X)=>Z+X.byteLength,0),Q=new Uint8Array(W),G=0;for(let Z of J)Q.set(Z,G),G+=Z.byteLength;return Q}}function dU(U=0,$=console.info){return{level:U,log(Y,z){if(Y<=U)$(`${Y}| ${z}`)}}}var nU=new WeakMap;class U0{static getEngine(U,$){let Y=nU.get(U);if(!Y)Y=new Map,nU.set(U,Y);let z=Y.get($);if(z)return z;let J=h.get($);return z={desc:J,cipher:new J.cipher(U),kdf:J.kdf,chunkSize:J.defaultChunkSize,provider:U},Y.set($,z),z}static async deriveKey(U,$,Y,z){try{let J=await U.kdf.derive($,Y,z,U.provider);$=n($),$=null,await U.cipher.setKey(J)}catch(J){let W=J instanceof Error?J.message:String(J);throw new o(W)}}}class z0{provider;v;cipher;kdf;chunkSize;stream;difficulty;saltStrength;engines=new Map;log;constructor(U,$={}){this.provider=U;this.v=h.get($.scheme??h.current.id),this.cipher=new this.v.cipher(U),this.kdf=this.v.kdf,this.chunkSize=$.chunkSize??this.v.defaultChunkSize,this.stream=new V0(this.cipher,this.chunkSize),this.difficulty=$.difficulty??"middle",this.saltStrength=$.saltStrength??"high",this.log=dU($.verbose??0,$.logger)}static async isEncrypted(U){try{return await z0.peekHeader(U),!0}catch{return!1}}static async headerDecode(U){let $=await z0.peekHeader(U),Y=Y0($);return{scheme:Y.scheme,difficulty:Y.difficulty,salt:H0(Y.salt),saltLength:Y.salt.byteLength}}setDifficulty(U){this.difficulty=U}getDifficulty(){return this.difficulty}setScheme(U){this.v=h.get(U),this.cipher=new this.v.cipher(this.provider),this.kdf=this.v.kdf,this.stream=new V0(this.cipher,this.chunkSize)}getScheme(){return this.v.id}setSaltDifficulty(U){this.saltStrength=U}getSaltDifficulty(){return this.saltStrength}setChunkSize(U){this.chunkSize=U,this.stream=new V0(this.cipher,this.chunkSize)}getChunkSize(){return this.chunkSize}setVerbose(U){this.log.level=U}getVerbose(){return this.log.level}async encryptText(U,$){try{this.log.log(1,`Start text encryption, scheme: ${this.getScheme()}`),this.log.log(2,"Deriving key for text encryption");let Y=this.genSalt();await this.deriveKey($,Y),$=n($),$=null,this.log.log(3,`Salt generated: ${H0(Y)}, KDF difficulty: ${this.difficulty}`),this.log.log(2,"Encrypting text data");let z=await this.cipher.encryptChunk(typeof U==="string"?new TextEncoder().encode(U):U);this.log.log(3,"Encoding header");let J=K0(this.v.id,this.difficulty,this.saltStrength,Y);this.log.log(3,"Encoding text");let W=H0(J,z);return this.log.log(1,"Decryption finished"),W}catch(Y){throw new T0(Y instanceof Error?Y.message:String(Y))}}async decryptText(U,$){try{this.log.log(1,`Start text decryption, Version ${this.getScheme()}`),this.log.log(3,"Start text decoding");let Y=s0(U);this.log.log(3,"Start header decoding"),await z0.peekHeader(U);let z=Y0(Y);this.log.log(3,"Trying to get engine");let J=U0.getEngine(this.provider,z.scheme);this.log.log(2,`Deriving key via engine for scheme: ${z.scheme}`),this.log.log(3,`Salt use: ${H0(z.salt)}, KDF difficulty: ${z.difficulty}`),await U0.deriveKey(J,$,z.salt,z.difficulty),$=n($),$=null,this.log.log(2,"Decrypting text data");let W=await J.cipher.decryptChunk(Y.slice(z.headerLen));this.log.log(3,"Decoding text");let Q=new TextDecoder().decode(W);return this.log.log(1,"Decryption finished"),Q}catch(Y){if(Y instanceof d||Y instanceof t||Y instanceof X0||Y instanceof P0||Y instanceof o)throw Y;throw new d("Decryption failed: wrong passphrase or corrupted ciphertext")}}async encryptFile(U,$){try{if(U.size===0){let W=this.genSalt();await this.deriveKey($,W),$=n($),$=null;let Q=K0(this.v.id,this.difficulty,this.saltStrength,W);return new Blob([Q],{type:"application/octet-stream"})}this.log.log(2,"Deriving key for file encryption");let Y=this.genSalt();await this.deriveKey($,Y),$=n($),$=null;let z=K0(this.v.id,this.difficulty,this.saltStrength,Y),J=await this.stream.collect(U.stream(),new A0(this.cipher,this.chunkSize).toTransformStream(),z);return new Blob([J],{type:"application/octet-stream"})}catch(Y){throw new T0(Y instanceof Error?Y.message:String(Y))}}async decryptFile(U,$){try{let Y=await z0.peekHeader(U),z=Y0(Y),J=U0.getEngine(this.provider,z.scheme);if(await U0.deriveKey(J,$,z.salt,z.difficulty),$=n($),$=null,U.size===z.headerLen)return new Blob([],{type:"application/octet-stream"});this.log.log(2,"Decrypting file data");let Q=await new V0(J.cipher,J.chunkSize).collect(U.slice(z.headerLen).stream(),new q0(J.cipher,J.chunkSize).toTransformStream());return new Blob([Q],{type:"application/octet-stream"})}catch(Y){if(Y instanceof d)throw Y;throw new d(Y instanceof Error?Y.message:String(Y))}}async createEncryptionStream(U){this.log.log(2,"Deriving key for stream encryption");let $=this.genSalt();await this.deriveKey(U,$),U=n(U),U=null;let Y=K0(this.v.id,this.difficulty,this.saltStrength,$),z=this.stream.encryptionStream();return{header:Y,writable:z.writable,readable:z.readable}}async createDecryptionStream(U){let $=this,Y=new Uint8Array(0),z=null;async function J(W,Q){let G=W.getReader();while(!0){let{value:Z,done:X}=await G.read();if(X)break;Q.enqueue(Z)}}return new TransformStream({async transform(W,Q){if(!z){if(Y=I0(Y,W),Y.length<2)return;let Z=Y.slice(0,30),{salt:X,difficulty:V}=Y0(Z),P=Y[1]>>5,S=Y[1]>>2&1?"high":"low",I=2+h.get(P).saltLengths[S];if(Y.length<I)return;let H=U0.getEngine($.provider,P);await U0.deriveKey(H,U,X,V),U=n(U),U=null,z=new q0(H.cipher,H.chunkSize).toTransformStream(),J(z.readable,Q);let F=Y.slice(I);if(F.length){let A=z.writable.getWriter();await A.write(F),A.releaseLock()}return}let G=z.writable.getWriter();await G.write(W),G.releaseLock()},async flush(){if(z){let W=z.writable.getWriter();await W.close(),W.releaseLock()}}})}async deriveKey(U,$,Y=this.difficulty){let z=performance.now();try{let J=await this.kdf.derive(U,$,Y,this.provider);U=n(U),U=null,await this.cipher.setKey(J),this.log.log(3,`Key derivation completed in ${(performance.now()-z).toFixed(1)} ms`)}catch(J){throw new o(J instanceof Error?J.message:String(J))}}genSalt(){let U=this.v.saltLengths[this.saltStrength];return this.provider.getRandomValues(new Uint8Array(U))}static async peekHeader(U){if(typeof U==="string")U=s0(U);if(U instanceof Uint8Array){if(U.length<2)throw new t("Input too short");let{headerLen:$}=Y0(U.length>=16?U:Uint8Array.from(U));if(U.length<$)throw new t("Incomplete header");return U.slice(0,$)}if(U instanceof Blob){let $=new Uint8Array(await U.slice(0,2).arrayBuffer());if($[0]!==1)throw new t("Invalid input format. The input is unknown.");let Y=$[1],z=Y>>5,J=Y>>2&1?"high":"low",W=h.get(z).saltLengths[J],Q=new Uint8Array(await U.slice(0,2+W).arrayBuffer());return Y0(Q),Q}throw new X0("Unsupported input type")}}import{webcrypto as n$,randomFillSync as u$}from"node:crypto";var uU={subtle:n$.subtle,getRandomValues(U){return u$(U),U},isNode:!0};function qz(U){return new z0(uU,U)}export{qz as createCryptit};

//# debugId=064BB76A91C1985364756E2164756E21
