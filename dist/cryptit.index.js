import{createRequire as Q$}from"node:module";var e0=Object.create;var{getPrototypeOf:U$,defineProperty:J0,getOwnPropertyNames:$$}=Object;var J$=Object.prototype.hasOwnProperty;var gU=(U,$,J)=>{J=U!=null?e0(U$(U)):{};let Q=$||!U||!U.__esModule?J0(J,"default",{value:U,enumerable:!0}):J;for(let W of $$(U))if(!J$.call(Q,W))J0(Q,W,{get:()=>U[W],enumerable:!0});return Q};var FU=(U,$)=>()=>($||U(($={exports:{}}).exports,$),$.exports);var u=Q$(import.meta.url);var S0=FU((TJ,T0)=>{var vU=/^[a-z0-9-]{1,32}$/,_U=/^[a-z0-9-]{1,32}$/,mU=/^[a-zA-Z0-9/+.-]+$/,z0=/^([a-zA-Z0-9/+.-]+|)$/,T$=/^((-)?[1-9]\d*|0)$/,xU=/^v=(\d+)$/;function S$(U){return HU(U).map(($)=>[$,U[$]].join("=")).join(",")}function A$(U){let $={};return U.split(",").forEach((J)=>{let Q=J.split("=");if(Q.length<2)throw new TypeError("params must be in the format name=value");$[Q.shift()]=Q.join("=")}),$}function HU(U){return Object.keys(U)}function M0(U){if(typeof Object.values==="function")return Object.values(U);return HU(U).map(($)=>U[$])}function F$(U){let $=[""];if(typeof U!=="object"||U===null)throw new TypeError("opts must be an object");if(typeof U.id!=="string")throw new TypeError("id must be a string");if(!vU.test(U.id))throw new TypeError(`id must satisfy ${vU}`);if($.push(U.id),typeof U.version!=="undefined"){if(typeof U.version!=="number"||U.version<0||!Number.isInteger(U.version))throw new TypeError("version must be a positive integer number");$.push(`v=${U.version}`)}if(typeof U.params!=="undefined"){if(typeof U.params!=="object"||U.params===null)throw new TypeError("params must be an object");let Q=HU(U.params);if(!Q.every((Y)=>_U.test(Y)))throw new TypeError(`params names must satisfy ${_U}`);Q.forEach((Y)=>{if(typeof U.params[Y]==="number")U.params[Y]=U.params[Y].toString();else if(Buffer.isBuffer(U.params[Y]))U.params[Y]=U.params[Y].toString("base64").split("=")[0]});let W=M0(U.params);if(!W.every((Y)=>typeof Y==="string"))throw new TypeError("params values must be strings");if(!W.every((Y)=>mU.test(Y)))throw new TypeError(`params values must satisfy ${mU}`);let Z=S$(U.params);$.push(Z)}if(typeof U.salt!=="undefined"){if(!Buffer.isBuffer(U.salt))throw new TypeError("salt must be a Buffer");if($.push(U.salt.toString("base64").split("=")[0]),typeof U.hash!=="undefined"){if(!Buffer.isBuffer(U.hash))throw new TypeError("hash must be a Buffer");$.push(U.hash.toString("base64").split("=")[0])}}return $.join("$")}function D$(U){if(typeof U!=="string"||U==="")throw new TypeError("pchstr must be a non-empty string");if(U[0]!=="$")throw new TypeError("pchstr must contain a $ as first char");let $=U.split("$");$.shift();let J=5;if(!xU.test($[1]))J--;if($.length>J)throw new TypeError(`pchstr contains too many fileds: ${$.length}/${J}`);let Q=$.shift();if(!vU.test(Q))throw new TypeError(`id must satisfy ${vU}`);let W;if(xU.test($[0]))W=parseInt($.shift().match(xU)[1],10);let Z,Y;if(z0.test($[$.length-1]))if($.length>1&&z0.test($[$.length-2]))Z=Buffer.from($.pop(),"base64"),Y=Buffer.from($.pop(),"base64");else Y=Buffer.from($.pop(),"base64");let V;if($.length>0){let q=$.pop();if(V=A$(q),!HU(V).every((K)=>_U.test(K)))throw new TypeError(`params names must satisfy ${_U}`);if(!M0(V).every((K)=>mU.test(K)))throw new TypeError(`params values must satisfy ${mU}`);HU(V).forEach((K)=>{V[K]=T$.test(V[K])?parseInt(V[K],10):V[K]})}if($.length>0)throw new TypeError(`pchstr contains unrecognized fileds: ${$}`);let G={id:Q};if(W)G.version=W;if(V)G.params=V;if(Y)G.salt=Y;if(Z)G.hash=Z;return G}T0.exports={serialize:F$,deserialize:D$}});var b0=FU((SJ,f0)=>{var B0=u("fs"),t=u("path"),R0=u("os"),E0=typeof __webpack_require__==="function"?__non_webpack_require__:u,B$=process.config&&process.config.variables||{},R$=!!process.env.PREBUILDS_ONLY,A0=process.versions.modules,iU=C$()?"electron":L$()?"node-webkit":"node",oU=process.env.npm_config_arch||R0.arch(),rU=process.env.npm_config_platform||R0.platform(),L0=process.env.LIBC||(j$(rU)?"musl":"glibc"),sU=process.env.ARM_VERSION||(oU==="arm64"?"8":B$.arm_version)||"",C0=(process.versions.uv||"").split(".")[0];f0.exports=x;function x(U){return E0(x.resolve(U))}x.resolve=x.path=function(U){U=t.resolve(U||".");try{var $=E0(t.join(U,"package.json")).name.toUpperCase().replace(/-/g,"_");if(process.env[$+"_PREBUILD"])U=process.env[$+"_PREBUILD"]}catch(G){}if(!R$){var J=F0(t.join(U,"build/Release"),D0);if(J)return J;var Q=F0(t.join(U,"build/Debug"),D0);if(Q)return Q}var W=V(U);if(W)return W;var Z=V(t.dirname(process.execPath));if(Z)return Z;var Y=["platform="+rU,"arch="+oU,"runtime="+iU,"abi="+A0,"uv="+C0,sU?"armv="+sU:"","libc="+L0,"node="+process.versions.node,process.versions.electron?"electron="+process.versions.electron:"",typeof __webpack_require__==="function"?"webpack=true":""].filter(Boolean).join(" ");throw new Error("No native build was found for "+Y+`
    loaded from: `+U+`
`);function V(G){var q=aU(t.join(G,"prebuilds")).map(j0),I=q.filter(v0(rU,oU)).sort(_0)[0];if(!I)return;var N=t.join(G,"prebuilds",I.name),K=aU(N).map(m0),H=K.filter(k0(iU,A0)),w=H.sort(y0(iU))[0];if(w)return t.join(N,w.file)}};function aU(U){try{return B0.readdirSync(U)}catch($){return[]}}function F0(U,$){var J=aU(U).filter($);return J[0]&&t.join(U,J[0])}function D0(U){return/\.node$/.test(U)}function j0(U){var $=U.split("-");if($.length!==2)return;var J=$[0],Q=$[1].split("+");if(!J)return;if(!Q.length)return;if(!Q.every(Boolean))return;return{name:U,platform:J,architectures:Q}}function v0(U,$){return function(J){if(J==null)return!1;if(J.platform!==U)return!1;return J.architectures.includes($)}}function _0(U,$){return U.architectures.length-$.architectures.length}function m0(U){var $=U.split("."),J=$.pop(),Q={file:U,specificity:0};if(J!=="node")return;for(var W=0;W<$.length;W++){var Z=$[W];if(Z==="node"||Z==="electron"||Z==="node-webkit")Q.runtime=Z;else if(Z==="napi")Q.napi=!0;else if(Z.slice(0,3)==="abi")Q.abi=Z.slice(3);else if(Z.slice(0,2)==="uv")Q.uv=Z.slice(2);else if(Z.slice(0,4)==="armv")Q.armv=Z.slice(4);else if(Z==="glibc"||Z==="musl")Q.libc=Z;else continue;Q.specificity++}return Q}function k0(U,$){return function(J){if(J==null)return!1;if(J.runtime&&J.runtime!==U&&!E$(J))return!1;if(J.abi&&J.abi!==$&&!J.napi)return!1;if(J.uv&&J.uv!==C0)return!1;if(J.armv&&J.armv!==sU)return!1;if(J.libc&&J.libc!==L0)return!1;return!0}}function E$(U){return U.runtime==="node"&&U.napi}function y0(U){return function($,J){if($.runtime!==J.runtime)return $.runtime===U?-1:1;else if($.abi!==J.abi)return $.abi?-1:1;else if($.specificity!==J.specificity)return $.specificity>J.specificity?-1:1;else return 0}}function L$(){return!!(process.versions&&process.versions.nw)}function C$(){if(process.versions&&process.versions.electron)return!0;if(process.env.ELECTRON_RUN_AS_NODE)return!0;return typeof window!=="undefined"&&window.process&&window.process.type==="renderer"}function j$(U){return U==="linux"&&B0.existsSync("/etc/alpine-release")}x.parseTags=m0;x.matchTags=k0;x.compareTags=y0;x.parseTuple=j0;x.matchTuple=v0;x.compareTuples=_0});var g0=FU((FJ,eU)=>{var tU=typeof __webpack_require__==="function"?__non_webpack_require__:u;if(typeof tU.addon==="function")eU.exports=tU.addon.bind(tU);else eU.exports=b0()});var d0=FU((l$,YU)=>{var __dirname="/Users/maxim/Projects/Private/Sites/cryptit/node_modules/argon2",BJ=u("node:assert"),{randomBytes:v$,timingSafeEqual:_$}=u("node:crypto"),{promisify:m$}=u("node:util"),{deserialize:c0,serialize:k$}=S0(),y$=g0(),{hash:n0}=y$(__dirname),f$=m$(v$);l$.argon2d=0;l$.argon2i=1;l$.argon2id=2;var OU=Object.freeze({argon2d:0,argon2i:1,argon2id:2}),b$=Object.freeze({[OU.argon2d]:"argon2d",[OU.argon2i]:"argon2i",[OU.argon2id]:"argon2id"}),l0={hashLength:32,timeCost:3,memoryCost:65536,parallelism:4,type:2,version:19};async function g$(U,$){let{raw:J,salt:Q,...W}={...l0,...$};if(W.hashLength>4294967295)throw new RangeError("Hash length is too large");if(W.memoryCost>4294967295)throw new RangeError("Memory cost is too large");if(W.timeCost>4294967295)throw new RangeError("Time cost is too large");if(W.parallelism>16777215)throw new RangeError("Parallelism is too large");Q=Q??await f$(16);let{hashLength:Z,secret:Y=Buffer.alloc(0),type:V,version:G,memoryCost:q,timeCost:I,parallelism:N,associatedData:K=Buffer.alloc(0)}=W,H=await n0({password:Buffer.from(U),salt:Q,secret:Y,data:K,hashLength:Z,m:q,t:I,p:N,version:G,type:V});if(J)return H;return k$({id:b$[V],version:G,params:{m:q,t:I,p:N,...K.byteLength>0?{data:K}:{}},salt:Q,hash:H})}l$.hash=g$;function c$(U,$={}){let{memoryCost:J,timeCost:Q,parallelism:W,version:Z}={...l0,...$},{version:Y,params:{m:V,t:G,p:q}}=c0(U);return+Y!==+Z||+V!==+J||+G!==+Q||+q!==+W}l$.needsRehash=c$;async function n$(U,$,J={}){let{id:Q,...W}=c0(U);if(!(Q in OU))return!1;let{version:Z=16,params:{m:Y,t:V,p:G,data:q=""},salt:I,hash:N}=W,{secret:K=Buffer.alloc(0)}=J;return _$(await n0({password:Buffer.from($),salt:I,secret:K,data:Buffer.from(q,"base64"),hashLength:N.byteLength,m:+Y,t:+V,p:+G,version:+Z,type:OU[Q]}),N)}l$.verify=n$});class o extends Error{constructor(U){super(U);Object.setPrototypeOf(this,new.target.prototype),this.name=new.target.name,this.stack=void 0}}class p extends o{}class wU extends o{}class cU extends o{}class DU extends o{}class NU extends o{}class r extends o{}class BU extends o{}class d extends o{}class l{static byId=new Map;static register(U){if(this.byId.has(U.id))throw new DU(`Scheme ${U.id} already registered`);this.byId.set(U.id,U)}static get(U){let $=this.byId.get(U);if(!$)throw new DU(`Unknown scheme: ${U}`);return $}static get current(){return this.get(0)}}class QU{p;static IV_LENGTH=12;IV_LENGTH=QU.IV_LENGTH;key;constructor(U){this.p=U}async setKey(U){this.key=U}async encryptChunk(U){let $=this.p.getRandomValues(new Uint8Array(QU.IV_LENGTH)),J=new Uint8Array(await this.p.subtle.encrypt({name:"AES-GCM",iv:$},this.key,U));U.fill(0);let Q=new Uint8Array($.length+J.length);return Q.set($),Q.set(J,$.length),Q}async decryptChunk(U){let $=U.slice(0,QU.IV_LENGTH),J=U.slice(QU.IV_LENGTH);try{let Q=await this.p.subtle.decrypt({name:"AES-GCM",iv:$},this.key,J);return new Uint8Array(Q)}catch{throw new d("Decryption failed: wrong passphrase or corrupted ciphertext")}}zeroKey(){}}/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function W0(U){return U instanceof Uint8Array||ArrayBuffer.isView(U)&&U.constructor.name==="Uint8Array"}function RU(U){if(typeof U!=="boolean")throw new Error(`boolean expected, not ${U}`)}function EU(U){if(!Number.isSafeInteger(U)||U<0)throw new Error("positive integer expected, got "+U)}function n(U,...$){if(!W0(U))throw new Error("Uint8Array expected");if($.length>0&&!$.includes(U.length))throw new Error("Uint8Array expected of length "+$+", got length="+U.length)}function nU(U,$=!0){if(U.destroyed)throw new Error("Hash instance has been destroyed");if($&&U.finished)throw new Error("Hash#digest() has already been called")}function Y0(U,$){n(U);let J=$.outputLen;if(U.length<J)throw new Error("digestInto() expects output buffer of length at least "+J)}function s(U){return new Uint32Array(U.buffer,U.byteOffset,Math.floor(U.byteLength/4))}function a(...U){for(let $=0;$<U.length;$++)U[$].fill(0)}function W$(U){return new DataView(U.buffer,U.byteOffset,U.byteLength)}var Y$=(()=>new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68)();function Z$(U){if(typeof U!=="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(U))}function LU(U){if(typeof U==="string")U=Z$(U);else if(W0(U))U=CU(U);else throw new Error("Uint8Array expected, got "+typeof U);return U}function Z0(U,$){if($==null||typeof $!=="object")throw new Error("options must be defined");return Object.assign(U,$)}function V0(U,$){if(U.length!==$.length)return!1;let J=0;for(let Q=0;Q<U.length;Q++)J|=U[Q]^$[Q];return J===0}var lU=(U,$)=>{function J(Q,...W){if(n(Q),!Y$)throw new Error("Non little-endian hardware is not yet supported");if(U.nonceLength!==void 0){let I=W[0];if(!I)throw new Error("nonce / iv required");if(U.varSizeNonce)n(I);else n(I,U.nonceLength)}let Z=U.tagLength;if(Z&&W[1]!==void 0)n(W[1]);let Y=$(Q,...W),V=(I,N)=>{if(N!==void 0){if(I!==2)throw new Error("cipher output not supported");n(N)}},G=!1;return{encrypt(I,N){if(G)throw new Error("cannot encrypt() twice with same key + nonce");return G=!0,n(I),V(Y.encrypt.length,N),Y.encrypt(I,N)},decrypt(I,N){if(n(I),Z&&I.length<Z)throw new Error("invalid ciphertext length: smaller than tagLength="+Z);return V(Y.decrypt.length,N),Y.decrypt(I,N)}}}return Object.assign(J,U),J};function dU(U,$,J=!0){if($===void 0)return new Uint8Array(U);if($.length!==U)throw new Error("invalid output length, expected "+U+", got: "+$.length);if(J&&!V$($))throw new Error("invalid output, must be aligned");return $}function Q0(U,$,J,Q){if(typeof U.setBigUint64==="function")return U.setBigUint64($,J,Q);let W=BigInt(32),Z=BigInt(4294967295),Y=Number(J>>W&Z),V=Number(J&Z),G=Q?4:0,q=Q?0:4;U.setUint32($+G,Y,Q),U.setUint32($+q,V,Q)}function G0(U,$,J){RU(J);let Q=new Uint8Array(16),W=W$(Q);return Q0(W,0,BigInt($),J),Q0(W,8,BigInt(U),J),Q}function V$(U){return U.byteOffset%4===0}function CU(U){return Uint8Array.from(U)}var X0=(U)=>Uint8Array.from(U.split("").map(($)=>$.charCodeAt(0))),G$=X0("expand 16-byte k"),q$=X0("expand 32-byte k"),X$=s(G$),I$=s(q$);function X(U,$){return U<<$|U>>>32-$}function uU(U){return U.byteOffset%4===0}var jU=64,N$=16,I0=4294967295,q0=new Uint32Array;function K$(U,$,J,Q,W,Z,Y,V){let G=W.length,q=new Uint8Array(jU),I=s(q),N=uU(W)&&uU(Z),K=N?s(W):q0,H=N?s(Z):q0;for(let w=0;w<G;Y++){if(U($,J,Q,I,Y,V),Y>=I0)throw new Error("arx: counter overflow");let O=Math.min(jU,G-w);if(N&&O===jU){let z=w/4;if(w%4!==0)throw new Error("arx: invalid block position");for(let M=0,T;M<N$;M++)T=z+M,H[T]=K[T]^I[M];w+=jU;continue}for(let z=0,M;z<O;z++)M=w+z,Z[M]=W[M]^q[z];w+=O}}function hU(U,$){let{allowShortKeys:J,extendNonceFn:Q,counterLength:W,counterRight:Z,rounds:Y}=Z0({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},$);if(typeof U!=="function")throw new Error("core must be a function");return EU(W),EU(Y),RU(Z),RU(J),(V,G,q,I,N=0)=>{n(V),n(G),n(q);let K=q.length;if(I===void 0)I=new Uint8Array(K);if(n(I),EU(N),N<0||N>=I0)throw new Error("arx: counter overflow");if(I.length<K)throw new Error(`arx: output (${I.length}) is shorter than data (${K})`);let H=[],w=V.length,O,z;if(w===32)H.push(O=CU(V)),z=I$;else if(w===16&&J)O=new Uint8Array(32),O.set(V),O.set(V,16),z=X$,H.push(O);else throw new Error(`arx: invalid 32-byte key, got length=${w}`);if(!uU(G))H.push(G=CU(G));let M=s(O);if(Q){if(G.length!==24)throw new Error("arx: extended nonce must be 24 bytes");Q(z,M,s(G.subarray(0,16)),M),G=G.subarray(16)}let T=16-W;if(T!==G.length)throw new Error(`arx: nonce must be ${T} or 16 bytes`);if(T!==12){let f=new Uint8Array(12);f.set(G,Z?0:12-G.length),G=f,H.push(G)}let m=s(G);return K$(U,z,M,m,q,I,N,Y),a(...H),I}}var b=(U,$)=>U[$++]&255|(U[$++]&255)<<8;class N0{constructor(U){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,U=LU(U),n(U,32);let $=b(U,0),J=b(U,2),Q=b(U,4),W=b(U,6),Z=b(U,8),Y=b(U,10),V=b(U,12),G=b(U,14);this.r[0]=$&8191,this.r[1]=($>>>13|J<<3)&8191,this.r[2]=(J>>>10|Q<<6)&7939,this.r[3]=(Q>>>7|W<<9)&8191,this.r[4]=(W>>>4|Z<<12)&255,this.r[5]=Z>>>1&8190,this.r[6]=(Z>>>14|Y<<2)&8191,this.r[7]=(Y>>>11|V<<5)&8065,this.r[8]=(V>>>8|G<<8)&8191,this.r[9]=G>>>5&127;for(let q=0;q<8;q++)this.pad[q]=b(U,16+2*q)}process(U,$,J=!1){let Q=J?0:2048,{h:W,r:Z}=this,Y=Z[0],V=Z[1],G=Z[2],q=Z[3],I=Z[4],N=Z[5],K=Z[6],H=Z[7],w=Z[8],O=Z[9],z=b(U,$+0),M=b(U,$+2),T=b(U,$+4),m=b(U,$+6),f=b(U,$+8),UU=b(U,$+10),g=b(U,$+12),c=b(U,$+14),S=W[0]+(z&8191),A=W[1]+((z>>>13|M<<3)&8191),F=W[2]+((M>>>10|T<<6)&8191),D=W[3]+((T>>>7|m<<9)&8191),B=W[4]+((m>>>4|f<<12)&8191),R=W[5]+(f>>>1&8191),E=W[6]+((f>>>14|UU<<2)&8191),L=W[7]+((UU>>>11|g<<5)&8191),C=W[8]+((g>>>8|c<<8)&8191),j=W[9]+(c>>>5|Q),P=0,_=P+S*Y+A*(5*O)+F*(5*w)+D*(5*H)+B*(5*K);P=_>>>13,_&=8191,_+=R*(5*N)+E*(5*I)+L*(5*q)+C*(5*G)+j*(5*V),P+=_>>>13,_&=8191;let k=P+S*V+A*Y+F*(5*O)+D*(5*w)+B*(5*H);P=k>>>13,k&=8191,k+=R*(5*K)+E*(5*N)+L*(5*I)+C*(5*q)+j*(5*G),P+=k>>>13,k&=8191;let y=P+S*G+A*V+F*Y+D*(5*O)+B*(5*w);P=y>>>13,y&=8191,y+=R*(5*H)+E*(5*K)+L*(5*N)+C*(5*I)+j*(5*q),P+=y>>>13,y&=8191;let v=P+S*q+A*G+F*V+D*Y+B*(5*O);P=v>>>13,v&=8191,v+=R*(5*w)+E*(5*H)+L*(5*K)+C*(5*N)+j*(5*I),P+=v>>>13,v&=8191;let i=P+S*I+A*q+F*G+D*V+B*Y;P=i>>>13,i&=8191,i+=R*(5*O)+E*(5*w)+L*(5*H)+C*(5*K)+j*(5*N),P+=i>>>13,i&=8191;let VU=P+S*N+A*I+F*q+D*G+B*V;P=VU>>>13,VU&=8191,VU+=R*Y+E*(5*O)+L*(5*w)+C*(5*H)+j*(5*K),P+=VU>>>13,VU&=8191;let GU=P+S*K+A*N+F*I+D*q+B*G;P=GU>>>13,GU&=8191,GU+=R*V+E*Y+L*(5*O)+C*(5*w)+j*(5*H),P+=GU>>>13,GU&=8191;let qU=P+S*H+A*K+F*N+D*I+B*q;P=qU>>>13,qU&=8191,qU+=R*G+E*V+L*Y+C*(5*O)+j*(5*w),P+=qU>>>13,qU&=8191;let XU=P+S*w+A*H+F*K+D*N+B*I;P=XU>>>13,XU&=8191,XU+=R*q+E*G+L*V+C*Y+j*(5*O),P+=XU>>>13,XU&=8191;let IU=P+S*O+A*w+F*H+D*K+B*N;P=IU>>>13,IU&=8191,IU+=R*I+E*q+L*G+C*V+j*Y,P+=IU>>>13,IU&=8191,P=(P<<2)+P|0,P=P+_|0,_=P&8191,P=P>>>13,k+=P,W[0]=_,W[1]=k,W[2]=y,W[3]=v,W[4]=i,W[5]=VU,W[6]=GU,W[7]=qU,W[8]=XU,W[9]=IU}finalize(){let{h:U,pad:$}=this,J=new Uint16Array(10),Q=U[1]>>>13;U[1]&=8191;for(let Y=2;Y<10;Y++)U[Y]+=Q,Q=U[Y]>>>13,U[Y]&=8191;U[0]+=Q*5,Q=U[0]>>>13,U[0]&=8191,U[1]+=Q,Q=U[1]>>>13,U[1]&=8191,U[2]+=Q,J[0]=U[0]+5,Q=J[0]>>>13,J[0]&=8191;for(let Y=1;Y<10;Y++)J[Y]=U[Y]+Q,Q=J[Y]>>>13,J[Y]&=8191;J[9]-=8192;let W=(Q^1)-1;for(let Y=0;Y<10;Y++)J[Y]&=W;W=~W;for(let Y=0;Y<10;Y++)U[Y]=U[Y]&W|J[Y];U[0]=(U[0]|U[1]<<13)&65535,U[1]=(U[1]>>>3|U[2]<<10)&65535,U[2]=(U[2]>>>6|U[3]<<7)&65535,U[3]=(U[3]>>>9|U[4]<<4)&65535,U[4]=(U[4]>>>12|U[5]<<1|U[6]<<14)&65535,U[5]=(U[6]>>>2|U[7]<<11)&65535,U[6]=(U[7]>>>5|U[8]<<8)&65535,U[7]=(U[8]>>>8|U[9]<<5)&65535;let Z=U[0]+$[0];U[0]=Z&65535;for(let Y=1;Y<8;Y++)Z=(U[Y]+$[Y]|0)+(Z>>>16)|0,U[Y]=Z&65535;a(J)}update(U){nU(this),U=LU(U),n(U);let{buffer:$,blockLen:J}=this,Q=U.length;for(let W=0;W<Q;){let Z=Math.min(J-this.pos,Q-W);if(Z===J){for(;J<=Q-W;W+=J)this.process(U,W);continue}if($.set(U.subarray(W,W+Z),this.pos),this.pos+=Z,W+=Z,this.pos===J)this.process($,0,!1),this.pos=0}return this}destroy(){a(this.h,this.r,this.buffer,this.pad)}digestInto(U){nU(this),Y0(U,this),this.finished=!0;let{buffer:$,h:J}=this,{pos:Q}=this;if(Q){$[Q++]=1;for(;Q<16;Q++)$[Q]=0;this.process($,0,!0)}this.finalize();let W=0;for(let Z=0;Z<8;Z++)U[W++]=J[Z]>>>0,U[W++]=J[Z]>>>8;return U}digest(){let{buffer:U,outputLen:$}=this;this.digestInto(U);let J=U.slice(0,$);return this.destroy(),J}}function P$(U){let $=(Q,W)=>U(W).update(LU(Q)).digest(),J=U(new Uint8Array(32));return $.outputLen=J.outputLen,$.blockLen=J.blockLen,$.create=(Q)=>U(Q),$}var K0=P$((U)=>new N0(U));function H0(U,$,J,Q,W,Z=20){let Y=U[0],V=U[1],G=U[2],q=U[3],I=$[0],N=$[1],K=$[2],H=$[3],w=$[4],O=$[5],z=$[6],M=$[7],T=W,m=J[0],f=J[1],UU=J[2],g=Y,c=V,S=G,A=q,F=I,D=N,B=K,R=H,E=w,L=O,C=z,j=M,P=T,_=m,k=f,y=UU;for(let i=0;i<Z;i+=2)g=g+F|0,P=X(P^g,16),E=E+P|0,F=X(F^E,12),g=g+F|0,P=X(P^g,8),E=E+P|0,F=X(F^E,7),c=c+D|0,_=X(_^c,16),L=L+_|0,D=X(D^L,12),c=c+D|0,_=X(_^c,8),L=L+_|0,D=X(D^L,7),S=S+B|0,k=X(k^S,16),C=C+k|0,B=X(B^C,12),S=S+B|0,k=X(k^S,8),C=C+k|0,B=X(B^C,7),A=A+R|0,y=X(y^A,16),j=j+y|0,R=X(R^j,12),A=A+R|0,y=X(y^A,8),j=j+y|0,R=X(R^j,7),g=g+D|0,y=X(y^g,16),C=C+y|0,D=X(D^C,12),g=g+D|0,y=X(y^g,8),C=C+y|0,D=X(D^C,7),c=c+B|0,P=X(P^c,16),j=j+P|0,B=X(B^j,12),c=c+B|0,P=X(P^c,8),j=j+P|0,B=X(B^j,7),S=S+R|0,_=X(_^S,16),E=E+_|0,R=X(R^E,12),S=S+R|0,_=X(_^S,8),E=E+_|0,R=X(R^E,7),A=A+F|0,k=X(k^A,16),L=L+k|0,F=X(F^L,12),A=A+F|0,k=X(k^A,8),L=L+k|0,F=X(F^L,7);let v=0;Q[v++]=Y+g|0,Q[v++]=V+c|0,Q[v++]=G+S|0,Q[v++]=q+A|0,Q[v++]=I+F|0,Q[v++]=N+D|0,Q[v++]=K+B|0,Q[v++]=H+R|0,Q[v++]=w+E|0,Q[v++]=O+L|0,Q[v++]=z+C|0,Q[v++]=M+j|0,Q[v++]=T+P|0,Q[v++]=m+_|0,Q[v++]=f+k|0,Q[v++]=UU+y|0}function w$(U,$,J,Q){let W=U[0],Z=U[1],Y=U[2],V=U[3],G=$[0],q=$[1],I=$[2],N=$[3],K=$[4],H=$[5],w=$[6],O=$[7],z=J[0],M=J[1],T=J[2],m=J[3];for(let UU=0;UU<20;UU+=2)W=W+G|0,z=X(z^W,16),K=K+z|0,G=X(G^K,12),W=W+G|0,z=X(z^W,8),K=K+z|0,G=X(G^K,7),Z=Z+q|0,M=X(M^Z,16),H=H+M|0,q=X(q^H,12),Z=Z+q|0,M=X(M^Z,8),H=H+M|0,q=X(q^H,7),Y=Y+I|0,T=X(T^Y,16),w=w+T|0,I=X(I^w,12),Y=Y+I|0,T=X(T^Y,8),w=w+T|0,I=X(I^w,7),V=V+N|0,m=X(m^V,16),O=O+m|0,N=X(N^O,12),V=V+N|0,m=X(m^V,8),O=O+m|0,N=X(N^O,7),W=W+q|0,m=X(m^W,16),w=w+m|0,q=X(q^w,12),W=W+q|0,m=X(m^W,8),w=w+m|0,q=X(q^w,7),Z=Z+I|0,z=X(z^Z,16),O=O+z|0,I=X(I^O,12),Z=Z+I|0,z=X(z^Z,8),O=O+z|0,I=X(I^O,7),Y=Y+N|0,M=X(M^Y,16),K=K+M|0,N=X(N^K,12),Y=Y+N|0,M=X(M^Y,8),K=K+M|0,N=X(N^K,7),V=V+G|0,T=X(T^V,16),H=H+T|0,G=X(G^H,12),V=V+G|0,T=X(T^V,8),H=H+T|0,G=X(G^H,7);let f=0;Q[f++]=W,Q[f++]=Z,Q[f++]=Y,Q[f++]=V,Q[f++]=z,Q[f++]=M,Q[f++]=T,Q[f++]=m}var H$=hU(H0,{counterRight:!1,counterLength:4,allowShortKeys:!1}),O$=hU(H0,{counterRight:!1,counterLength:8,extendNonceFn:w$,allowShortKeys:!1});var z$=new Uint8Array(16),P0=(U,$)=>{U.update($);let J=$.length%16;if(J)U.update(z$.subarray(J))},M$=new Uint8Array(32);function w0(U,$,J,Q,W){let Z=U($,J,M$),Y=K0.create(Z);if(W)P0(Y,W);P0(Y,Q);let V=G0(Q.length,W?W.length:0,!0);Y.update(V);let G=Y.digest();return a(Z,V),G}var O0=(U)=>($,J,Q)=>{return{encrypt(Z,Y){let V=Z.length;Y=dU(V+16,Y,!1),Y.set(Z);let G=Y.subarray(0,-16);U($,J,G,G,1);let q=w0(U,$,J,G,Q);return Y.set(q,V),a(q),Y},decrypt(Z,Y){Y=dU(Z.length-16,Y,!1);let V=Z.subarray(0,-16),G=Z.subarray(-16),q=w0(U,$,J,V,Q);if(!V0(G,q))throw new Error("invalid tag");return Y.set(Z.subarray(0,-16)),U($,J,Y,Y,1),a(q),Y}}},wJ=lU({blockSize:64,nonceLength:12,tagLength:16},O0(H$)),pU=lU({blockSize:64,nonceLength:24,tagLength:16},O0(O$));class WU{p;static IV_LENGTH=24;IV_LENGTH=WU.IV_LENGTH;key;constructor(U){this.p=U}async setKey(U){this.key=new Uint8Array(await this.p.subtle.exportKey("raw",U))}async encryptChunk(U){let $=this.p.getRandomValues(new Uint8Array(WU.IV_LENGTH)),Q=pU(this.key,$).encrypt(U);U.fill(0);let W=new Uint8Array($.length+Q.length);return W.set($,0),W.set(Q,$.length),W}async decryptChunk(U){let $=U.slice(0,WU.IV_LENGTH),J=U.slice(WU.IV_LENGTH),Q=pU(this.key,$);try{return Q.decrypt(J)}catch{throw new d("Decryption failed: wrong passphrase or corrupted ciphertext")}}zeroKey(){this.key.fill(0)}}import*as kU from"argon2-browser";async function o$(){if(typeof window!=="undefined")return;if(globalThis.loadArgon2WasmModule)return;try{let{createRequire:U}=await import("node:module"),{readFile:$}=await import("node:fs/promises"),J=U(import.meta.url),Q=J.resolve("argon2-browser/dist/argon2.js"),W=J.resolve("argon2-browser/dist/argon2.wasm");globalThis.loadArgon2WasmModule=async()=>{let Z=new Uint8Array(await $(W));return globalThis.Module={wasmBinary:Z,locateFile:(Y)=>Y==="argon2.wasm"?W:Y},J(Q)}}catch{}}async function u0(U,$,J,Q){if(Q==="node"){let W=await Promise.resolve().then(() => gU(d0(),1)),Z=typeof U==="string"?Buffer.from(U,"utf8"):Buffer.from(U),Y=Buffer.from($),V=await W.hash(Z,{salt:Y,timeCost:J.time,memoryCost:J.mem,parallelism:J.parallelism,hashLength:32,raw:!0,type:W.argon2id});return Y.fill(0),Z.fill(0),{hash:new Uint8Array(V)}}if(Q==="browser")return await o$(),kU.hash({pass:U,salt:$,time:J.time,mem:J.mem,parallelism:J.parallelism,hashLen:32,type:kU.ArgonType.Argon2id}).then((W)=>{if(!W||!W.hash)throw new r("Failed to produce key derivation");return{hash:W.hash}}).catch((W)=>{let Z=W instanceof Error?W.message:typeof W==="string"?W:"Unknown error";throw new r(`argon2-browser failure: ${Z}`)});throw new Error(`Unsupported environment: ${Q}`)}class yU{presets;exportExtractable;name="argon2id";constructor(U,$=!1){this.presets=U;this.exportExtractable=$}async derive(U,$,J,Q){let{hash:W}=await u0(U,$,this.presets[J],Q.isNode?"node":"browser");if(this.exportExtractable)return Q.subtle.importKey("raw",W,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]);else return Q.subtle.importKey("raw",W,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}}var h0={low:{time:5,mem:65536,parallelism:1},middle:{time:20,mem:65536,parallelism:1},high:{time:40,mem:65536,parallelism:1}},r$={id:0,cipher:QU,kdf:new yU(h0),saltLengths:{low:12,high:16},difficulties:h0,defaultChunkSize:524288};l.register(r$);var p0={low:{time:5,mem:65536,parallelism:2},middle:{time:10,mem:98304,parallelism:4},high:{time:20,mem:98304,parallelism:4}},s$={id:1,cipher:WU,kdf:new yU(p0,!0),saltLengths:{low:12,high:16},difficulties:p0,defaultChunkSize:524288};l.register(s$);var fU=1;function x0(){return typeof process!=="undefined"&&typeof process.versions==="object"&&!0}function zU(...U){let $=U.reduce((W,Z)=>W+Z.byteLength,0),J=new Uint8Array($),Q=0;for(let W of U)J.set(W,Q),Q+=W.byteLength;return J}function MU(...U){try{let $=zU(...U);if(x0())return Buffer.from($).toString("base64");let J="";for(let Q=0;Q<$.length;Q++)J+=String.fromCharCode($[Q]);return btoa(J)}catch{throw new cU("Base64 Encoding Error")}}function TU(U){try{if(!/^[A-Za-z0-9+/]+={0,2}$/.test(U)||U.length%4!==0)throw new Error("Invalid Base64");if(x0())return new Uint8Array(Buffer.from(U,"base64"));let $=atob(U),J=new Uint8Array($.length);for(let Q=0;Q<$.length;Q++)J[Q]=$.charCodeAt(Q);return J}catch{throw new wU(`Invalid Base64: length=${U.length}, content='${U.slice(0,12)}…'`)}}function h(U){let $=U.value.length,J=new Array($).fill("\x00").join("");U.value=J}function SU(U,$,J,Q){let W={low:0,middle:1,high:2};if(!($ in W))throw new TypeError(`Unsupported difficulty: ${$}`);let Z=W[$],Y=U<<5|(J==="high"?1:0)<<2|Z;return zU(new Uint8Array([fU,Y]),Q)}function ZU(U){if(U[0]!==fU)throw new p("Invalid input format. The input is unknown.");if(U.length<14)throw new p("Invalid input format. Header too short.");try{let $=U[1],J=$>>5,Q=$>>2&1?"high":"low",W=$&3,Z=["low","middle","high"][W],Y=l.get(J).saltLengths[Q],V=U.slice(2,2+Y);return{scheme:J,difficulty:Z,saltStrength:Q,salt:V,headerLen:2+Y}}catch($){throw new NU($ instanceof Error?$.message:String($))}}async function bU(U){if(U instanceof Uint8Array)return U;if(U instanceof ArrayBuffer)return new Uint8Array(U);return new Uint8Array(await U.arrayBuffer())}function U0(U){let $=new Uint8Array(4);return new DataView($.buffer).setUint32(0,U,!1),$}function i0(U,$=0){if(U.length-$<4)throw new RangeError("Not enough bytes for frame header");return new DataView(U.buffer,U.byteOffset+$,4).getUint32(0,!1)}var e=4;class AU{engine;chunkSize;buffer=new Uint8Array(0);constructor(U,$=524288){this.engine=U;this.chunkSize=$}toTransformStream(){return new TransformStream({transform:async(U,$)=>{await this.transform(await bU(U),$)},flush:async(U)=>this.flush(U)})}async transform(U,$){if(U.length>this.chunkSize*4)throw new RangeError(`Input block (${U.length} B) exceeds sane limit`);let J=new Uint8Array(this.buffer.length+U.length);J.set(this.buffer),J.set(U,this.buffer.length);let Q=0;while(J.length-Q>=this.chunkSize){let W=J.slice(Q,Q+this.chunkSize);Q+=this.chunkSize;let Z=await this.engine.encryptChunk(W),Y=new Uint8Array(e+Z.length);Y.set(U0(Z.length)),Y.set(Z,e),$.enqueue(Y)}this.buffer=J.slice(Q)}async flush(U){if(!this.buffer.length)return;let $=await this.engine.encryptChunk(this.buffer),J=new Uint8Array(e+$.length);J.set(U0($.length)),J.set($,e),U.enqueue(J),this.buffer=new Uint8Array(0),this.engine.zeroKey()}}class KU{engine;chunkSize;buffer=new Uint8Array(0);constructor(U,$=524288){this.engine=U;this.chunkSize=$}toTransformStream(){return new TransformStream({transform:async(U,$)=>{await this.transform(await bU(U),$)},flush:async(U)=>this.flush(U)})}async transform(U,$){let J=new Uint8Array(this.buffer.length+U.length);J.set(this.buffer),J.set(U,this.buffer.length);let Q=0;while(!0){if(J.length-Q<e)break;let W=i0(J,Q);if(W>this.chunkSize*2)throw new d(`Frame length ${W} exceeds …`);if(J.length-Q-e<W)break;Q+=e;let Z=J.slice(Q,Q+W);Q+=W;try{let Y=await this.engine.decryptChunk(Z);$.enqueue(Y)}catch(Y){throw Y instanceof d?Y:new d("Decryption failed: Wrong passphrase or corrupted ciphertext")}}this.buffer=J.slice(Q)}async flush(U){await this.transform(new Uint8Array(0),U),this.buffer=new Uint8Array(0),this.engine.zeroKey()}}async function o0(U,$){let J=U.getReader(),Q=$&&$.length?[$]:[];try{while(!0){let{value:V,done:G}=await J.read();if(G)break;Q.push(V)}}finally{J.releaseLock()}let W=Q.reduce((V,G)=>V+G.byteLength,0),Z=new Uint8Array(W),Y=0;for(let V of Q)Z.set(V,Y),Y+=V.byteLength;return Z}class PU{engine;chunkSize;constructor(U,$=524288){this.engine=U;this.chunkSize=$}encryptionStream(){let U=new AU(this.engine,this.chunkSize).toTransformStream();return{writable:U.writable,readable:U.readable}}decryptionStream(U){let $=U,J=new TransformStream({transform(W,Z){if($===0){Z.enqueue(W);return}if(W.byteLength<=$){$-=W.byteLength;return}Z.enqueue(W.slice($)),$=0}}),Q=new KU(this.engine,this.chunkSize).toTransformStream();return{writable:J.writable,readable:J.readable.pipeThrough(Q)}}async collect(U,$,J=null){return o0(U.pipeThrough($),J??void 0)}}function r0(U=0,$=console.info){return{level:U,log(J,Q){if(J<=U)$(`${J}| ${Q}`)}}}function s0(U,$,J){if($<0||J<0||$+J>U)throw new RangeError("read() slice exceeds data bounds")}class $0{src;#U=null;constructor(U){this.src=U}get length(){if(this.src instanceof Uint8Array)return this.src.byteLength;if(this.src instanceof Blob)return this.src.size;return this.ensureUint8().byteLength}async read(U,$){if(s0(this.length,U,$),this.src instanceof Uint8Array)return this.src.slice(U,U+$);if(this.src instanceof Blob){let J=await this.src.slice(U,U+$).arrayBuffer();return new Uint8Array(J)}return this.ensureUint8().slice(U,U+$)}ensureUint8(){if(!this.#U)this.#U=TU(this.src);return this.#U}}var a0=new WeakMap;class $U{static getEngine(U,$){let J=a0.get(U);if(!J)J=new Map,a0.set(U,J);let Q=J.get($);if(Q)return Q;let W=l.get($);return Q={desc:W,cipher:new W.cipher(U),kdf:W.kdf,chunkSize:W.defaultChunkSize,provider:U},J.set($,Q),Q}static async deriveKey(U,$,J,Q){try{let W=await U.kdf.derive($.value,J,Q,U.provider);await U.cipher.setKey(W)}catch(W){let Z=W instanceof Error?W.message:String(W);throw new r(Z)}finally{h($)}}}class JU{provider;v;cipher;kdf;chunkSize;stream;difficulty;saltStrength;engines=new Map;log;constructor(U,$={}){this.provider=U;this.v=l.get($.scheme??l.current.id),this.cipher=new this.v.cipher(U),this.kdf=this.v.kdf,this.chunkSize=this.setChunkSize($.chunkSize??this.v.defaultChunkSize),this.stream=new PU(this.cipher,this.chunkSize),this.difficulty=$.difficulty??"middle",this.saltStrength=$.saltStrength??"high",this.log=r0($.verbose??0,$.logger)}static async isEncrypted(U){try{return await JU.peekHeader(U),!0}catch{return!1}}static async headerDecode(U){let $=await JU.peekHeader(U),J=ZU($);return{scheme:J.scheme,difficulty:J.difficulty,salt:MU(J.salt),saltLength:J.salt.byteLength}}static async decodeData(U){let $=typeof U?.read==="function"?U:new $0(U),J=await $.read(0,Math.min(256,$.length)),Q=await JU.peekHeader(J),{scheme:W,headerLen:Z}=ZU(Q),Y=$.length,V=Y-Z;if(V<=0)throw new p("Payload is empty");let G=await $.read(Z,4),q=new DataView(G.buffer,G.byteOffset,4).getUint32(0,!1);if(q+4<=V&&q>=28){let H=q,w=Z,O=0,z=0;while(w+4<=Y){let M=await $.read(w,4),T=new DataView(M.buffer,M.byteOffset,4).getUint32(0,!1);if(T===0||w+4+T>Y)break;O++,z+=T,w+=4+T}return{isChunked:!0,chunks:{chunkSize:H,count:O,totalPayload:z}}}let N=await $.read(Z,V),K=l.get(W).cipher.IV_LENGTH;if(N.length<K+16)throw new p("Ciphertext too short for IV & tag");return{isChunked:!1,payloadLength:V,params:{iv:N.slice(0,K),tag:N.slice(N.length-16)}}}setDifficulty(U){this.difficulty=U}getDifficulty(){return this.difficulty}setScheme(U){this.v=l.get(U),this.cipher=new this.v.cipher(this.provider),this.kdf=this.v.kdf,this.stream=new PU(this.cipher,this.chunkSize)}getScheme(){return this.v.id}setSaltDifficulty(U){this.saltStrength=U}getSaltDifficulty(){return this.saltStrength}setChunkSize(U){let $=U,J;if($==null)J=this.v.defaultChunkSize;else if(J=Number($),!Number.isInteger(J)||J<1)throw new Error(`Invalid chunkSize: ${$}. Must be a positive integer.`);return this.chunkSize=J,this.stream=new PU(this.cipher,this.chunkSize),J}getChunkSize(){return this.chunkSize}setVerbose(U){this.log.level=U}getVerbose(){return this.log.level}async encryptText(U,$){let J={value:$};try{this.log.log(1,`Start text encryption, scheme: ${this.getScheme()}`),this.log.log(2,"Deriving key for text encryption");let Q=this.genSalt();await this.deriveKey(J,Q),h(J),$=null,this.log.log(3,`Salt generated: ${MU(Q)}, KDF difficulty: ${this.difficulty}`),this.log.log(2,"Encrypting text data");let W=await this.cipher.encryptChunk(typeof U==="string"?new TextEncoder().encode(U):U);this.cipher.zeroKey(),this.log.log(3,"Encoding header");let Z=SU(this.v.id,this.difficulty,this.saltStrength,Q);this.log.log(3,"Encoding text");let Y=MU(Z,W);return this.log.log(1,"Decryption finished"),Y}catch(Q){throw new BU(Q instanceof Error?Q.message:String(Q))}}async decryptText(U,$){let J={value:$};try{this.log.log(1,`Start text decryption, Version ${this.getScheme()}`),this.log.log(3,"Start text decoding");let Q=TU(U);this.log.log(3,"Start header decoding"),await JU.peekHeader(U);let W=ZU(Q);this.log.log(3,"Trying to get engine");let Z=$U.getEngine(this.provider,W.scheme);this.log.log(2,`Deriving key via engine for scheme: ${W.scheme}`),this.log.log(3,`Salt use: ${MU(W.salt)}, KDF difficulty: ${W.difficulty}`);try{await $U.deriveKey(Z,J,W.salt,W.difficulty)}finally{h(J),$=null}this.log.log(2,"Decrypting text data");let Y=await Z.cipher.decryptChunk(Q.slice(W.headerLen));Z.cipher.zeroKey(),this.log.log(3,"Decoding text");let V=new TextDecoder().decode(Y);return this.log.log(1,"Decryption finished"),V}catch(Q){if(Q instanceof d||Q instanceof p||Q instanceof NU||Q instanceof wU||Q instanceof r)throw Q;throw new d("Decryption failed: wrong passphrase or corrupted ciphertext")}}async encryptFile(U,$){let J={value:$};try{if(U.size===0){let Y=this.genSalt();await this.deriveKey(J,Y),h(J),$=null;let V=SU(this.v.id,this.difficulty,this.saltStrength,Y);return new Blob([V],{type:"application/octet-stream"})}this.log.log(2,"Deriving key for file encryption");let Q=this.genSalt();await this.deriveKey(J,Q),h(J),$=null;let W=SU(this.v.id,this.difficulty,this.saltStrength,Q),Z=await this.stream.collect(U.stream(),new AU(this.cipher,this.chunkSize).toTransformStream(),W);return new Blob([Z],{type:"application/octet-stream"})}catch(Q){throw new BU(Q instanceof Error?Q.message:String(Q))}}async decryptFile(U,$){let J={value:$};try{let Q=await JU.peekHeader(U),W=ZU(Q),Z=$U.getEngine(this.provider,W.scheme);try{await $U.deriveKey(Z,J,W.salt,W.difficulty)}finally{h(J),$=null}if(U.size===W.headerLen)return new Blob([],{type:"application/octet-stream"});this.log.log(2,"Decrypting file data");let V=await new PU(Z.cipher,Z.chunkSize).collect(U.slice(W.headerLen).stream(),new KU(Z.cipher,Z.chunkSize).toTransformStream());return new Blob([V],{type:"application/octet-stream"})}catch(Q){if(Q instanceof d)throw Q;throw new d(Q instanceof Error?Q.message:String(Q))}}async createEncryptionStream(U){let $={value:U};this.log.log(2,"Deriving key for stream encryption");let J=this.genSalt();await this.deriveKey($,J),h($),U=null;let Q=SU(this.v.id,this.difficulty,this.saltStrength,J),W=this.stream.encryptionStream();return{header:Q,writable:W.writable,readable:W.readable}}async createDecryptionStream(U){let $={value:U},J=this,Q=new Uint8Array(0),W=null;async function Z(Y,V){let G=Y.getReader();while(!0){let{value:q,done:I}=await G.read();if(I)break;V.enqueue(q)}}return new TransformStream({async transform(Y,V){if(!W){if(Q=zU(Q,Y),Q.length<2)return;let q=Q.slice(0,30),{salt:I,difficulty:N}=ZU(q),K=Q[1]>>5,H=Q[1]>>2&1?"high":"low",O=2+l.get(K).saltLengths[H];if(Q.length<O)return;let z=$U.getEngine(J.provider,K);try{await $U.deriveKey(z,$,I,N)}finally{h($),U=null}W=new KU(z.cipher,z.chunkSize).toTransformStream(),Z(W.readable,V).catch((T)=>{V.error(T)});let M=Q.slice(O);if(M.length){let T=W.writable.getWriter();await T.write(M),T.releaseLock()}return}let G=W.writable.getWriter();await G.write(Y),G.releaseLock()},async flush(){if(W){let Y=W.writable.getWriter();await Y.close(),Y.releaseLock()}}})}async deriveKey(U,$,J=this.difficulty){let Q=performance.now();try{let W=await this.kdf.derive(U.value,$,J,this.provider);h(U),await this.cipher.setKey(W),this.log.log(3,`Key derivation completed in ${(performance.now()-Q).toFixed(1)} ms`)}catch(W){throw new r(W instanceof Error?W.message:String(W))}}genSalt(U=this.saltStrength){let $=this.v.saltLengths[this.saltStrength];return this.provider.getRandomValues(new Uint8Array($))}static async peekHeader(U){let $=await this.readAsUint8(U);if($ instanceof Uint8Array){if($.length<2)throw new p("Input too short");let{headerLen:J}=ZU($.length>=16?$:Uint8Array.from($));if($.length<J)throw new p("Incomplete header");return $.slice(0,J)}throw new NU("Unsupported input type")}static async readAsUint8(U){if(typeof U==="string")return TU(U);if(U instanceof Blob){let $=U.slice(0,64);return new Uint8Array(await $.arrayBuffer())}return U}}import{webcrypto as a$,randomFillSync as t$}from"node:crypto";var t0={subtle:a$.subtle,getRandomValues(U){return t$(U),U},isNode:!0};function _Q(U){return new JU(t0,U)}export{_Q as createCryptit};

//# debugId=CA7451A5D8A769EF64756E2164756E21
