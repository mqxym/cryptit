var n8=Object.create;var{getPrototypeOf:u8,defineProperty:H,getOwnPropertyNames:z8,getOwnPropertyDescriptor:l8}=Object,J8=Object.prototype.hasOwnProperty;var Q8=(A,U,_)=>{_=A!=null?n8(u8(A)):{};let S=U||!A||!A.__esModule?H(_,"default",{value:A,enumerable:!0}):_;for(let V of z8(A))if(!J8.call(S,V))H(S,V,{get:()=>A[V],enumerable:!0});return S},$8=new WeakMap,o8=(A)=>{var U=$8.get(A),_;if(U)return U;if(U=H({},"__esModule",{value:!0}),A&&typeof A==="object"||typeof A==="function")z8(A).map((S)=>!J8.call(U,S)&&H(U,S,{get:()=>A[S],enumerable:!(_=l8(A,S))||_.enumerable}));return $8.set(A,U),U},m=(A,U)=>()=>(U||A((U={exports:{}}).exports,U),U.exports);var d8=(A,U)=>{for(var _ in U)H(A,_,{get:U[_],enumerable:!0,configurable:!0,set:(S)=>U[_]=()=>S})};var O8=m((xA,Z8)=>{var f=/^[a-z0-9-]{1,32}$/,b=/^[a-z0-9-]{1,32}$/,g=/^[a-zA-Z0-9/+.-]+$/,W8=/^([a-zA-Z0-9/+.-]+|)$/,i8=/^((-)?[1-9]\d*|0)$/,r=/^v=(\d+)$/;function p8(A){return R(A).map((U)=>[U,A[U]].join("=")).join(",")}function r8(A){let U={};return A.split(",").forEach((_)=>{let S=_.split("=");if(S.length<2)throw new TypeError("params must be in the format name=value");U[S.shift()]=S.join("=")}),U}function R(A){return Object.keys(A)}function X8(A){if(typeof Object.values==="function")return Object.values(A);return R(A).map((U)=>A[U])}function t8(A){let U=[""];if(typeof A!=="object"||A===null)throw new TypeError("opts must be an object");if(typeof A.id!=="string")throw new TypeError("id must be a string");if(!f.test(A.id))throw new TypeError(`id must satisfy ${f}`);if(U.push(A.id),typeof A.version!=="undefined"){if(typeof A.version!=="number"||A.version<0||!Number.isInteger(A.version))throw new TypeError("version must be a positive integer number");U.push(`v=${A.version}`)}if(typeof A.params!=="undefined"){if(typeof A.params!=="object"||A.params===null)throw new TypeError("params must be an object");let S=R(A.params);if(!S.every((P)=>b.test(P)))throw new TypeError(`params names must satisfy ${b}`);S.forEach((P)=>{if(typeof A.params[P]==="number")A.params[P]=A.params[P].toString();else if(Buffer.isBuffer(A.params[P]))A.params[P]=A.params[P].toString("base64").split("=")[0]});let V=X8(A.params);if(!V.every((P)=>typeof P==="string"))throw new TypeError("params values must be strings");if(!V.every((P)=>g.test(P)))throw new TypeError(`params values must satisfy ${g}`);let Y=p8(A.params);U.push(Y)}if(typeof A.salt!=="undefined"){if(!Buffer.isBuffer(A.salt))throw new TypeError("salt must be a Buffer");if(U.push(A.salt.toString("base64").split("=")[0]),typeof A.hash!=="undefined"){if(!Buffer.isBuffer(A.hash))throw new TypeError("hash must be a Buffer");U.push(A.hash.toString("base64").split("=")[0])}}return U.join("$")}function a8(A){if(typeof A!=="string"||A==="")throw new TypeError("pchstr must be a non-empty string");if(A[0]!=="$")throw new TypeError("pchstr must contain a $ as first char");let U=A.split("$");U.shift();let _=5;if(!r.test(U[1]))_--;if(U.length>_)throw new TypeError(`pchstr contains too many fileds: ${U.length}/${_}`);let S=U.shift();if(!f.test(S))throw new TypeError(`id must satisfy ${f}`);let V;if(r.test(U[0]))V=parseInt(U.shift().match(r)[1],10);let Y,P;if(W8.test(U[U.length-1]))if(U.length>1&&W8.test(U[U.length-2]))Y=Buffer.from(U.pop(),"base64"),P=Buffer.from(U.pop(),"base64");else P=Buffer.from(U.pop(),"base64");let $;if(U.length>0){let J=U.pop();if($=r8(J),!R($).every((Q)=>b.test(Q)))throw new TypeError(`params names must satisfy ${b}`);if(!X8($).every((Q)=>g.test(Q)))throw new TypeError(`params values must satisfy ${g}`);R($).forEach((Q)=>{$[Q]=i8.test($[Q])?parseInt($[Q],10):$[Q]})}if(U.length>0)throw new TypeError(`pchstr contains unrecognized fileds: ${U}`);let z={id:S};if(V)z.version=V;if($)z.params=$;if(P)z.salt=P;if(Y)z.hash=Y;return z}Z8.exports={serialize:t8,deserialize:a8}});var E8=m((DA,H8)=>{var I8=require("fs"),T=require("path"),K8=require("os"),M8=typeof __webpack_require__==="function"?__non_webpack_require__:require,s8=process.config&&process.config.variables||{},e8=!!process.env.PREBUILDS_ONLY,G8=process.versions.modules,t=_A()?"electron":UA()?"node-webkit":"node",a=process.env.npm_config_arch||K8.arch(),s=process.env.npm_config_platform||K8.platform(),N8=process.env.LIBC||(SA(s)?"musl":"glibc"),e=process.env.ARM_VERSION||(a==="arm64"?"8":s8.arm_version)||"",w8=(process.versions.uv||"").split(".")[0];H8.exports=G;function G(A){return M8(G.resolve(A))}G.resolve=G.path=function(A){A=T.resolve(A||".");try{var U=M8(T.join(A,"package.json")).name.toUpperCase().replace(/-/g,"_");if(process.env[U+"_PREBUILD"])A=process.env[U+"_PREBUILD"]}catch(z){}if(!e8){var _=q8(T.join(A,"build/Release"),T8);if(_)return _;var S=q8(T.join(A,"build/Debug"),T8);if(S)return S}var V=$(A);if(V)return V;var Y=$(T.dirname(process.execPath));if(Y)return Y;var P=["platform="+s,"arch="+a,"runtime="+t,"abi="+G8,"uv="+w8,e?"armv="+e:"","libc="+N8,"node="+process.versions.node,process.versions.electron?"electron="+process.versions.electron:"",typeof __webpack_require__==="function"?"webpack=true":""].filter(Boolean).join(" ");throw new Error("No native build was found for "+P+`
    loaded from: `+A+`
`);function $(z){var J=A8(T.join(z,"prebuilds")).map(x8),O=J.filter(D8(s,a)).sort(L8)[0];if(!O)return;var X=T.join(z,"prebuilds",O.name),Q=A8(X).map(B8),C=Q.filter(C8(t,G8)),F=C.sort(F8(t))[0];if(F)return T.join(X,F.file)}};function A8(A){try{return I8.readdirSync(A)}catch(U){return[]}}function q8(A,U){var _=A8(A).filter(U);return _[0]&&T.join(A,_[0])}function T8(A){return/\.node$/.test(A)}function x8(A){var U=A.split("-");if(U.length!==2)return;var _=U[0],S=U[1].split("+");if(!_)return;if(!S.length)return;if(!S.every(Boolean))return;return{name:A,platform:_,architectures:S}}function D8(A,U){return function(_){if(_==null)return!1;if(_.platform!==A)return!1;return _.architectures.includes(U)}}function L8(A,U){return A.architectures.length-U.architectures.length}function B8(A){var U=A.split("."),_=U.pop(),S={file:A,specificity:0};if(_!=="node")return;for(var V=0;V<U.length;V++){var Y=U[V];if(Y==="node"||Y==="electron"||Y==="node-webkit")S.runtime=Y;else if(Y==="napi")S.napi=!0;else if(Y.slice(0,3)==="abi")S.abi=Y.slice(3);else if(Y.slice(0,2)==="uv")S.uv=Y.slice(2);else if(Y.slice(0,4)==="armv")S.armv=Y.slice(4);else if(Y==="glibc"||Y==="musl")S.libc=Y;else continue;S.specificity++}return S}function C8(A,U){return function(_){if(_==null)return!1;if(_.runtime&&_.runtime!==A&&!AA(_))return!1;if(_.abi&&_.abi!==U&&!_.napi)return!1;if(_.uv&&_.uv!==w8)return!1;if(_.armv&&_.armv!==e)return!1;if(_.libc&&_.libc!==N8)return!1;return!0}}function AA(A){return A.runtime==="node"&&A.napi}function F8(A){return function(U,_){if(U.runtime!==_.runtime)return U.runtime===A?-1:1;else if(U.abi!==_.abi)return U.abi?-1:1;else if(U.specificity!==_.specificity)return U.specificity>_.specificity?-1:1;else return 0}}function UA(){return!!(process.versions&&process.versions.nw)}function _A(){if(process.versions&&process.versions.electron)return!0;if(process.env.ELECTRON_RUN_AS_NODE)return!0;return typeof window!=="undefined"&&window.process&&window.process.type==="renderer"}function SA(A){return A==="linux"&&I8.existsSync("/etc/alpine-release")}G.parseTags=B8;G.matchTags=C8;G.compareTags=F8;G.parseTuple=x8;G.matchTuple=D8;G.compareTuples=L8});var R8=m((LA,_8)=>{var U8=typeof __webpack_require__==="function"?__non_webpack_require__:require;if(typeof U8.addon==="function")_8.exports=U8.addon.bind(U8);else _8.exports=E8()});var v8=m((CA,N)=>{var __dirname="/Users/maxim/Projects/Private/Sites/cryptit/node_modules/argon2",BA=require("node:assert"),{randomBytes:VA,timingSafeEqual:YA}=require("node:crypto"),{promisify:PA}=require("node:util"),{deserialize:y8,serialize:$A}=O8(),zA=R8(),{hash:k8}=zA(__dirname),JA=PA(VA);N.exports.argon2d=0;N.exports.argon2i=1;N.exports.argon2id=2;var y=Object.freeze({argon2d:0,argon2i:1,argon2id:2}),QA=Object.freeze({[y.argon2d]:"argon2d",[y.argon2i]:"argon2i",[y.argon2id]:"argon2id"}),j8={hashLength:32,timeCost:3,memoryCost:65536,parallelism:4,type:2,version:19};async function WA(A,U){let{raw:_,salt:S,...V}={...j8,...U};if(V.hashLength>4294967295)throw new RangeError("Hash length is too large");if(V.memoryCost>4294967295)throw new RangeError("Memory cost is too large");if(V.timeCost>4294967295)throw new RangeError("Time cost is too large");if(V.parallelism>16777215)throw new RangeError("Parallelism is too large");S=S??await JA(16);let{hashLength:Y,secret:P=Buffer.alloc(0),type:$,version:z,memoryCost:J,timeCost:O,parallelism:X,associatedData:Q=Buffer.alloc(0)}=V,C=await k8({password:Buffer.from(A),salt:S,secret:P,data:Q,hashLength:Y,m:J,t:O,p:X,version:z,type:$});if(_)return C;return $A({id:QA[$],version:z,params:{m:J,t:O,p:X,...Q.byteLength>0?{data:Q}:{}},salt:S,hash:C})}N.exports.hash=WA;function XA(A,U={}){let{memoryCost:_,timeCost:S,parallelism:V,version:Y}={...j8,...U},{version:P,params:{m:$,t:z,p:J}}=y8(A);return+P!==+Y||+$!==+_||+z!==+S||+J!==+V}N.exports.needsRehash=XA;async function ZA(A,U,_={}){let{id:S,...V}=y8(A);if(!(S in y))return!1;let{version:Y=16,params:{m:P,t:$,p:z,data:J=""},salt:O,hash:X}=V,{secret:Q=Buffer.alloc(0)}=_;return YA(await k8({password:Buffer.from(U),salt:O,secret:Q,data:Buffer.from(J,"base64"),hashLength:X.byteLength,m:+P,t:+$,p:+z,version:+Y,type:y[S]}),X)}N.exports.verify=ZA});var qA={};d8(qA,{createCryptit:()=>GA});module.exports=o8(qA);class q extends Error{constructor(A){super(A);Object.setPrototypeOf(this,new.target.prototype),this.name=new.target.name,this.stack=void 0}}class I extends q{}class E extends q{}class i extends q{}class c extends q{}class D extends q{}class K extends q{}class h extends q{}class Z extends q{}class W{static byId=new Map;static register(A){if(this.byId.has(A.id))throw new c(`Version ${A.id} already registered`);this.byId.set(A.id,A)}static get(A){let U=this.byId.get(A);if(!U)throw new c(`Unknown version: ${A}`);return U}static get current(){return this.get(0)}}class p{p;key;constructor(A){this.p=A}setKey(A){this.key=A}async encryptChunk(A){let U=this.p.getRandomValues(new Uint8Array(12)),_=new Uint8Array(await this.p.subtle.encrypt({name:"AES-GCM",iv:U},this.key,A)),S=new Uint8Array(U.length+_.length);return S.set(U),S.set(_,U.length),S}async decryptChunk(A){let U=A.slice(0,12),_=A.slice(12),S=await this.p.subtle.decrypt({name:"AES-GCM",iv:U},this.key,_);try{let V=await this.p.subtle.decrypt({name:"AES-GCM",iv:U},this.key,_);return new Uint8Array(V)}catch{throw new Z("Decryption failed: wrong passphrase or corrupted ciphertext")}}}var n=Q8(require("argon2-browser"));async function m8(A,U,_,S){if(S==="node"){let V=await Promise.resolve().then(() => Q8(v8())),Y=typeof A==="string"?Buffer.from(A,"utf8"):Buffer.from(A),P=Buffer.from(U),$=await V.hash(Y,{salt:P,timeCost:_.time,memoryCost:_.mem,parallelism:_.parallelism,hashLength:32,raw:!0,type:V.argon2id});return{hash:new Uint8Array($)}}if(S==="browser"){if(!("loadArgon2WasmBinary"in globalThis))globalThis.loadArgon2WasmBinary=()=>{let V=new URL("argon2.wasm",import.meta.url).href;return fetch(V).then((Y)=>{if(!Y.ok)throw new Error("Failed to load argon2.wasm");return Y.arrayBuffer()}).then((Y)=>new Uint8Array(Y))};return n.hash({pass:A,salt:U,time:_.time,mem:_.mem,parallelism:_.parallelism,hashLen:32,type:n.ArgonType.Argon2id}).then((V)=>{if(!V||!V.hash)throw new Error("Failed to produce key derivation");return{hash:V.hash}}).catch((V)=>{let Y=V instanceof Error?V.message:typeof V==="string"?V:"Unknown error";throw new K(`argon2-browser failure: ${Y}`)})}throw new Error(`Unsupported environment: ${S}`)}class S8{presets;name="argon2id";constructor(A){this.presets=A}async derive(A,U,_,S){let{hash:V}=await m8(A,U,this.presets[_],S.isNode?"node":"browser");return S.subtle.importKey("raw",V,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}}var c8={low:{time:5,mem:65536,parallelism:1},middle:{time:20,mem:65536,parallelism:1},high:{time:40,mem:65536,parallelism:1}},OA={id:0,cipher:p,kdf:new S8(c8),saltLengths:{low:12,high:16},difficulties:c8,defaultChunkSize:524288};W.register(OA);var u=1;function h8(){return typeof process!=="undefined"&&typeof process.versions==="object"&&!0}function k(...A){let U=A.reduce((V,Y)=>V+Y.byteLength,0),_=new Uint8Array(U),S=0;for(let V of A)_.set(V,S),S+=V.byteLength;return _}function j(...A){try{let U=k(...A);if(h8())return Buffer.from(U).toString("base64");let _="";for(let S=0;S<U.length;S++)_+=String.fromCharCode(U[S]);return btoa(_)}catch(U){throw new i("Base64 Enconding Error")}}function V8(A){try{if(!/^[A-Za-z0-9+/]+={0,2}$/.test(A)||A.length%4!==0)throw new Error("invalid base64");if(h8())return new Uint8Array(Buffer.from(A,"base64"));let U=atob(A),_=new Uint8Array(U.length);for(let S=0;S<U.length;S++)_[S]=U.charCodeAt(S);return _}catch(U){throw new E("Base64 Decoding Error")}}function l(A,U,_,S){let V={low:0,middle:1,high:2}[U]??0,Y=A<<5|(_==="high"?1:0)<<2|V;return k(new Uint8Array([u,Y]),S)}function w(A){if(A[0]!==u)throw new I("Invalid input format. The input is unknown.");try{let U=A[1],_=U>>5,S=U>>2&1?"high":"low",V=U&3,Y=["low","middle","high"][V],P=W.get(_).saltLengths[S],$=A.slice(2,2+P);return{version:_,difficulty:Y,saltStrength:S,salt:$,headerLen:2+P}}catch(U){throw new D(U instanceof Error?U.message:String(U))}}class v{engine;chunkSize;buffer=new Uint8Array(0);constructor(A,U=524288){this.engine=A;this.chunkSize=U}toTransformStream(){return new TransformStream({transform:async(A,U)=>{await this.transform(await this.asUint8Array(A),U)},flush:async(A)=>this.flush(A)})}async transform(A,U){let _=new Uint8Array(this.buffer.length+A.length);_.set(this.buffer),_.set(A,this.buffer.length);let S=0;while(_.length-S>=this.chunkSize){let V=_.slice(S,S+this.chunkSize);S+=this.chunkSize;let Y=await this.engine.encryptChunk(V),P=new Uint8Array(4);new DataView(P.buffer).setUint32(0,Y.length,!1);let $=new Uint8Array(4+Y.length);$.set(P),$.set(Y,P.length),U.enqueue($)}this.buffer=_.slice(S)}async flush(A){if(!this.buffer.length)return;let U=await this.engine.encryptChunk(this.buffer),_=new Uint8Array(4);new DataView(_.buffer).setUint32(0,U.length,!1);let S=new Uint8Array(4+U.length);S.set(_),S.set(U,4),A.enqueue(S),this.buffer=new Uint8Array(0)}async asUint8Array(A){if(A instanceof Uint8Array)return A;if(A instanceof ArrayBuffer)return new Uint8Array(A);return new Uint8Array(await A.arrayBuffer())}}class L{engine;chunkSize;buffer=new Uint8Array(0);constructor(A,U=524288){this.engine=A;this.chunkSize=U}toTransformStream(){return new TransformStream({transform:async(A,U)=>{await this.transform(await this.asUint8Array(A),U)},flush:async(A)=>this.flush(A)})}async transform(A,U){let _=new Uint8Array(this.buffer.length+A.length);_.set(this.buffer),_.set(A,this.buffer.length);let S=0;while(!0){if(_.length-S<4)break;let V=new DataView(_.buffer,_.byteOffset+S,4).getUint32(0,!1);if(_.length-S-4<V)break;S+=4;let Y=_.slice(S,S+V);S+=V;try{let P=await this.engine.decryptChunk(Y);U.enqueue(P)}catch(P){throw P instanceof Z?P:new Z("Decryption failed: Wrong passphrase or corrupted ciphertext")}}this.buffer=_.slice(S)}async flush(A){await this.transform(new Uint8Array(0),A),this.buffer=new Uint8Array(0)}async asUint8Array(A){if(A instanceof Uint8Array)return A;if(A instanceof ArrayBuffer)return new Uint8Array(A);return new Uint8Array(await A.arrayBuffer())}}class B{engine;chunkSize;constructor(A,U=524288){this.engine=A;this.chunkSize=U}encryptionStream(){let A=new v(this.engine,this.chunkSize).toTransformStream();return{writable:A.writable,readable:A.readable}}decryptionStream(A){let U=A,_=new TransformStream({transform(V,Y){if(U===0){Y.enqueue(V);return}if(V.byteLength<=U){U-=V.byteLength;return}Y.enqueue(V.slice(U)),U=0}}),S=new L(this.engine,this.chunkSize).toTransformStream();return{writable:_.writable,readable:_.readable.pipeThrough(S)}}async collect(A,U,_=null){let S=A.pipeThrough(U).getReader(),V=[];if(_?.length)V.push(_);while(!0){let{value:z,done:J}=await S.read();if(J)break;V.push(z)}let Y=V.reduce((z,J)=>z+J.byteLength,0),P=new Uint8Array(Y),$=0;for(let z of V)P.set(z,$),$+=z.byteLength;return P}}function f8(A=0,U=console.info){return{level:A,log(_,S){if(_<=A)U(`${_}| ${S}`)}}}var b8=new Map;class M{static getEngine(A,U){let _=b8.get(U);if(_)return _;let S=W.get(U),V=new S.cipher(A),Y=S.kdf,P=S.defaultChunkSize;return _={desc:S,cipher:V,kdf:Y,chunkSize:P,provider:A},b8.set(U,_),_}static async deriveKey(A,U,_,S){try{let V=await A.kdf.derive(U,_,S,A.provider);A.cipher.key=V}catch(V){let Y=V instanceof Error?V.message:String(V);throw new K(Y)}}}class x{provider;v;cipher;kdf;chunkSize;stream;difficulty;saltStrength;engines=new Map;log;constructor(A,U={}){this.provider=A;this.v=W.get(U.version??W.current.id),this.cipher=new this.v.cipher(A),this.kdf=this.v.kdf,this.chunkSize=U.chunkSize??this.v.defaultChunkSize,this.stream=new B(this.cipher,this.chunkSize),this.difficulty=U.difficulty??"middle",this.saltStrength=U.saltStrength??"high",this.log=f8(U.verbose??0,U.logger)}static async isEncrypted(A){try{return await x.peekHeader(A),!0}catch{return!1}}static async headerDecode(A){let U=await x.peekHeader(A),_=w(U);return{version:_.version,difficulty:_.difficulty,salt:j(_.salt),saltLength:_.salt.byteLength}}setDifficulty(A){this.difficulty=A}getDifficulty(){return this.difficulty}setVersion(A){this.v=W.get(A),this.cipher=new this.v.cipher(this.provider),this.kdf=this.v.kdf,this.stream=new B(this.cipher,this.chunkSize)}getVersion(){return this.v.id}setSaltDifficulty(A){this.saltStrength=A}getSaltDifficulty(){return this.saltStrength}setChunkSize(A){this.chunkSize=A,this.stream=new B(this.cipher,this.chunkSize)}getChunkSize(){return this.chunkSize}setVerbose(A){this.log.level=A}getVerbose(){return this.log.level}async encryptText(A,U){try{this.log.log(1,"Start text encryption"),this.log.log(2,"Deriving key for text encryption");let _=this.genSalt();await this.deriveKey(U,_),this.log.log(3,`Salt generated: ${j(_)}, KDF difficulty: ${this.difficulty}`),this.log.log(2,"Encrypting text data");let S=await this.cipher.encryptChunk(typeof A==="string"?new TextEncoder().encode(A):A);this.log.log(3,"Encoding header");let V=l(this.v.id,this.difficulty,this.saltStrength,_);this.log.log(3,"Encoding text");let Y=j(V,S);return this.log.log(1,"Decryption finished"),Y}catch(_){throw new h(_ instanceof Error?_.message:String(_))}}async decryptText(A,U){try{this.log.log(1,"Start text decryption"),this.log.log(3,"Start text decoding");let _=V8(A);this.log.log(3,"Start header decoding"),await x.peekHeader(A);let S=w(_);this.log.log(3,"Trying to get engine");let V=M.getEngine(this.provider,S.version);this.log.log(2,"Deriving key via engine for text decryption"),this.log.log(3,`Salt use: ${j(S.salt)}, KDF difficulty: ${S.difficulty}`),await M.deriveKey(V,U,S.salt,S.difficulty),this.log.log(2,"Decrypting text data");let Y=await V.cipher.decryptChunk(_.slice(S.headerLen));this.log.log(3,"Decoding text");let P=new TextDecoder().decode(Y);return this.log.log(1,"Decryption finished"),P}catch(_){if(_ instanceof Z||_ instanceof I||_ instanceof D||_ instanceof E||_ instanceof K)throw _;throw new Z("Decryption failed: wrong passphrase or corrupted ciphertext")}}async encryptFile(A,U){try{this.log.log(2,"Deriving key for file encryption");let _=this.genSalt();await this.deriveKey(U,_);let S=l(this.v.id,this.difficulty,this.saltStrength,_),V=await this.stream.collect(A.stream(),new v(this.cipher,this.chunkSize).toTransformStream(),S);return new Blob([V],{type:"application/octet-stream"})}catch(_){throw new h(_ instanceof Error?_.message:String(_))}}async decryptFile(A,U){try{let _=await x.peekHeader(A),S=w(_),V=M.getEngine(this.provider,S.version);await M.deriveKey(V,U,S.salt,S.difficulty),this.log.log(2,"Decrypting file data");let P=await new B(V.cipher,V.chunkSize).collect(A.slice(S.headerLen).stream(),new L(V.cipher,V.chunkSize).toTransformStream());return new Blob([P],{type:"application/octet-stream"})}catch(_){if(_ instanceof Z)throw _;throw new Z(_ instanceof Error?_.message:String(_))}}async createEncryptionStream(A){this.log.log(2,"Deriving key for stream encryption");let U=this.genSalt();await this.deriveKey(A,U);let _=l(this.v.id,this.difficulty,this.saltStrength,U),S=this.stream.encryptionStream();return{header:_,writable:S.writable,readable:S.readable}}async createDecryptionStream(A){let U=this,_=new Uint8Array(0),S=null;async function V(Y,P){let $=Y.getReader();while(!0){let{value:z,done:J}=await $.read();if(J)break;P.enqueue(z)}}return new TransformStream({async transform(Y,P){if(!S){if(_=k(_,Y),_.length<2)return;let z=_.slice(0,30),{salt:J,difficulty:O}=w(z),X=_[1]>>5,Q=_[1]>>2&1?"high":"low",F=2+W.get(X).saltLengths[Q];if(_.length<F)return;let d=M.getEngine(U.provider,X);await M.deriveKey(d,A,J,O),S=new L(d.cipher,d.chunkSize).toTransformStream(),V(S.readable,P);let Y8=_.slice(F);if(Y8.length){let P8=S.writable.getWriter();await P8.write(Y8),P8.releaseLock()}return}let $=S.writable.getWriter();await $.write(Y),$.releaseLock()},async flush(){if(S){let Y=S.writable.getWriter();await Y.close(),Y.releaseLock()}}})}async deriveKey(A,U,_=this.difficulty){let S=performance.now();try{let V=await this.kdf.derive(A,U,_,this.provider);this.cipher.key=V,this.log.log(3,`Key derivation completed in ${(performance.now()-S).toFixed(1)} ms`)}catch(V){throw new K(V instanceof Error?V.message:String(V))}}genSalt(){let A=this.v.saltLengths[this.saltStrength];return this.provider.getRandomValues(new Uint8Array(A))}static async peekHeader(A){if(typeof A==="string")A=V8(A);if(A instanceof Uint8Array){if(A.length<2)throw new I("Input too short");let{headerLen:U}=w(A.length>=16?A:Uint8Array.from(A));if(A.length<U)throw new I("Incomplete header");return A.slice(0,U)}if(A instanceof Blob){let U=new Uint8Array(await A.slice(0,2).arrayBuffer());if(U[0]!==1)throw new I("Invalid input format. The input is unknown.");let _=U[1],S=_>>5,V=_>>2&1?"high":"low",Y=W.get(S).saltLengths[V],P=new Uint8Array(await A.slice(0,2+Y).arrayBuffer());return w(P),P}throw new D("Unsupported input type")}}var o=require("node:crypto"),g8={subtle:o.webcrypto.subtle,getRandomValues(A){return o.randomFillSync(A),A},isNode:!0};function GA(A){return new x(g8,A)}

//# debugId=C37CBD187C4BA7FE64756E2164756E21
