var V0=Object.create;var{getPrototypeOf:I0,defineProperty:SU,getOwnPropertyNames:dU,getOwnPropertyDescriptor:H0}=Object,iU=Object.prototype.hasOwnProperty;var MU=(U,$,J)=>{J=U!=null?V0(I0(U)):{};let Z=$||!U||!U.__esModule?SU(J,"default",{value:U,enumerable:!0}):J;for(let q of dU(U))if(!iU.call(Z,q))SU(Z,q,{get:()=>U[q],enumerable:!0});return Z},cU=new WeakMap,R0=(U)=>{var $=cU.get(U),J;if($)return $;if($=SU({},"__esModule",{value:!0}),U&&typeof U==="object"||typeof U==="function")dU(U).map((Z)=>!iU.call($,Z)&&SU($,Z,{get:()=>U[Z],enumerable:!(J=H0(U,Z))||J.enumerable}));return cU.set(U,$),$};var S0=(U,$)=>{for(var J in $)SU(U,J,{get:$[J],enumerable:!0,configurable:!0,set:(Z)=>$[J]=()=>Z})};var x0={};S0(x0,{createCryptit:()=>h0,Cryptit:()=>a,ConvertibleOutput:()=>RU,ConvertibleInput:()=>r});module.exports=R0(x0);class e extends Error{constructor(U){super(U);Object.setPrototypeOf(this,new.target.prototype),this.name=new.target.name,this.stack=void 0}}class d extends e{}class XU extends e{}class bU extends e{}class DU extends e{}class QU extends e{}class UU extends e{}class i extends e{}class f extends e{}class x{static byId=new Map;static register(U){if(this.byId.has(U.id))throw new DU(`Scheme ${U.id} already registered`);this.byId.set(U.id,U)}static get(U){let $=this.byId.get(U);if(!$)throw new DU(`Unknown scheme: ${U}`);return $}static get current(){return this.get(0)}}class $U{p;padding=null;headerAAD=new Uint8Array(0);padAADMode="auto";padAlign=8;allowLegacyAADFallback=!0;legacyFallbackPolicy="auto";tryEmptyAADOnLegacyFallback=!1;setLegacyAADFallback(U={}){if(U.enabled!==void 0)this.allowLegacyAADFallback=!!U.enabled;if(U.policy)this.legacyFallbackPolicy=U.policy;if(U.tryEmptyAAD!==void 0)this.tryEmptyAADOnLegacyFallback=!!U.tryEmptyAAD}static PAD_AAD_MAGIC=new Uint8Array([80,65,68,49]);static PAD_AAD_VER=1;constructor(U){this.p=U}setPaddingScheme(U){this.padding=U}setPaddingAADMode(U){this.padAADMode=U}setPaddingAlign(U){if(!Number.isInteger(U)||U<1||U>255)throw Error("padAlign must be 1..255");this.padAlign=U|0}setAAD(U){this.headerAAD=U&&U.byteLength?new Uint8Array(U):new Uint8Array(0)}async encryptChunk(U){let $=this.resolveMode(),J=U;if($==="require"){if(!this.padding)throw Error("Padding required but no scheme set");let Y=(Q)=>this.p.getRandomValues(new Uint8Array(Q));J=this.padding.pad(U,Y,this.padAlign)}let Z=this.composeAAD($),q=await this.encryptWithAAD(J,Z);if(U.fill(0),J!==U)J.fill(0);return q}async decryptChunk(U){let $=this.resolveMode(),J=this.composeAAD($);try{let Z=await this.decryptWithAAD(U,J);return this.enforcePolicyAfterDecrypt(Z,$)}catch(Z){if(!this.allowLegacyAADFallback)throw Z;let q=[];if(this.headerAAD.length)q.push(this.headerAAD);if(this.tryEmptyAADOnLegacyFallback)q.push(new Uint8Array(0));let Y=Z;for(let Q of q)try{let K=await this.decryptWithAAD(U,Q),w=this.legacyFallbackPolicy==="auto"?"auto":this.legacyFallbackPolicy;return this.enforcePolicyAfterDecrypt(K,w)}catch(K){Y=K}throw Y}}enforcePolicyAfterDecrypt(U,$){if(!this.padding){if($==="require")throw new f("Expected padding but no scheme configured");return U}let{used:J,plain:Z}=this.padding.tryUnpad(U);if($==="require"){if(!J)throw new f("Expected padding trailer not found");return new Uint8Array(Z)}if($==="forbid"){if(J)throw new f("Padding forbidden by policy");return U}return J?new Uint8Array(Z):U}resolveMode(){if(this.padAADMode==="auto")return this.padding?"require":"forbid";return this.padAADMode}buildPadAAD(U){let $=U==="require"?0:1,J=new Uint8Array($U.PAD_AAD_MAGIC.length+1+1+1),Z=0;return J.set($U.PAD_AAD_MAGIC,Z),Z+=$U.PAD_AAD_MAGIC.length,J[Z++]=$U.PAD_AAD_VER&255,J[Z++]=$,J[Z++]=this.padAlign&255,J}composeAAD(U){let $=this.buildPadAAD(U);if(!this.headerAAD.length)return $;let J=new Uint8Array(this.headerAAD.length+$.length);return J.set(this.headerAAD,0),J.set($,this.headerAAD.length),J}}class s extends $U{static IV_LENGTH=12;static TAG_LENGTH=16;IV_LENGTH=s.IV_LENGTH;TAG_LENGTH=s.TAG_LENGTH;key=null;constructor(U){super(U)}async setKey(U){this.key=U}zeroKey(){this.key=null}async encryptWithAAD(U,$){let J=this.p.getRandomValues(new Uint8Array(s.IV_LENGTH)),Z={name:"AES-GCM",iv:J,additionalData:$},q=await this.p.subtle.encrypt(Z,this.requireKey(),U),Y=new Uint8Array(q),Q=new Uint8Array(J.length+Y.length);return Q.set(J,0),Q.set(Y,J.length),Q}async decryptWithAAD(U,$){if(U.byteLength<s.IV_LENGTH+s.TAG_LENGTH)throw new f("Invalid ciphertext: too short.");let J=U.subarray(0,s.IV_LENGTH),Z=U.subarray(s.IV_LENGTH),q={name:"AES-GCM",iv:J,additionalData:$};try{let Y=await this.p.subtle.decrypt(q,this.requireKey(),Z);return new Uint8Array(Y)}catch{throw new f("Decryption failed: wrong passphrase or corrupted ciphertext")}}requireKey(){if(!this.key)throw Error("Encryption key not set");return this.key}}/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function j0(U){return U instanceof Uint8Array||ArrayBuffer.isView(U)&&U.constructor.name==="Uint8Array"}function PU(U){if(typeof U!=="boolean")throw Error(`boolean expected, not ${U}`)}function mU(U){if(!Number.isSafeInteger(U)||U<0)throw Error("positive integer expected, got "+U)}function l(U,$,J=""){let Z=j0(U),q=U?.length,Y=$!==void 0;if(!Z||Y&&q!==$){let Q=J&&`"${J}" `,K=Y?` of length ${$}`:"",w=Z?`length=${q}`:`type=${typeof U}`;throw Error(Q+"expected Uint8Array"+K+", got "+w)}return U}function fU(U,$=!0){if(U.destroyed)throw Error("Hash instance has been destroyed");if($&&U.finished)throw Error("Hash#digest() has already been called")}function sU(U,$){l(U,void 0,"output");let J=$.outputLen;if(U.length<J)throw Error("digestInto() expects output buffer of length at least "+J)}function JU(U){return new Uint32Array(U.buffer,U.byteOffset,Math.floor(U.byteLength/4))}function ZU(...U){for(let $=0;$<U.length;$++)U[$].fill(0)}function B0(U){return new DataView(U.buffer,U.byteOffset,U.byteLength)}var v0=(()=>new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68)();function nU(U,$){if($==null||typeof $!=="object")throw Error("options must be defined");return Object.assign(U,$)}function oU(U,$){if(U.length!==$.length)return!1;let J=0;for(let Z=0;Z<U.length;Z++)J|=U[Z]^$[Z];return J===0}var gU=(U,$)=>{function J(Z,...q){if(l(Z,void 0,"key"),!v0)throw Error("Non little-endian hardware is not yet supported");if(U.nonceLength!==void 0){let N=q[0];l(N,U.varSizeNonce?void 0:U.nonceLength,"nonce")}let Y=U.tagLength;if(Y&&q[1]!==void 0)l(q[1],void 0,"AAD");let Q=$(Z,...q),K=(N,G)=>{if(G!==void 0){if(N!==2)throw Error("cipher output not supported");l(G,void 0,"output")}},w=!1;return{encrypt(N,G){if(w)throw Error("cannot encrypt() twice with same key + nonce");return w=!0,l(N),K(Q.encrypt.length,G),Q.encrypt(N,G)},decrypt(N,G){if(l(N),Y&&N.length<Y)throw Error('"ciphertext" expected length bigger than tagLength='+Y);return K(Q.decrypt.length,G),Q.decrypt(N,G)}}}return Object.assign(J,U),J};function yU(U,$,J=!0){if($===void 0)return new Uint8Array(U);if($.length!==U)throw Error('"output" expected Uint8Array of length '+U+", got: "+$.length);if(J&&!M0($))throw Error("invalid output, must be aligned");return $}function rU(U,$,J){PU(J);let Z=new Uint8Array(16),q=B0(Z);return q.setBigUint64(0,BigInt($),J),q.setBigUint64(8,BigInt(U),J),Z}function M0(U){return U.byteOffset%4===0}function zU(U){return Uint8Array.from(U)}var tU=(U)=>Uint8Array.from(U.split(""),($)=>$.charCodeAt(0)),D0=tU("expand 16-byte k"),P0=tU("expand 32-byte k"),m0=JU(D0),_0=JU(P0);function W(U,$){return U<<$|U>>>32-$}function lU(U){return U.byteOffset%4===0}var _U=64,A0=16,eU=4294967295,aU=Uint32Array.of();function L0(U,$,J,Z,q,Y,Q,K){let w=q.length,O=new Uint8Array(_U),N=JU(O),G=lU(q)&&lU(Y),V=G?JU(q):aU,I=G?JU(Y):aU;for(let z=0;z<w;Q++){if(U($,J,Z,N,Q,K),Q>=eU)throw Error("arx: counter overflow");let X=Math.min(_U,w-z);if(G&&X===_U){let H=z/4;if(z%4!==0)throw Error("arx: invalid block position");for(let F=0,S;F<A0;F++)S=H+F,I[S]=V[S]^N[F];z+=_U;continue}for(let H=0,F;H<X;H++)F=z+H,Y[F]=q[F]^O[H];z+=X}}function uU(U,$){let{allowShortKeys:J,extendNonceFn:Z,counterLength:q,counterRight:Y,rounds:Q}=nU({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},$);if(typeof U!=="function")throw Error("core must be a function");return mU(q),mU(Q),PU(Y),PU(J),(K,w,O,N,G=0)=>{l(K,void 0,"key"),l(w,void 0,"nonce"),l(O,void 0,"data");let V=O.length;if(N===void 0)N=new Uint8Array(V);if(l(N,void 0,"output"),mU(G),G<0||G>=eU)throw Error("arx: counter overflow");if(N.length<V)throw Error(`arx: output (${N.length}) is shorter than data (${V})`);let I=[],z=K.length,X,H;if(z===32)I.push(X=zU(K)),H=_0;else if(z===16&&J)X=new Uint8Array(32),X.set(K),X.set(K,16),H=m0,I.push(X);else throw l(K,32,"arx key"),Error("invalid key size");if(!lU(w))I.push(w=zU(w));let F=JU(X);if(Z){if(w.length!==24)throw Error("arx: extended nonce must be 24 bytes");Z(H,F,JU(w.subarray(0,16)),F),w=w.subarray(16)}let S=16-q;if(S!==w.length)throw Error(`arx: nonce must be ${S} or 16 bytes`);if(S!==12){let g=new Uint8Array(12);g.set(w,Y?0:12-w.length),w=g,I.push(w)}let R=JU(w);return L0(U,H,F,R,O,N,G,Q),ZU(...I),N}}function u(U,$){return U[$++]&255|(U[$++]&255)<<8}class U0{blockLen=16;outputLen=16;buffer=new Uint8Array(16);r=new Uint16Array(10);h=new Uint16Array(10);pad=new Uint16Array(8);pos=0;finished=!1;constructor(U){U=zU(l(U,32,"key"));let $=u(U,0),J=u(U,2),Z=u(U,4),q=u(U,6),Y=u(U,8),Q=u(U,10),K=u(U,12),w=u(U,14);this.r[0]=$&8191,this.r[1]=($>>>13|J<<3)&8191,this.r[2]=(J>>>10|Z<<6)&7939,this.r[3]=(Z>>>7|q<<9)&8191,this.r[4]=(q>>>4|Y<<12)&255,this.r[5]=Y>>>1&8190,this.r[6]=(Y>>>14|Q<<2)&8191,this.r[7]=(Q>>>11|K<<5)&8065,this.r[8]=(K>>>8|w<<8)&8191,this.r[9]=w>>>5&127;for(let O=0;O<8;O++)this.pad[O]=u(U,16+2*O)}process(U,$,J=!1){let Z=J?0:2048,{h:q,r:Y}=this,Q=Y[0],K=Y[1],w=Y[2],O=Y[3],N=Y[4],G=Y[5],V=Y[6],I=Y[7],z=Y[8],X=Y[9],H=u(U,$+0),F=u(U,$+2),S=u(U,$+4),R=u(U,$+6),g=u(U,$+8),YU=u(U,$+10),p=u(U,$+12),h=u(U,$+14),j=q[0]+(H&8191),B=q[1]+((H>>>13|F<<3)&8191),v=q[2]+((F>>>10|S<<6)&8191),M=q[3]+((S>>>7|R<<9)&8191),D=q[4]+((R>>>4|g<<12)&8191),P=q[5]+(g>>>1&8191),m=q[6]+((g>>>14|YU<<2)&8191),_=q[7]+((YU>>>11|p<<5)&8191),A=q[8]+((p>>>8|h<<8)&8191),L=q[9]+(h>>>5|Z),T=0,C=T+j*Q+B*(5*X)+v*(5*z)+M*(5*I)+D*(5*V);T=C>>>13,C&=8191,C+=P*(5*G)+m*(5*N)+_*(5*O)+A*(5*w)+L*(5*K),T+=C>>>13,C&=8191;let k=T+j*K+B*Q+v*(5*X)+M*(5*z)+D*(5*I);T=k>>>13,k&=8191,k+=P*(5*V)+m*(5*G)+_*(5*N)+A*(5*O)+L*(5*w),T+=k>>>13,k&=8191;let b=T+j*w+B*K+v*Q+M*(5*X)+D*(5*z);T=b>>>13,b&=8191,b+=P*(5*I)+m*(5*V)+_*(5*G)+A*(5*N)+L*(5*O),T+=b>>>13,b&=8191;let E=T+j*O+B*w+v*K+M*Q+D*(5*X);T=E>>>13,E&=8191,E+=P*(5*z)+m*(5*I)+_*(5*V)+A*(5*G)+L*(5*N),T+=E>>>13,E&=8191;let t=T+j*N+B*O+v*w+M*K+D*Q;T=t>>>13,t&=8191,t+=P*(5*X)+m*(5*z)+_*(5*I)+A*(5*V)+L*(5*G),T+=t>>>13,t&=8191;let WU=T+j*G+B*N+v*O+M*w+D*K;T=WU>>>13,WU&=8191,WU+=P*Q+m*(5*X)+_*(5*z)+A*(5*I)+L*(5*V),T+=WU>>>13,WU&=8191;let OU=T+j*V+B*G+v*N+M*O+D*w;T=OU>>>13,OU&=8191,OU+=P*K+m*Q+_*(5*X)+A*(5*z)+L*(5*I),T+=OU>>>13,OU&=8191;let NU=T+j*I+B*V+v*G+M*N+D*O;T=NU>>>13,NU&=8191,NU+=P*w+m*K+_*Q+A*(5*X)+L*(5*z),T+=NU>>>13,NU&=8191;let GU=T+j*z+B*I+v*V+M*G+D*N;T=GU>>>13,GU&=8191,GU+=P*O+m*w+_*K+A*Q+L*(5*X),T+=GU>>>13,GU&=8191;let TU=T+j*X+B*z+v*I+M*V+D*G;T=TU>>>13,TU&=8191,TU+=P*N+m*O+_*w+A*K+L*Q,T+=TU>>>13,TU&=8191,T=(T<<2)+T|0,T=T+C|0,C=T&8191,T=T>>>13,k+=T,q[0]=C,q[1]=k,q[2]=b,q[3]=E,q[4]=t,q[5]=WU,q[6]=OU,q[7]=NU,q[8]=GU,q[9]=TU}finalize(){let{h:U,pad:$}=this,J=new Uint16Array(10),Z=U[1]>>>13;U[1]&=8191;for(let Q=2;Q<10;Q++)U[Q]+=Z,Z=U[Q]>>>13,U[Q]&=8191;U[0]+=Z*5,Z=U[0]>>>13,U[0]&=8191,U[1]+=Z,Z=U[1]>>>13,U[1]&=8191,U[2]+=Z,J[0]=U[0]+5,Z=J[0]>>>13,J[0]&=8191;for(let Q=1;Q<10;Q++)J[Q]=U[Q]+Z,Z=J[Q]>>>13,J[Q]&=8191;J[9]-=8192;let q=(Z^1)-1;for(let Q=0;Q<10;Q++)J[Q]&=q;q=~q;for(let Q=0;Q<10;Q++)U[Q]=U[Q]&q|J[Q];U[0]=(U[0]|U[1]<<13)&65535,U[1]=(U[1]>>>3|U[2]<<10)&65535,U[2]=(U[2]>>>6|U[3]<<7)&65535,U[3]=(U[3]>>>9|U[4]<<4)&65535,U[4]=(U[4]>>>12|U[5]<<1|U[6]<<14)&65535,U[5]=(U[6]>>>2|U[7]<<11)&65535,U[6]=(U[7]>>>5|U[8]<<8)&65535,U[7]=(U[8]>>>8|U[9]<<5)&65535;let Y=U[0]+$[0];U[0]=Y&65535;for(let Q=1;Q<8;Q++)Y=(U[Q]+$[Q]|0)+(Y>>>16)|0,U[Q]=Y&65535;ZU(J)}update(U){fU(this),l(U),U=zU(U);let{buffer:$,blockLen:J}=this,Z=U.length;for(let q=0;q<Z;){let Y=Math.min(J-this.pos,Z-q);if(Y===J){for(;J<=Z-q;q+=J)this.process(U,q);continue}if($.set(U.subarray(q,q+Y),this.pos),this.pos+=Y,q+=Y,this.pos===J)this.process($,0,!1),this.pos=0}return this}destroy(){ZU(this.h,this.r,this.buffer,this.pad)}digestInto(U){fU(this),sU(U,this),this.finished=!0;let{buffer:$,h:J}=this,{pos:Z}=this;if(Z){$[Z++]=1;for(;Z<16;Z++)$[Z]=0;this.process($,0,!0)}this.finalize();let q=0;for(let Y=0;Y<8;Y++)U[q++]=J[Y]>>>0,U[q++]=J[Y]>>>8;return U}digest(){let{buffer:U,outputLen:$}=this;this.digestInto(U);let J=U.slice(0,$);return this.destroy(),J}}function E0(U){let $=(Z,q)=>U(q).update(Z).digest(),J=U(new Uint8Array(32));return $.outputLen=J.outputLen,$.blockLen=J.blockLen,$.create=(Z)=>U(Z),$}var $0=(()=>E0((U)=>new U0(U)))();function q0(U,$,J,Z,q,Y=20){let Q=U[0],K=U[1],w=U[2],O=U[3],N=$[0],G=$[1],V=$[2],I=$[3],z=$[4],X=$[5],H=$[6],F=$[7],S=q,R=J[0],g=J[1],YU=J[2],p=Q,h=K,j=w,B=O,v=N,M=G,D=V,P=I,m=z,_=X,A=H,L=F,T=S,C=R,k=g,b=YU;for(let t=0;t<Y;t+=2)p=p+v|0,T=W(T^p,16),m=m+T|0,v=W(v^m,12),p=p+v|0,T=W(T^p,8),m=m+T|0,v=W(v^m,7),h=h+M|0,C=W(C^h,16),_=_+C|0,M=W(M^_,12),h=h+M|0,C=W(C^h,8),_=_+C|0,M=W(M^_,7),j=j+D|0,k=W(k^j,16),A=A+k|0,D=W(D^A,12),j=j+D|0,k=W(k^j,8),A=A+k|0,D=W(D^A,7),B=B+P|0,b=W(b^B,16),L=L+b|0,P=W(P^L,12),B=B+P|0,b=W(b^B,8),L=L+b|0,P=W(P^L,7),p=p+M|0,b=W(b^p,16),A=A+b|0,M=W(M^A,12),p=p+M|0,b=W(b^p,8),A=A+b|0,M=W(M^A,7),h=h+D|0,T=W(T^h,16),L=L+T|0,D=W(D^L,12),h=h+D|0,T=W(T^h,8),L=L+T|0,D=W(D^L,7),j=j+P|0,C=W(C^j,16),m=m+C|0,P=W(P^m,12),j=j+P|0,C=W(C^j,8),m=m+C|0,P=W(P^m,7),B=B+v|0,k=W(k^B,16),_=_+k|0,v=W(v^_,12),B=B+v|0,k=W(k^B,8),_=_+k|0,v=W(v^_,7);let E=0;Z[E++]=Q+p|0,Z[E++]=K+h|0,Z[E++]=w+j|0,Z[E++]=O+B|0,Z[E++]=N+v|0,Z[E++]=G+M|0,Z[E++]=V+D|0,Z[E++]=I+P|0,Z[E++]=z+m|0,Z[E++]=X+_|0,Z[E++]=H+A|0,Z[E++]=F+L|0,Z[E++]=S+T|0,Z[E++]=R+C|0,Z[E++]=g+k|0,Z[E++]=YU+b|0}function C0(U,$,J,Z){let q=U[0],Y=U[1],Q=U[2],K=U[3],w=$[0],O=$[1],N=$[2],G=$[3],V=$[4],I=$[5],z=$[6],X=$[7],H=J[0],F=J[1],S=J[2],R=J[3];for(let YU=0;YU<20;YU+=2)q=q+w|0,H=W(H^q,16),V=V+H|0,w=W(w^V,12),q=q+w|0,H=W(H^q,8),V=V+H|0,w=W(w^V,7),Y=Y+O|0,F=W(F^Y,16),I=I+F|0,O=W(O^I,12),Y=Y+O|0,F=W(F^Y,8),I=I+F|0,O=W(O^I,7),Q=Q+N|0,S=W(S^Q,16),z=z+S|0,N=W(N^z,12),Q=Q+N|0,S=W(S^Q,8),z=z+S|0,N=W(N^z,7),K=K+G|0,R=W(R^K,16),X=X+R|0,G=W(G^X,12),K=K+G|0,R=W(R^K,8),X=X+R|0,G=W(G^X,7),q=q+O|0,R=W(R^q,16),z=z+R|0,O=W(O^z,12),q=q+O|0,R=W(R^q,8),z=z+R|0,O=W(O^z,7),Y=Y+N|0,H=W(H^Y,16),X=X+H|0,N=W(N^X,12),Y=Y+N|0,H=W(H^Y,8),X=X+H|0,N=W(N^X,7),Q=Q+G|0,F=W(F^Q,16),V=V+F|0,G=W(G^V,12),Q=Q+G|0,F=W(F^Q,8),V=V+F|0,G=W(G^V,7),K=K+w|0,S=W(S^K,16),I=I+S|0,w=W(w^I,12),K=K+w|0,S=W(S^K,8),I=I+S|0,w=W(w^I,7);let g=0;Z[g++]=q,Z[g++]=Y,Z[g++]=Q,Z[g++]=K,Z[g++]=H,Z[g++]=F,Z[g++]=S,Z[g++]=R}var k0=uU(q0,{counterRight:!1,counterLength:4,allowShortKeys:!1}),b0=uU(q0,{counterRight:!1,counterLength:8,extendNonceFn:C0,allowShortKeys:!1});var f0=new Uint8Array(16),J0=(U,$)=>{U.update($);let J=$.length%16;if(J)U.update(f0.subarray(J))},g0=new Uint8Array(32);function Z0(U,$,J,Z,q){if(q!==void 0)l(q,void 0,"AAD");let Y=U($,J,g0),Q=rU(Z.length,q?q.length:0,!0),K=$0.create(Y);if(q)J0(K,q);J0(K,Z),K.update(Q);let w=K.digest();return ZU(Y,Q),w}var Y0=(U)=>($,J,Z)=>{return{encrypt(Y,Q){let K=Y.length;Q=yU(K+16,Q,!1),Q.set(Y);let w=Q.subarray(0,-16);U($,J,w,w,1);let O=Z0(U,$,J,w,Z);return Q.set(O,K),ZU(O),Q},decrypt(Y,Q){Q=yU(Y.length-16,Q,!1);let K=Y.subarray(0,-16),w=Y.subarray(-16),O=Z0(U,$,J,K,Z);if(!oU(w,O))throw Error("invalid tag");return Q.set(Y.subarray(0,-16)),U($,J,Q,Q,1),ZU(O),Q}}},T$=gU({blockSize:64,nonceLength:12,tagLength:16},Y0(k0)),pU=gU({blockSize:64,nonceLength:24,tagLength:16},Y0(b0));class n extends $U{static IV_LENGTH=24;static TAG_LENGTH=16;IV_LENGTH=n.IV_LENGTH;TAG_LENGTH=n.TAG_LENGTH;key=null;constructor(U){super(U)}async setKey(U){this.key=new Uint8Array(await this.p.subtle.exportKey("raw",U))}zeroKey(){if(this.key)this.key.fill(0);this.key=null}async encryptWithAAD(U,$){let J=this.p.getRandomValues(new Uint8Array(n.IV_LENGTH)),q=pU(this.requireRawKey(),J,$).encrypt(U),Y=new Uint8Array(J.length+q.length);return Y.set(J,0),Y.set(q,J.length),Y}async decryptWithAAD(U,$){if(U.byteLength<n.IV_LENGTH+n.TAG_LENGTH)throw new f("Invalid ciphertext: too short.");let J=U.subarray(0,n.IV_LENGTH),Z=U.subarray(n.IV_LENGTH),q=pU(this.requireRawKey(),J,$);try{return q.decrypt(Z)}catch{throw new f("Decryption failed: wrong passphrase or corrupted ciphertext")}}requireRawKey(){if(!this.key)throw Error("Encryption key not set");return this.key}}var AU=MU(require("argon2-browser"));async function y0(){if(typeof window<"u")return;if(globalThis.loadArgon2WasmModule)return;try{let{createRequire:U}=await import("node:module"),{readFile:$}=await import("node:fs/promises"),J=U(import.meta.url),Z=J.resolve("argon2-browser/dist/argon2.js"),q=J.resolve("argon2-browser/dist/argon2.wasm");globalThis.loadArgon2WasmModule=async()=>{let Y=new Uint8Array(await $(q));return globalThis.Module={wasmBinary:Y,locateFile:(Q)=>Q==="argon2.wasm"?q:Q},J(Z)}}catch{}}async function Q0(U,$,J,Z){if(Z==="node"){let q=await import("@node-rs/argon2"),Y=typeof U==="string"?Buffer.from(U,"utf8"):Buffer.from(U),K=(await q.hash(Y,{salt:$,timeCost:J.time,memoryCost:J.mem,parallelism:J.parallelism,outputLen:32,algorithm:q.Algorithm.Argon2id})).split("$").pop();if(!K)throw Error("Unexpected argon2 hash format");let w=Buffer.from(K,"base64");return Y.fill(0),{hash:new Uint8Array(w)}}if(Z==="browser")return await y0(),AU.hash({pass:U,salt:$,time:J.time,mem:J.mem,parallelism:J.parallelism,hashLen:32,type:AU.ArgonType.Argon2id}).then((q)=>{if(!q||!q.hash)throw new UU("Failed to produce key derivation");return{hash:q.hash}}).catch((q)=>{let Y=q instanceof Error?q.message:typeof q==="string"?q:"Unknown error";throw new UU(`argon2-browser failure: ${Y}`)});throw Error(`Unsupported environment: ${Z}`)}class LU{presets;exportExtractable;name="argon2id";constructor(U,$=!1){this.presets=U;this.exportExtractable=$}async derive(U,$,J,Z){let{hash:q}=await Q0(U,$,this.presets[J],Z.isNode?"node":"browser");if(this.exportExtractable)return Z.subtle.importKey("raw",q,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]);else return Z.subtle.importKey("raw",q,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}}var K0={low:{time:5,mem:65536,parallelism:1},middle:{time:20,mem:65536,parallelism:1},high:{time:40,mem:65536,parallelism:1}},l0={id:0,cipher:s,kdf:new LU(K0),saltLengths:{low:12,high:16},difficulties:K0,defaultChunkSize:524288};x.register(l0);var w0={low:{time:5,mem:65536,parallelism:2},middle:{time:10,mem:98304,parallelism:4},high:{time:20,mem:98304,parallelism:4}},u0={id:1,cipher:n,kdf:new LU(w0,!0),saltLengths:{low:12,high:16},difficulties:w0,defaultChunkSize:524288};x.register(u0);var EU=1;function W0(){return typeof process<"u"&&typeof process.versions==="object"&&!0}function wU(...U){let $=U.reduce((q,Y)=>q+Y.byteLength,0),J=new Uint8Array($),Z=0;for(let q of U)J.set(q,Z),Z+=q.byteLength;return J}function FU(...U){try{let $=wU(...U);if(W0())return Buffer.from($).toString("base64");let J="";for(let Z=0;Z<$.length;Z++)J+=String.fromCharCode($[Z]);return btoa(J)}catch{throw new bU("Base64 Encoding Error")}}function jU(U){try{if(!/^[A-Za-z0-9+/]+={0,2}$/.test(U)||U.length%4!==0)throw Error("Invalid Base64");if(W0())return new Uint8Array(Buffer.from(U,"base64"));let $=atob(U),J=new Uint8Array($.length);for(let Z=0;Z<$.length;Z++)J[Z]=$.charCodeAt(Z);return J}catch{throw new XU(`Invalid Base64: length=${U.length}, content='${U.slice(0,12)}…'`)}}function c(U){let $=U.value.length,J=Array($).fill("\x00").join("");U.value=J}function VU(U,$,J,Z,q){let Y={low:0,middle:1,high:2};if(!($ in Y))throw TypeError(`Unsupported difficulty: ${$}`);let Q=Y[$],K=U<<5|(J==="high"?1:0)<<2|Q,w=wU(new Uint8Array([EU,K]),Z);if(q)q.setAAD(w);return w}function o(U,$){if(U[0]!==EU)throw new d("Invalid input format. The input is unknown.");if(U.length<14)throw new d("Invalid input format. Header too short.");try{let J=U[1],Z=J>>5,q=J>>2&1?"high":"low",Y=J&3,Q=["low","middle","high"][Y],K=x.get(Z).saltLengths[q],w=2+K;if(U.length<w)throw new d("Invalid input format. Header truncated.");if($)$.setAAD(U.subarray(0,w));let O=U.slice(2,2+K);return{scheme:Z,difficulty:Q,saltStrength:q,salt:O,headerLen:w}}catch(J){throw new QU(J instanceof Error?J.message:String(J))}}async function CU(U){if(U instanceof Uint8Array)return U;if(U instanceof ArrayBuffer)return new Uint8Array(U);return new Uint8Array(await U.arrayBuffer())}function hU(U){let $=new Uint8Array(4);return new DataView($.buffer).setUint32(0,U,!1),$}function O0(U,$=0){if(U.length-$<4)throw RangeError("Not enough bytes for frame header");return new DataView(U.buffer,U.byteOffset+$,4).getUint32(0,!1)}var qU=4;class BU{engine;chunkSize;buffer=new Uint8Array(0);constructor(U,$=524288){this.engine=U;this.chunkSize=$}toTransformStream(){return new TransformStream({transform:async(U,$)=>{await this.transform(await CU(U),$)},flush:async(U)=>this.flush(U)})}async transform(U,$){if(U.length>Math.min(this.chunkSize*4,67108864))throw RangeError(`Input block (${U.length} B) exceeds maximum allowed ${Math.min(this.chunkSize*4,67108864)} B`);let Z=new Uint8Array(this.buffer.length+U.length);Z.set(this.buffer),Z.set(U,this.buffer.length);let q=0;while(Z.length-q>=this.chunkSize){let Y=Z.slice(q,q+this.chunkSize);q+=this.chunkSize;let Q=await this.engine.encryptChunk(Y),K=new Uint8Array(qU+Q.length);K.set(hU(Q.length)),K.set(Q,qU),$.enqueue(K)}this.buffer=Z.slice(q)}async flush(U){if(!this.buffer.length)return;let $=await this.engine.encryptChunk(this.buffer),J=new Uint8Array(qU+$.length);J.set(hU($.length)),J.set($,qU),U.enqueue(J),this.buffer=new Uint8Array(0),this.engine.zeroKey()}}class IU{engine;chunkSize;buffer=new Uint8Array(0);constructor(U,$=524288){this.engine=U;this.chunkSize=$}toTransformStream(){return new TransformStream({transform:async(U,$)=>{await this.transform(await CU(U),$)},flush:async(U)=>this.flush(U)})}async transform(U,$){let J=new Uint8Array(this.buffer.length+U.length);J.set(this.buffer),J.set(U,this.buffer.length);let Z=0;while(!0){if(J.length-Z<qU)break;let q=O0(J,Z);if(q>this.chunkSize*2)throw new f(`Frame length ${q} exceeds …`);if(J.length-Z-qU<q)break;Z+=qU;let Y=J.slice(Z,Z+q);Z+=q;try{let Q=await this.engine.decryptChunk(Y);$.enqueue(Q)}catch(Q){throw Q instanceof f?Q:new f("Decryption failed: Wrong passphrase or corrupted ciphertext")}}this.buffer=J.slice(Z)}async flush(U){await this.transform(new Uint8Array(0),U),this.buffer=new Uint8Array(0),this.engine.zeroKey()}}async function N0(U,$){let J=U.getReader(),Z=$&&$.length?[$]:[];try{while(!0){let{value:K,done:w}=await J.read();if(w)break;Z.push(K)}}finally{J.releaseLock()}let q=Z.reduce((K,w)=>K+w.byteLength,0),Y=new Uint8Array(q),Q=0;for(let K of Z)Y.set(K,Q),Q+=K.byteLength;return Y}class HU{engine;chunkSize;constructor(U,$=524288){this.engine=U;this.chunkSize=$}encryptionStream(){let U=new BU(this.engine,this.chunkSize).toTransformStream();return{writable:U.writable,readable:U.readable}}decryptionStream(U){let $=U,J=new TransformStream({transform(q,Y){if($===0){Y.enqueue(q);return}if(q.byteLength<=$){$-=q.byteLength;return}Y.enqueue(q.slice($)),$=0}}),Z=new IU(this.engine,this.chunkSize).toTransformStream();return{writable:J.writable,readable:J.readable.pipeThrough(Z)}}async collect(U,$,J=null){return N0(U.pipeThrough($),J??void 0)}getEngine(){return this.engine}}function G0(U){try{if(U)U.fill(0)}catch{}}function p0(U){let $="";for(let J=0;J<U.length;J++){let Z=U[J].toString(16).padStart(2,"0");$+=Z}return $}class r{bytes;destroyed=!1;static from(U){if(U instanceof r)return U;if(typeof U==="string")return new r(new TextEncoder().encode(U));if(U instanceof Uint8Array)return new r(U);throw TypeError("ConvertibleInput: unsupported input type")}constructor(U){this.bytes=U}toUint8Array(){if(this.destroyed)throw Error("ConvertibleInput: already cleared");return this.bytes}clear(){if(!this.destroyed)G0(this.bytes),this.bytes=new Uint8Array(0),this.destroyed=!0}}class RU{bytes;destroyed=!1;constructor(U){this.bytes=U}get uint8array(){if(this.destroyed)throw Error("ConvertibleOutput: already cleared");return this.bytes}get base64(){if(this.destroyed)throw Error("ConvertibleOutput: already cleared");return FU(this.bytes)}get hex(){if(this.destroyed)throw Error("ConvertibleOutput: already cleared");return p0(this.bytes)}get text(){if(this.destroyed)throw Error("ConvertibleOutput: already cleared");return new TextDecoder().decode(this.bytes)}clear(){if(!this.destroyed)G0(this.bytes),this.bytes=new Uint8Array(0),this.destroyed=!0}toString(){return this.base64}}class vU extends Error{constructor(U="Malformed padding"){super(U)}}class y{static STRUCT_SIZE=8;static MAGIC40=new Uint8Array([227,122,193,93,180]);static VERSION=41;static CRC8_POLY=7;maxPad=y.STRUCT_SIZE+8-1;static ctEqU8(U,$){return(((U|0)^($|0))&255)===0}static ctEqFixedLen(U,$){let J=0,Z=U.length;for(let q=0;q<Z;q++)J|=U[q]^$[q];return J===0}crc8(U){let $=0;for(let J=0;J<U.length;J++){$^=U[J]&255;for(let Z=0;Z<8;Z++)$=$&128?$<<1^y.CRC8_POLY:$<<1,$&=255}return $&255}computeK(U,$){let J=y.STRUCT_SIZE;if(!Number.isInteger($)||$<1)throw new vU("align must be a positive integer");if(J+$-1>255)throw new vU("align too large for 1-byte LEN");let Z=J+$-1,q=($-U%$)%$;if(q===0)q=$;while(q<J)q+=$;if(q>Z)throw new vU("Cannot satisfy alignment within 1-byte LEN");return q}pad(U,$,J=8){let Z=y.STRUCT_SIZE,q=this.computeK(U.length,J),Y=q-Z,Q=new Uint8Array(U.length+q);if(Q.set(U,0),Y>0){let O=$(Y);if(!O||O.length!==Y)throw new vU("rng returned wrong length");Q.set(O,U.length)}let K=U.length+Y;Q.set(y.MAGIC40,K+0),Q[K+5]=y.VERSION&255,Q[K+6]=q&255;let w=new Uint8Array(7);return w.set(y.MAGIC40,0),w[5]=y.VERSION&255,w[6]=q&255,Q[K+7]=this.crc8(w),Q}tryUnpad(U){let $=y.STRUCT_SIZE,J=()=>({used:!1,plain:U});if(U.length<$)return J();let Z=U.length,q=U[Z-1]&255,Y=U[Z-2]&255,Q=U[Z-3]&255;if(Y<$||Y>U.length)return J();let K=Z-$,w=U.subarray(K,K+5);if(!y.ctEqFixedLen(w,y.MAGIC40))return J();if(!y.ctEqU8(Q,y.VERSION&255))return J();let N=new Uint8Array(7);N.set(y.MAGIC40,0),N[5]=Q,N[6]=Y;let G=this.crc8(N);if(!y.ctEqU8(G,q))return J();return{used:!0,plain:U.subarray(0,Z-Y)}}}function T0(U=0,$=console.info){return{level:U,log(J,Z){if(J<=U)$(`${J}| ${Z}`)}}}function X0(U,$,J){if($<0||J<0||$+J>U)throw RangeError("read() slice exceeds data bounds")}class xU{src;#U=null;constructor(U){this.src=U}get length(){if(this.src instanceof Uint8Array)return this.src.byteLength;if(this.src instanceof Blob)return this.src.size;return this.ensureUint8().byteLength}async read(U,$){if(X0(this.length,U,$),this.src instanceof Uint8Array)return this.src.slice(U,U+$);if(this.src instanceof Blob){let J=await this.src.slice(U,U+$).arrayBuffer();return new Uint8Array(J)}return this.ensureUint8().slice(U,U+$)}ensureUint8(){if(!this.#U)this.#U=jU(this.src);return this.#U}}var z0=new WeakMap;class KU{static getEngine(U,$){let J=z0.get(U);if(!J)J=new Map,z0.set(U,J);let Z=J.get($);if(Z)return Z;let q=x.get($);return Z={desc:q,cipher:new q.cipher(U),kdf:q.kdf,chunkSize:q.defaultChunkSize,provider:U},J.set($,Z),Z}static async deriveKey(U,$,J,Z){try{let q=await U.kdf.derive($.value,J,Z,U.provider);await U.cipher.setKey(q)}catch(q){let Y=q instanceof Error?q.message:String(q);throw new UU(Y)}finally{c($)}}}class a{provider;v;cipher;kdf;chunkSize;stream;acceptUnauthenticatedHeader;difficulty;saltStrength;engines=new Map;log;constructor(U,$={}){this.provider=U;this.v=x.get($.scheme??x.current.id),this.cipher=new this.v.cipher(U),this.kdf=this.v.kdf,this.chunkSize=this.setChunkSize($.chunkSize??this.v.defaultChunkSize),this.stream=new HU(this.cipher,this.chunkSize),this.difficulty=$.difficulty??"middle",this.saltStrength=$.saltStrength??"high",this.acceptUnauthenticatedHeader=$.acceptUnauthenticatedHeader??!1,this.log=T0($.verbose??0,$.logger)}static async isEncrypted(U){try{return await a.peekHeader(U),!0}catch{return!1}}static async decodeHeader(U){let $=await a.peekHeader(U),J=o($);return{scheme:J.scheme,difficulty:J.difficulty,salt:FU(J.salt),saltBytes:J.salt,saltLength:J.salt.byteLength}}static async headerDecode(U){return this.decodeHeader(U)}static isRandomAccessSource(U){return typeof U==="object"&&U!==null&&typeof U.read==="function"}static async decodeData(U){let $=a.isRandomAccessSource(U)?U:new xU(U),J=await $.read(0,Math.min(256,$.length)),Z=await a.peekHeader(J),{scheme:q,headerLen:Y}=o(Z),Q=$.length,K=Q-Y;if(K<=0)throw new d("Payload is empty");let w=await $.read(Y,4),O=new DataView(w.buffer,w.byteOffset,4).getUint32(0,!1);if(O+4<=K&&O>=28){let z=O,X=Y,H=0,F=0;while(X+4<=Q){let S=await $.read(X,4),R=new DataView(S.buffer,S.byteOffset,4).getUint32(0,!1);if(R===0||X+4+R>Q)break;H++,F+=R,X+=4+R}return{isChunked:!0,chunks:{chunkSize:z,count:H,totalPayload:F}}}let G=await $.read(Y,K),V=x.get(q).cipher.IV_LENGTH,I=x.get(q).cipher.TAG_LENGTH;if(G.length<V+I)throw new d("Ciphertext too short for IV & tag");return{isChunked:!1,payloadLength:K-V-I,params:{iv:G.slice(0,V),ivLength:V,tag:G.slice(G.length-I),tagLength:I}}}setDifficulty(U){this.difficulty=U}getDifficulty(){return this.difficulty}setScheme(U){this.v=x.get(U),this.cipher=new this.v.cipher(this.provider),this.kdf=this.v.kdf,this.stream=new HU(this.cipher,this.chunkSize)}getScheme(){return this.v.id}setSaltDifficulty(U){this.saltStrength=U}getSaltDifficulty(){return this.saltStrength}setChunkSize(U){let J=U,Z;if(J==null)Z=this.v.defaultChunkSize;else{if(Z=Number(J),!Number.isInteger(Z)||Z<1)throw Error(`Invalid chunkSize: ${J}. Must be a positive integer.`);if(Z>134217728)throw RangeError("chunkSize cannot exceed 134217728 bytes.")}if(this.chunkSize=Z,this.stream)this.stream=new HU(this.cipher,this.chunkSize);return Z}getChunkSize(){return this.chunkSize}setVerbose(U){this.log.level=U}getVerbose(){return this.log.level}async encryptText(U,$){if($===null)throw new i("Password can't be null");let J={value:$};try{if($==="")this.log.log(0,"Empty passphrase provided to encryptText");this.log.log(1,`Start text encryption, scheme: ${this.getScheme()}`);let Z=r.from(U),q=Z.toUint8Array();this.log.log(2,"Deriving key for text encryption");let Y=this.genSalt();await this.deriveKey(J,Y),c(J),$=null,this.log.log(3,`Salt generated: ${FU(Y)}, KDF difficulty: ${this.difficulty}`),this.log.log(3,"Encoding header");let Q=VU(this.v.id,this.difficulty,this.saltStrength,Y,this.cipher);this.cipher.setPaddingScheme(new y),this.cipher.setPaddingAlign(8),this.cipher.setPaddingAADMode("require"),this.log.log(2,"Encrypting text data");let K=await this.cipher.encryptChunk(q);this.cipher.zeroKey();try{Z.clear()}catch{}let w=wU(Q,K);return this.log.log(1,"Encryption finished"),new RU(w)}catch(Z){throw new i(Z instanceof Error?Z.message:String(Z))}}async decryptText(U,$){if($===null)throw new i("Password can't be null");let J={value:$};try{if($==="")this.log.log(0,"Empty passphrase provided to decryptText");this.log.log(1,`Start text decryption, Version ${this.getScheme()}`);let Z;if(typeof U==="string")this.log.log(3,"Decoding Base64 ciphertext"),Z=jU(U);else if(U instanceof Uint8Array)Z=U;else if(U instanceof r)Z=U.toUint8Array();else throw new XU("Unsupported ciphertext input type");this.log.log(3,"Start header decoding");let q=o(Z);this.log.log(3,"Selecting decryption engine");let Y=KU.getEngine(this.provider,q.scheme);this.log.log(2,`Deriving key via engine for scheme: ${q.scheme}`),this.log.log(3,`Salt use: ${FU(q.salt)}, KDF difficulty: ${q.difficulty}`);try{await KU.deriveKey(Y,J,q.salt,q.difficulty)}finally{c(J),$=null}Y.cipher.setPaddingScheme(new y),Y.cipher.setPaddingAlign(8),Y.cipher.setPaddingAADMode("require"),Y.cipher.setLegacyAADFallback({enabled:!0,policy:"auto",tryEmptyAAD:this.acceptUnauthenticatedHeader?!0:!1}),this.log.log(2,"Decrypting text data"),o(Z,Y.cipher);let Q=await Y.cipher.decryptChunk(Z.slice(q.headerLen));if(Y.cipher.zeroKey(),U instanceof r)try{U.clear()}catch{}return this.log.log(1,"Decryption finished"),new RU(Q)}catch(Z){if(Z instanceof f||Z instanceof d||Z instanceof QU||Z instanceof XU||Z instanceof UU)throw Z;throw new f("Decryption failed: wrong passphrase or corrupted ciphertext")}}async encryptFile(U,$){if($===null)throw new i("Password can't be null");let J={value:$};try{if(U.size===0){let Q=this.genSalt();await this.deriveKey(J,Q),c(J),$=null;let K=VU(this.v.id,this.difficulty,this.saltStrength,Q);return new Blob([K],{type:"application/octet-stream"})}this.log.log(2,"Deriving key for file encryption");let Z=this.genSalt();await this.deriveKey(J,Z),c(J),$=null;let q=VU(this.v.id,this.difficulty,this.saltStrength,Z,this.stream.getEngine());this.stream.getEngine().setPaddingAADMode("forbid");let Y=await this.stream.collect(U.stream(),new BU(this.cipher,this.chunkSize).toTransformStream(),q);return new Blob([Y],{type:"application/octet-stream"})}catch(Z){throw new i(Z instanceof Error?Z.message:String(Z))}}async decryptFile(U,$){if($===null)throw new i("Password can't be null");let J={value:$};try{let Z=await a.peekHeader(U),q=o(Z),Y=KU.getEngine(this.provider,q.scheme);try{await KU.deriveKey(Y,J,q.salt,q.difficulty)}finally{c(J),$=null}if(U.size===q.headerLen)return new Blob([],{type:"application/octet-stream"});this.log.log(2,"Decrypting file data");let Q=new HU(Y.cipher,Y.chunkSize);o(Z,Q.getEngine()),Y.cipher.setPaddingAADMode("forbid"),Y.cipher.setLegacyAADFallback({enabled:!0,policy:"auto",tryEmptyAAD:this.acceptUnauthenticatedHeader?!0:!1});let K=await Q.collect(U.slice(q.headerLen).stream(),new IU(Y.cipher,Y.chunkSize).toTransformStream());return new Blob([K],{type:"application/octet-stream"})}catch(Z){if(Z instanceof f)throw Z;throw new f(Z instanceof Error?Z.message:String(Z))}}async createEncryptionStream(U){if(U===null)throw new i("Password can't be null");let $={value:U};this.log.log(2,"Deriving key for stream encryption");let J=this.genSalt();await this.deriveKey($,J),c($),U=null;let Z=VU(this.v.id,this.difficulty,this.saltStrength,J,this.stream.getEngine());this.stream.getEngine().setPaddingAADMode("forbid");let q=this.stream.encryptionStream();return{header:Z,writable:q.writable,readable:q.readable}}async createDecryptionStream(U){if(U===null)throw new i("Password can't be null");let $=this.provider,J={value:U},Z=new Uint8Array(0),q=null,Y=65536,Q=14,K=async(w,O)=>{let N=w.getReader();while(!0){let{value:G,done:V}=await N.read();if(V)break;O.enqueue(G)}};return new TransformStream({transform:async(w,O)=>{if(!q){if(w&&w.byteLength){if(Z.byteLength+w.byteLength>Y){c(J),O.error(new d(`Header not found within ${Y} bytes`));return}Z=wU(Z,w)}if(Z.byteLength<Q)return;let G=Z[1],V=G>>5,I=G>>2&1?"high":"low",z=0;try{z=2+x.get(V).saltLengths[I]}catch(R){c(J),O.error(new QU(R instanceof Error?R.message:String(R)));return}if(Z.byteLength<z)return;let X=Z.subarray(0,z),H;try{H=o(X)}catch(R){c(J),O.error(R instanceof Error?R:new QU("Invalid header"));return}let F=KU.getEngine($,H.scheme);try{await KU.deriveKey(F,J,H.salt,H.difficulty)}finally{c(J),U=null}o(X,F.cipher),F.cipher.setPaddingAADMode("forbid"),F.cipher.setLegacyAADFallback({enabled:!0,policy:"auto",tryEmptyAAD:this.acceptUnauthenticatedHeader?!0:!1}),q=new IU(F.cipher,F.chunkSize).toTransformStream(),K(q.readable,O).catch((R)=>O.error(R));let S=Z.subarray(z);if(Z=new Uint8Array(0),S.byteLength){let R=q.writable.getWriter();await R.write(S),R.releaseLock()}return}let N=q.writable.getWriter();await N.write(w),N.releaseLock()},flush:async()=>{if(!q)throw c(J),new d("Header not found before end of stream");let w=q.writable.getWriter();await w.close(),w.releaseLock()}})}generateFakeData(U=0){if(!Number.isInteger(U)||U<0)throw RangeError("payloadLength must be a non-negative integer.");let $=this.genSalt(),J=VU(this.v.id,this.difficulty,this.saltStrength,$,this.cipher),Z=U>0?this.provider.getRandomValues(new Uint8Array(U)):new Uint8Array(0);return wU(J,Z)}async deriveKey(U,$,J=this.difficulty){let Z=performance.now();try{let q=await this.kdf.derive(U.value,$,J,this.provider);c(U),await this.cipher.setKey(q),this.log.log(3,`Key derivation completed in ${(performance.now()-Z).toFixed(1)} ms`)}catch(q){throw new UU(q instanceof Error?q.message:String(q))}}genSalt(U=this.saltStrength){let $=this.v.saltLengths[U];return this.provider.getRandomValues(new Uint8Array($))}static async peekHeader(U){let $=await this.readAsUint8(U);if($ instanceof Uint8Array){if($.length<2)throw new d("Input too short");let{headerLen:J}=o($.length>=16?$:Uint8Array.from($));if($.length<J)throw new d("Incomplete header");return $.slice(0,J)}throw new QU("Unsupported input type")}static async readAsUint8(U){if(typeof U==="string")return jU(U);if(U instanceof Blob){let $=U.slice(0,64);return new Uint8Array(await $.arrayBuffer())}return U}}var kU=require("node:crypto"),F0={subtle:kU.webcrypto.subtle,getRandomValues(U){return kU.randomFillSync(U),U},isNode:!0};function h0(U){return new a(F0,U)}

//# debugId=E92C55182D7067E664756E2164756E21
