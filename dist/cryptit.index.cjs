var w0=Object.create;var{getPrototypeOf:F0,defineProperty:wU,getOwnPropertyNames:uU,getOwnPropertyDescriptor:I0}=Object,hU=Object.prototype.hasOwnProperty;var SU=(U,$,Q)=>{Q=U!=null?w0(F0(U)):{};let J=$||!U||!U.__esModule?wU(Q,"default",{value:U,enumerable:!0}):Q;for(let W of uU(U))if(!hU.call(J,W))wU(J,W,{get:()=>U[W],enumerable:!0});return J},dU=new WeakMap,R0=(U)=>{var $=dU.get(U),Q;if($)return $;if($=wU({},"__esModule",{value:!0}),U&&typeof U==="object"||typeof U==="function")uU(U).map((J)=>!hU.call($,J)&&wU($,J,{get:()=>U[J],enumerable:!(Q=I0(U,J))||Q.enumerable}));return dU.set(U,$),$};var M0=(U,$)=>{for(var Q in $)wU(U,Q,{get:$[Q],enumerable:!0,configurable:!0,set:(J)=>$[Q]=()=>J})};var u0={};M0(u0,{createCryptit:()=>d0,Cryptit:()=>s,ConvertibleOutput:()=>zU,ConvertibleInput:()=>n});module.exports=R0(u0);class r extends Error{constructor(U){super(U);Object.setPrototypeOf(this,new.target.prototype),this.name=new.target.name,this.stack=void 0}}class h extends r{}class NU extends r{}class kU extends r{}class AU extends r{}class QU extends r{}class a extends r{}class x extends r{}class d extends r{}class p{static byId=new Map;static register(U){if(this.byId.has(U.id))throw new AU(`Scheme ${U.id} already registered`);this.byId.set(U.id,U)}static get(U){let $=this.byId.get(U);if(!$)throw new AU(`Unknown scheme: ${U}`);return $}static get current(){return this.get(0)}}class WU{p;static IV_LENGTH=12;static TAG_LENGTH=16;IV_LENGTH=WU.IV_LENGTH;TAG_LENGTH=WU.TAG_LENGTH;key;aad=new Uint8Array(0);constructor(U){this.p=U}async setKey(U){this.key=U}async encryptChunk(U){let $=this.p.getRandomValues(new Uint8Array(WU.IV_LENGTH)),Q=this.aad.length?{name:"AES-GCM",iv:$,additionalData:this.aad}:{name:"AES-GCM",iv:$},J=await this.p.subtle.encrypt(Q,this.requireKey(),U),W=new Uint8Array(J);U.fill(0);let Z=new Uint8Array($.length+W.length);return Z.set($,0),Z.set(W,$.length),Z}async decryptChunk(U){let $=U.slice(0,WU.IV_LENGTH),Q=U.slice(WU.IV_LENGTH),J=this.aad.length?{name:"AES-GCM",iv:$,additionalData:this.aad}:{name:"AES-GCM",iv:$};try{let W=await this.p.subtle.decrypt(J,this.requireKey(),Q);return new Uint8Array(W)}catch{throw new d("Decryption failed: wrong passphrase or corrupted ciphertext")}}zeroKey(){this.key=null}setAAD(U){this.aad=U&&U.byteLength?new Uint8Array(U):new Uint8Array(0)}requireKey(){if(!this.key)throw new Error("Encryption key not set");return this.key}}/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function iU(U){return U instanceof Uint8Array||ArrayBuffer.isView(U)&&U.constructor.name==="Uint8Array"}function HU(U){if(typeof U!=="boolean")throw new Error(`boolean expected, not ${U}`)}function BU(U){if(!Number.isSafeInteger(U)||U<0)throw new Error("positive integer expected, got "+U)}function c(U,...$){if(!iU(U))throw new Error("Uint8Array expected");if($.length>0&&!$.includes(U.length))throw new Error("Uint8Array expected of length "+$+", got length="+U.length)}function gU(U,$=!0){if(U.destroyed)throw new Error("Hash instance has been destroyed");if($&&U.finished)throw new Error("Hash#digest() has already been called")}function nU(U,$){c(U);let Q=$.outputLen;if(U.length<Q)throw new Error("digestInto() expects output buffer of length at least "+Q)}function t(U){return new Uint32Array(U.buffer,U.byteOffset,Math.floor(U.byteLength/4))}function e(...U){for(let $=0;$<U.length;$++)U[$].fill(0)}function S0(U){return new DataView(U.buffer,U.byteOffset,U.byteLength)}var A0=(()=>new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68)();function H0(U){if(typeof U!=="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(U))}function DU(U){if(typeof U==="string")U=H0(U);else if(iU(U))U=mU(U);else throw new Error("Uint8Array expected, got "+typeof U);return U}function sU(U,$){if($==null||typeof $!=="object")throw new Error("options must be defined");return Object.assign(U,$)}function oU(U,$){if(U.length!==$.length)return!1;let Q=0;for(let J=0;J<U.length;J++)Q|=U[J]^$[J];return Q===0}var bU=(U,$)=>{function Q(J,...W){if(c(J),!A0)throw new Error("Non little-endian hardware is not yet supported");if(U.nonceLength!==void 0){let N=W[0];if(!N)throw new Error("nonce / iv required");if(U.varSizeNonce)c(N);else c(N,U.nonceLength)}let Z=U.tagLength;if(Z&&W[1]!==void 0)c(W[1]);let V=$(J,...W),Y=(N,X)=>{if(X!==void 0){if(N!==2)throw new Error("cipher output not supported");c(X)}},q=!1;return{encrypt(N,X){if(q)throw new Error("cannot encrypt() twice with same key + nonce");return q=!0,c(N),Y(V.encrypt.length,X),V.encrypt(N,X)},decrypt(N,X){if(c(N),Z&&N.length<Z)throw new Error("invalid ciphertext length: smaller than tagLength="+Z);return Y(V.decrypt.length,X),V.decrypt(N,X)}}}return Object.assign(Q,U),Q};function fU(U,$,Q=!0){if($===void 0)return new Uint8Array(U);if($.length!==U)throw new Error("invalid output length, expected "+U+", got: "+$.length);if(Q&&!B0($))throw new Error("invalid output, must be aligned");return $}function xU(U,$,Q,J){if(typeof U.setBigUint64==="function")return U.setBigUint64($,Q,J);let W=BigInt(32),Z=BigInt(4294967295),V=Number(Q>>W&Z),Y=Number(Q&Z),q=J?4:0,G=J?0:4;U.setUint32($+q,V,J),U.setUint32($+G,Y,J)}function rU(U,$,Q){HU(Q);let J=new Uint8Array(16),W=S0(J);return xU(W,0,BigInt($),Q),xU(W,8,BigInt(U),Q),J}function B0(U){return U.byteOffset%4===0}function mU(U){return Uint8Array.from(U)}var tU=(U)=>Uint8Array.from(U.split("").map(($)=>$.charCodeAt(0))),D0=tU("expand 16-byte k"),m0=tU("expand 32-byte k"),j0=t(D0),v0=t(m0);function K(U,$){return U<<$|U>>>32-$}function yU(U){return U.byteOffset%4===0}var jU=64,L0=16,eU=4294967295,aU=new Uint32Array;function _0(U,$,Q,J,W,Z,V,Y){let q=W.length,G=new Uint8Array(jU),N=t(G),X=yU(W)&&yU(Z),z=X?t(W):aU,w=X?t(Z):aU;for(let O=0;O<q;V++){if(U($,Q,J,N,V,Y),V>=eU)throw new Error("arx: counter overflow");let P=Math.min(jU,q-O);if(X&&P===jU){let I=O/4;if(O%4!==0)throw new Error("arx: invalid block position");for(let F=0,M;F<L0;F++)M=I+F,w[M]=z[M]^N[F];O+=jU;continue}for(let I=0,F;I<P;I++)F=O+I,Z[F]=W[F]^G[I];O+=P}}function lU(U,$){let{allowShortKeys:Q,extendNonceFn:J,counterLength:W,counterRight:Z,rounds:V}=sU({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},$);if(typeof U!=="function")throw new Error("core must be a function");return BU(W),BU(V),HU(Z),HU(Q),(Y,q,G,N,X=0)=>{c(Y),c(q),c(G);let z=G.length;if(N===void 0)N=new Uint8Array(z);if(c(N),BU(X),X<0||X>=eU)throw new Error("arx: counter overflow");if(N.length<z)throw new Error(`arx: output (${N.length}) is shorter than data (${z})`);let w=[],O=Y.length,P,I;if(O===32)w.push(P=mU(Y)),I=v0;else if(O===16&&Q)P=new Uint8Array(32),P.set(Y),P.set(Y,16),I=j0,w.push(P);else throw new Error(`arx: invalid 32-byte key, got length=${O}`);if(!yU(q))w.push(q=mU(q));let F=t(P);if(J){if(q.length!==24)throw new Error("arx: extended nonce must be 24 bytes");J(I,F,t(q.subarray(0,16)),F),q=q.subarray(16)}let M=16-W;if(M!==q.length)throw new Error(`arx: nonce must be ${M} or 16 bytes`);if(M!==12){let b=new Uint8Array(12);b.set(q,Z?0:12-q.length),q=b,w.push(q)}let R=t(q);return _0(U,I,F,R,G,N,X,V),e(...w),N}}var f=(U,$)=>U[$++]&255|(U[$++]&255)<<8;class U0{constructor(U){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,U=DU(U),c(U,32);let $=f(U,0),Q=f(U,2),J=f(U,4),W=f(U,6),Z=f(U,8),V=f(U,10),Y=f(U,12),q=f(U,14);this.r[0]=$&8191,this.r[1]=($>>>13|Q<<3)&8191,this.r[2]=(Q>>>10|J<<6)&7939,this.r[3]=(J>>>7|W<<9)&8191,this.r[4]=(W>>>4|Z<<12)&255,this.r[5]=Z>>>1&8190,this.r[6]=(Z>>>14|V<<2)&8191,this.r[7]=(V>>>11|Y<<5)&8065,this.r[8]=(Y>>>8|q<<8)&8191,this.r[9]=q>>>5&127;for(let G=0;G<8;G++)this.pad[G]=f(U,16+2*G)}process(U,$,Q=!1){let J=Q?0:2048,{h:W,r:Z}=this,V=Z[0],Y=Z[1],q=Z[2],G=Z[3],N=Z[4],X=Z[5],z=Z[6],w=Z[7],O=Z[8],P=Z[9],I=f(U,$+0),F=f(U,$+2),M=f(U,$+4),R=f(U,$+6),b=f(U,$+8),JU=f(U,$+10),y=f(U,$+12),l=f(U,$+14),S=W[0]+(I&8191),A=W[1]+((I>>>13|F<<3)&8191),H=W[2]+((F>>>10|M<<6)&8191),B=W[3]+((M>>>7|R<<9)&8191),D=W[4]+((R>>>4|b<<12)&8191),m=W[5]+(b>>>1&8191),j=W[6]+((b>>>14|JU<<2)&8191),v=W[7]+((JU>>>11|y<<5)&8191),L=W[8]+((y>>>8|l<<8)&8191),_=W[9]+(l>>>5|J),T=0,E=T+S*V+A*(5*P)+H*(5*O)+B*(5*w)+D*(5*z);T=E>>>13,E&=8191,E+=m*(5*X)+j*(5*N)+v*(5*G)+L*(5*q)+_*(5*Y),T+=E>>>13,E&=8191;let k=T+S*Y+A*V+H*(5*P)+B*(5*O)+D*(5*w);T=k>>>13,k&=8191,k+=m*(5*z)+j*(5*X)+v*(5*N)+L*(5*G)+_*(5*q),T+=k>>>13,k&=8191;let g=T+S*q+A*Y+H*V+B*(5*P)+D*(5*O);T=g>>>13,g&=8191,g+=m*(5*w)+j*(5*z)+v*(5*X)+L*(5*N)+_*(5*G),T+=g>>>13,g&=8191;let C=T+S*G+A*q+H*Y+B*V+D*(5*P);T=C>>>13,C&=8191,C+=m*(5*O)+j*(5*w)+v*(5*z)+L*(5*X)+_*(5*N),T+=C>>>13,C&=8191;let o=T+S*N+A*G+H*q+B*Y+D*V;T=o>>>13,o&=8191,o+=m*(5*P)+j*(5*O)+v*(5*w)+L*(5*z)+_*(5*X),T+=o>>>13,o&=8191;let ZU=T+S*X+A*N+H*G+B*q+D*Y;T=ZU>>>13,ZU&=8191,ZU+=m*V+j*(5*P)+v*(5*O)+L*(5*w)+_*(5*z),T+=ZU>>>13,ZU&=8191;let qU=T+S*z+A*X+H*N+B*G+D*q;T=qU>>>13,qU&=8191,qU+=m*Y+j*V+v*(5*P)+L*(5*O)+_*(5*w),T+=qU>>>13,qU&=8191;let YU=T+S*w+A*z+H*X+B*N+D*G;T=YU>>>13,YU&=8191,YU+=m*q+j*Y+v*V+L*(5*P)+_*(5*O),T+=YU>>>13,YU&=8191;let KU=T+S*O+A*w+H*z+B*X+D*N;T=KU>>>13,KU&=8191,KU+=m*G+j*q+v*Y+L*V+_*(5*P),T+=KU>>>13,KU&=8191;let GU=T+S*P+A*O+H*w+B*z+D*X;T=GU>>>13,GU&=8191,GU+=m*N+j*G+v*q+L*Y+_*V,T+=GU>>>13,GU&=8191,T=(T<<2)+T|0,T=T+E|0,E=T&8191,T=T>>>13,k+=T,W[0]=E,W[1]=k,W[2]=g,W[3]=C,W[4]=o,W[5]=ZU,W[6]=qU,W[7]=YU,W[8]=KU,W[9]=GU}finalize(){let{h:U,pad:$}=this,Q=new Uint16Array(10),J=U[1]>>>13;U[1]&=8191;for(let V=2;V<10;V++)U[V]+=J,J=U[V]>>>13,U[V]&=8191;U[0]+=J*5,J=U[0]>>>13,U[0]&=8191,U[1]+=J,J=U[1]>>>13,U[1]&=8191,U[2]+=J,Q[0]=U[0]+5,J=Q[0]>>>13,Q[0]&=8191;for(let V=1;V<10;V++)Q[V]=U[V]+J,J=Q[V]>>>13,Q[V]&=8191;Q[9]-=8192;let W=(J^1)-1;for(let V=0;V<10;V++)Q[V]&=W;W=~W;for(let V=0;V<10;V++)U[V]=U[V]&W|Q[V];U[0]=(U[0]|U[1]<<13)&65535,U[1]=(U[1]>>>3|U[2]<<10)&65535,U[2]=(U[2]>>>6|U[3]<<7)&65535,U[3]=(U[3]>>>9|U[4]<<4)&65535,U[4]=(U[4]>>>12|U[5]<<1|U[6]<<14)&65535,U[5]=(U[6]>>>2|U[7]<<11)&65535,U[6]=(U[7]>>>5|U[8]<<8)&65535,U[7]=(U[8]>>>8|U[9]<<5)&65535;let Z=U[0]+$[0];U[0]=Z&65535;for(let V=1;V<8;V++)Z=(U[V]+$[V]|0)+(Z>>>16)|0,U[V]=Z&65535;e(Q)}update(U){gU(this),U=DU(U),c(U);let{buffer:$,blockLen:Q}=this,J=U.length;for(let W=0;W<J;){let Z=Math.min(Q-this.pos,J-W);if(Z===Q){for(;Q<=J-W;W+=Q)this.process(U,W);continue}if($.set(U.subarray(W,W+Z),this.pos),this.pos+=Z,W+=Z,this.pos===Q)this.process($,0,!1),this.pos=0}return this}destroy(){e(this.h,this.r,this.buffer,this.pad)}digestInto(U){gU(this),nU(U,this),this.finished=!0;let{buffer:$,h:Q}=this,{pos:J}=this;if(J){$[J++]=1;for(;J<16;J++)$[J]=0;this.process($,0,!0)}this.finalize();let W=0;for(let Z=0;Z<8;Z++)U[W++]=Q[Z]>>>0,U[W++]=Q[Z]>>>8;return U}digest(){let{buffer:U,outputLen:$}=this;this.digestInto(U);let Q=U.slice(0,$);return this.destroy(),Q}}function C0(U){let $=(J,W)=>U(W).update(DU(J)).digest(),Q=U(new Uint8Array(32));return $.outputLen=Q.outputLen,$.blockLen=Q.blockLen,$.create=(J)=>U(J),$}var $0=C0((U)=>new U0(U));function W0(U,$,Q,J,W,Z=20){let V=U[0],Y=U[1],q=U[2],G=U[3],N=$[0],X=$[1],z=$[2],w=$[3],O=$[4],P=$[5],I=$[6],F=$[7],M=W,R=Q[0],b=Q[1],JU=Q[2],y=V,l=Y,S=q,A=G,H=N,B=X,D=z,m=w,j=O,v=P,L=I,_=F,T=M,E=R,k=b,g=JU;for(let o=0;o<Z;o+=2)y=y+H|0,T=K(T^y,16),j=j+T|0,H=K(H^j,12),y=y+H|0,T=K(T^y,8),j=j+T|0,H=K(H^j,7),l=l+B|0,E=K(E^l,16),v=v+E|0,B=K(B^v,12),l=l+B|0,E=K(E^l,8),v=v+E|0,B=K(B^v,7),S=S+D|0,k=K(k^S,16),L=L+k|0,D=K(D^L,12),S=S+D|0,k=K(k^S,8),L=L+k|0,D=K(D^L,7),A=A+m|0,g=K(g^A,16),_=_+g|0,m=K(m^_,12),A=A+m|0,g=K(g^A,8),_=_+g|0,m=K(m^_,7),y=y+B|0,g=K(g^y,16),L=L+g|0,B=K(B^L,12),y=y+B|0,g=K(g^y,8),L=L+g|0,B=K(B^L,7),l=l+D|0,T=K(T^l,16),_=_+T|0,D=K(D^_,12),l=l+D|0,T=K(T^l,8),_=_+T|0,D=K(D^_,7),S=S+m|0,E=K(E^S,16),j=j+E|0,m=K(m^j,12),S=S+m|0,E=K(E^S,8),j=j+E|0,m=K(m^j,7),A=A+H|0,k=K(k^A,16),v=v+k|0,H=K(H^v,12),A=A+H|0,k=K(k^A,8),v=v+k|0,H=K(H^v,7);let C=0;J[C++]=V+y|0,J[C++]=Y+l|0,J[C++]=q+S|0,J[C++]=G+A|0,J[C++]=N+H|0,J[C++]=X+B|0,J[C++]=z+D|0,J[C++]=w+m|0,J[C++]=O+j|0,J[C++]=P+v|0,J[C++]=I+L|0,J[C++]=F+_|0,J[C++]=M+T|0,J[C++]=R+E|0,J[C++]=b+k|0,J[C++]=JU+g|0}function E0(U,$,Q,J){let W=U[0],Z=U[1],V=U[2],Y=U[3],q=$[0],G=$[1],N=$[2],X=$[3],z=$[4],w=$[5],O=$[6],P=$[7],I=Q[0],F=Q[1],M=Q[2],R=Q[3];for(let JU=0;JU<20;JU+=2)W=W+q|0,I=K(I^W,16),z=z+I|0,q=K(q^z,12),W=W+q|0,I=K(I^W,8),z=z+I|0,q=K(q^z,7),Z=Z+G|0,F=K(F^Z,16),w=w+F|0,G=K(G^w,12),Z=Z+G|0,F=K(F^Z,8),w=w+F|0,G=K(G^w,7),V=V+N|0,M=K(M^V,16),O=O+M|0,N=K(N^O,12),V=V+N|0,M=K(M^V,8),O=O+M|0,N=K(N^O,7),Y=Y+X|0,R=K(R^Y,16),P=P+R|0,X=K(X^P,12),Y=Y+X|0,R=K(R^Y,8),P=P+R|0,X=K(X^P,7),W=W+G|0,R=K(R^W,16),O=O+R|0,G=K(G^O,12),W=W+G|0,R=K(R^W,8),O=O+R|0,G=K(G^O,7),Z=Z+N|0,I=K(I^Z,16),P=P+I|0,N=K(N^P,12),Z=Z+N|0,I=K(I^Z,8),P=P+I|0,N=K(N^P,7),V=V+X|0,F=K(F^V,16),z=z+F|0,X=K(X^z,12),V=V+X|0,F=K(F^V,8),z=z+F|0,X=K(X^z,7),Y=Y+q|0,M=K(M^Y,16),w=w+M|0,q=K(q^w,12),Y=Y+q|0,M=K(M^Y,8),w=w+M|0,q=K(q^w,7);let b=0;J[b++]=W,J[b++]=Z,J[b++]=V,J[b++]=Y,J[b++]=I,J[b++]=F,J[b++]=M,J[b++]=R}var k0=lU(W0,{counterRight:!1,counterLength:4,allowShortKeys:!1}),g0=lU(W0,{counterRight:!1,counterLength:8,extendNonceFn:E0,allowShortKeys:!1});var b0=new Uint8Array(16),J0=(U,$)=>{U.update($);let Q=$.length%16;if(Q)U.update(b0.subarray(Q))},f0=new Uint8Array(32);function Q0(U,$,Q,J,W){let Z=U($,Q,f0),V=$0.create(Z);if(W)J0(V,W);J0(V,J);let Y=rU(J.length,W?W.length:0,!0);V.update(Y);let q=V.digest();return e(Z,Y),q}var V0=(U)=>($,Q,J)=>{return{encrypt(Z,V){let Y=Z.length;V=fU(Y+16,V,!1),V.set(Z);let q=V.subarray(0,-16);U($,Q,q,q,1);let G=Q0(U,$,Q,q,J);return V.set(G,Y),e(G),V},decrypt(Z,V){V=fU(Z.length-16,V,!1);let Y=Z.subarray(0,-16),q=Z.subarray(-16),G=Q0(U,$,Q,Y,J);if(!oU(q,G))throw new Error("invalid tag");return V.set(Z.subarray(0,-16)),U($,Q,V,V,1),e(G),V}}},V$=bU({blockSize:64,nonceLength:12,tagLength:16},V0(k0)),FU=bU({blockSize:64,nonceLength:24,tagLength:16},V0(g0));class UU{p;static IV_LENGTH=24;static TAG_LENGTH=16;IV_LENGTH=UU.IV_LENGTH;TAG_LENGTH=UU.TAG_LENGTH;key;aad=new Uint8Array(0);constructor(U){this.p=U}async setKey(U){this.key=new Uint8Array(await this.p.subtle.exportKey("raw",U))}async encryptChunk(U){if(!this.key)throw new Error("Key not set");let $=this.p.getRandomValues(new Uint8Array(UU.IV_LENGTH)),J=(this.aad.length?FU(this.key,$,this.aad):FU(this.key,$)).encrypt(U);U.fill(0);let W=new Uint8Array($.length+J.length);return W.set($,0),W.set(J,$.length),W}async decryptChunk(U){if(!this.key)throw new Error("Key not set");if(U.byteLength<UU.IV_LENGTH+16)throw new d("Invalid ciphertext: too short.");let $=U.slice(0,UU.IV_LENGTH),Q=U.slice(UU.IV_LENGTH),J=this.aad.length?FU(this.key,$,this.aad):FU(this.key,$);try{return J.decrypt(Q)}catch{throw new d("Decryption failed: wrong passphrase or corrupted ciphertext")}}zeroKey(){if(this.key)this.key.fill(0)}setAAD(U){this.aad=U&&U.byteLength?new Uint8Array(U):new Uint8Array(0)}}var vU=SU(require("argon2-browser"));async function y0(){if(typeof window!=="undefined")return;if(globalThis.loadArgon2WasmModule)return;try{let{createRequire:U}=await import("node:module"),{readFile:$}=await import("node:fs/promises"),Q=U(import.meta.url),J=Q.resolve("argon2-browser/dist/argon2.js"),W=Q.resolve("argon2-browser/dist/argon2.wasm");globalThis.loadArgon2WasmModule=async()=>{let Z=new Uint8Array(await $(W));return globalThis.Module={wasmBinary:Z,locateFile:(V)=>V==="argon2.wasm"?W:V},Q(J)}}catch{}}async function Z0(U,$,Q,J){if(J==="node"){let Z=await import("@node-rs/argon2"),V=typeof U==="string"?Buffer.from(U,"utf8"):Buffer.from(U),q=(await Z.hash(V,{salt:$,timeCost:Q.time,memoryCost:Q.mem,parallelism:Q.parallelism,outputLen:32,algorithm:Z.Algorithm.Argon2id})).split("$").pop();if(!q)throw new Error("Unexpected argon2 hash format");let G=Buffer.from(q,"base64");return $.fill(0),V.fill(0),{hash:new Uint8Array(G)}}if(J==="browser")return await y0(),vU.hash({pass:U,salt:$,time:Q.time,mem:Q.mem,parallelism:Q.parallelism,hashLen:32,type:vU.ArgonType.Argon2id}).then((W)=>{if(!W||!W.hash)throw new a("Failed to produce key derivation");return{hash:W.hash}}).catch((W)=>{let Z=W instanceof Error?W.message:typeof W==="string"?W:"Unknown error";throw new a(`argon2-browser failure: ${Z}`)});throw new Error(`Unsupported environment: ${J}`)}class LU{presets;exportExtractable;name="argon2id";constructor(U,$=!1){this.presets=U;this.exportExtractable=$}async derive(U,$,Q,J){let{hash:W}=await Z0(U,$,this.presets[Q],J.isNode?"node":"browser");if(this.exportExtractable)return J.subtle.importKey("raw",W,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]);else return J.subtle.importKey("raw",W,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}}var q0={low:{time:5,mem:65536,parallelism:1},middle:{time:20,mem:65536,parallelism:1},high:{time:40,mem:65536,parallelism:1}},l0={id:0,cipher:WU,kdf:new LU(q0),saltLengths:{low:12,high:16},difficulties:q0,defaultChunkSize:524288};p.register(l0);var Y0={low:{time:5,mem:65536,parallelism:2},middle:{time:10,mem:98304,parallelism:4},high:{time:20,mem:98304,parallelism:4}},p0={id:1,cipher:UU,kdf:new LU(Y0,!0),saltLengths:{low:12,high:16},difficulties:Y0,defaultChunkSize:524288};p.register(p0);var _U=1;function K0(){return typeof process!=="undefined"&&typeof process.versions==="object"&&!0}function XU(...U){let $=U.reduce((W,Z)=>W+Z.byteLength,0),Q=new Uint8Array($),J=0;for(let W of U)Q.set(W,J),J+=W.byteLength;return Q}function TU(...U){try{let $=XU(...U);if(K0())return Buffer.from($).toString("base64");let Q="";for(let J=0;J<$.length;J++)Q+=String.fromCharCode($[J]);return btoa(Q)}catch{throw new kU("Base64 Encoding Error")}}function IU(U){try{if(!/^[A-Za-z0-9+/]+={0,2}$/.test(U)||U.length%4!==0)throw new Error("Invalid Base64");if(K0())return new Uint8Array(Buffer.from(U,"base64"));let $=atob(U),Q=new Uint8Array($.length);for(let J=0;J<$.length;J++)Q[J]=$.charCodeAt(J);return Q}catch{throw new NU(`Invalid Base64: length=${U.length}, content='${U.slice(0,12)}…'`)}}function u(U){let $=U.value.length,Q=new Array($).fill("\x00").join("");U.value=Q}function RU(U,$,Q,J,W){let Z={low:0,middle:1,high:2};if(!($ in Z))throw new TypeError(`Unsupported difficulty: ${$}`);let V=Z[$],Y=U<<5|(Q==="high"?1:0)<<2|V,q=XU(new Uint8Array([_U,Y]),J);if(W)W.setAAD(q);return q}function i(U,$){if(U[0]!==_U)throw new h("Invalid input format. The input is unknown.");if(U.length<14)throw new h("Invalid input format. Header too short.");try{let Q=U[1],J=Q>>5,W=Q>>2&1?"high":"low",Z=Q&3,V=["low","middle","high"][Z],Y=p.get(J).saltLengths[W],q=2+Y;if(U.length<q)throw new h("Invalid input format. Header truncated.");if($)$.setAAD(U.subarray(0,q));let G=U.slice(2,2+Y);return{scheme:J,difficulty:V,saltStrength:W,salt:G,headerLen:q}}catch(Q){throw new QU(Q instanceof Error?Q.message:String(Q))}}async function CU(U){if(U instanceof Uint8Array)return U;if(U instanceof ArrayBuffer)return new Uint8Array(U);return new Uint8Array(await U.arrayBuffer())}function pU(U){let $=new Uint8Array(4);return new DataView($.buffer).setUint32(0,U,!1),$}function G0(U,$=0){if(U.length-$<4)throw new RangeError("Not enough bytes for frame header");return new DataView(U.buffer,U.byteOffset+$,4).getUint32(0,!1)}var $U=4;class MU{engine;chunkSize;buffer=new Uint8Array(0);constructor(U,$=524288){this.engine=U;this.chunkSize=$}toTransformStream(){return new TransformStream({transform:async(U,$)=>{await this.transform(await CU(U),$)},flush:async(U)=>this.flush(U)})}async transform(U,$){if(U.length>Math.min(this.chunkSize*4,67108864))throw new RangeError(`Input block (${U.length} B) exceeds maximum allowed ${Math.min(this.chunkSize*4,67108864)} B`);let J=new Uint8Array(this.buffer.length+U.length);J.set(this.buffer),J.set(U,this.buffer.length);let W=0;while(J.length-W>=this.chunkSize){let Z=J.slice(W,W+this.chunkSize);W+=this.chunkSize;let V=await this.engine.encryptChunk(Z),Y=new Uint8Array($U+V.length);Y.set(pU(V.length)),Y.set(V,$U),$.enqueue(Y)}this.buffer=J.slice(W)}async flush(U){if(!this.buffer.length)return;let $=await this.engine.encryptChunk(this.buffer),Q=new Uint8Array($U+$.length);Q.set(pU($.length)),Q.set($,$U),U.enqueue(Q),this.buffer=new Uint8Array(0),this.engine.zeroKey()}}class OU{engine;chunkSize;buffer=new Uint8Array(0);constructor(U,$=524288){this.engine=U;this.chunkSize=$}toTransformStream(){return new TransformStream({transform:async(U,$)=>{await this.transform(await CU(U),$)},flush:async(U)=>this.flush(U)})}async transform(U,$){let Q=new Uint8Array(this.buffer.length+U.length);Q.set(this.buffer),Q.set(U,this.buffer.length);let J=0;while(!0){if(Q.length-J<$U)break;let W=G0(Q,J);if(W>this.chunkSize*2)throw new d(`Frame length ${W} exceeds …`);if(Q.length-J-$U<W)break;J+=$U;let Z=Q.slice(J,J+W);J+=W;try{let V=await this.engine.decryptChunk(Z);$.enqueue(V)}catch(V){throw V instanceof d?V:new d("Decryption failed: Wrong passphrase or corrupted ciphertext")}}this.buffer=Q.slice(J)}async flush(U){await this.transform(new Uint8Array(0),U),this.buffer=new Uint8Array(0),this.engine.zeroKey()}}async function N0(U,$){let Q=U.getReader(),J=$&&$.length?[$]:[];try{while(!0){let{value:Y,done:q}=await Q.read();if(q)break;J.push(Y)}}finally{Q.releaseLock()}let W=J.reduce((Y,q)=>Y+q.byteLength,0),Z=new Uint8Array(W),V=0;for(let Y of J)Z.set(Y,V),V+=Y.byteLength;return Z}class PU{engine;chunkSize;constructor(U,$=524288){this.engine=U;this.chunkSize=$}encryptionStream(){let U=new MU(this.engine,this.chunkSize).toTransformStream();return{writable:U.writable,readable:U.readable}}decryptionStream(U){let $=U,Q=new TransformStream({transform(W,Z){if($===0){Z.enqueue(W);return}if(W.byteLength<=$){$-=W.byteLength;return}Z.enqueue(W.slice($)),$=0}}),J=new OU(this.engine,this.chunkSize).toTransformStream();return{writable:Q.writable,readable:Q.readable.pipeThrough(J)}}async collect(U,$,Q=null){return N0(U.pipeThrough($),Q??void 0)}getEngine(){return this.engine}}function X0(U){try{if(U)U.fill(0)}catch{}}function c0(U){let $="";for(let Q=0;Q<U.length;Q++){let J=U[Q].toString(16).padStart(2,"0");$+=J}return $}class n{bytes;destroyed=!1;static from(U){if(U instanceof n)return U;if(typeof U==="string")return new n(new TextEncoder().encode(U));if(U instanceof Uint8Array)return new n(U);throw new TypeError("ConvertibleInput: unsupported input type")}constructor(U){this.bytes=U}toUint8Array(){if(this.destroyed)throw new Error("ConvertibleInput: already cleared");return this.bytes}clear(){if(!this.destroyed)X0(this.bytes),this.bytes=new Uint8Array(0),this.destroyed=!0}}class zU{bytes;destroyed=!1;constructor(U){this.bytes=U}get uint8array(){if(this.destroyed)throw new Error("ConvertibleOutput: already cleared");return this.bytes}get base64(){if(this.destroyed)throw new Error("ConvertibleOutput: already cleared");return TU(this.bytes)}get hex(){if(this.destroyed)throw new Error("ConvertibleOutput: already cleared");return c0(this.bytes)}get text(){if(this.destroyed)throw new Error("ConvertibleOutput: already cleared");return new TextDecoder().decode(this.bytes)}clear(){if(!this.destroyed)X0(this.bytes),this.bytes=new Uint8Array(0),this.destroyed=!0}toString(){return this.base64}}function T0(U=0,$=console.info){return{level:U,log(Q,J){if(Q<=U)$(`${Q}| ${J}`)}}}function O0(U,$,Q){if($<0||Q<0||$+Q>U)throw new RangeError("read() slice exceeds data bounds")}class cU{src;#U=null;constructor(U){this.src=U}get length(){if(this.src instanceof Uint8Array)return this.src.byteLength;if(this.src instanceof Blob)return this.src.size;return this.ensureUint8().byteLength}async read(U,$){if(O0(this.length,U,$),this.src instanceof Uint8Array)return this.src.slice(U,U+$);if(this.src instanceof Blob){let Q=await this.src.slice(U,U+$).arrayBuffer();return new Uint8Array(Q)}return this.ensureUint8().slice(U,U+$)}ensureUint8(){if(!this.#U)this.#U=IU(this.src);return this.#U}}var P0=new WeakMap;class VU{static getEngine(U,$){let Q=P0.get(U);if(!Q)Q=new Map,P0.set(U,Q);let J=Q.get($);if(J)return J;let W=p.get($);return J={desc:W,cipher:new W.cipher(U),kdf:W.kdf,chunkSize:W.defaultChunkSize,provider:U},Q.set($,J),J}static async deriveKey(U,$,Q,J){try{let W=await U.kdf.derive($.value,Q,J,U.provider);await U.cipher.setKey(W)}catch(W){let Z=W instanceof Error?W.message:String(W);throw new a(Z)}finally{u($)}}}class s{provider;v;cipher;kdf;chunkSize;stream;difficulty;saltStrength;engines=new Map;log;constructor(U,$={}){this.provider=U;this.v=p.get($.scheme??p.current.id),this.cipher=new this.v.cipher(U),this.kdf=this.v.kdf,this.chunkSize=this.setChunkSize($.chunkSize??this.v.defaultChunkSize),this.stream=new PU(this.cipher,this.chunkSize),this.difficulty=$.difficulty??"middle",this.saltStrength=$.saltStrength??"high",this.log=T0($.verbose??0,$.logger)}static async isEncrypted(U){try{return await s.peekHeader(U),!0}catch{return!1}}static async decodeHeader(U){let $=await s.peekHeader(U),Q=i($);return{scheme:Q.scheme,difficulty:Q.difficulty,salt:TU(Q.salt),saltBytes:Q.salt,saltLength:Q.salt.byteLength}}static async headerDecode(U){return this.decodeHeader(U)}static isRandomAccessSource(U){return typeof U==="object"&&U!==null&&typeof U.read==="function"}static async decodeData(U){let $=s.isRandomAccessSource(U)?U:new cU(U),Q=await $.read(0,Math.min(256,$.length)),J=await s.peekHeader(Q),{scheme:W,headerLen:Z}=i(J),V=$.length,Y=V-Z;if(Y<=0)throw new h("Payload is empty");let q=await $.read(Z,4),G=new DataView(q.buffer,q.byteOffset,4).getUint32(0,!1);if(G+4<=Y&&G>=28){let O=G,P=Z,I=0,F=0;while(P+4<=V){let M=await $.read(P,4),R=new DataView(M.buffer,M.byteOffset,4).getUint32(0,!1);if(R===0||P+4+R>V)break;I++,F+=R,P+=4+R}return{isChunked:!0,chunks:{chunkSize:O,count:I,totalPayload:F}}}let X=await $.read(Z,Y),z=p.get(W).cipher.IV_LENGTH,w=p.get(W).cipher.TAG_LENGTH;if(X.length<z+w)throw new h("Ciphertext too short for IV & tag");return{isChunked:!1,payloadLength:Y-z-w,params:{iv:X.slice(0,z),ivLength:z,tag:X.slice(X.length-w),tagLength:w}}}setDifficulty(U){this.difficulty=U}getDifficulty(){return this.difficulty}setScheme(U){this.v=p.get(U),this.cipher=new this.v.cipher(this.provider),this.kdf=this.v.kdf,this.stream=new PU(this.cipher,this.chunkSize)}getScheme(){return this.v.id}setSaltDifficulty(U){this.saltStrength=U}getSaltDifficulty(){return this.saltStrength}setChunkSize(U){let Q=U,J;if(Q==null)J=this.v.defaultChunkSize;else{if(J=Number(Q),!Number.isInteger(J)||J<1)throw new Error(`Invalid chunkSize: ${Q}. Must be a positive integer.`);if(J>134217728)throw new RangeError("chunkSize cannot exceed 134217728 bytes.")}if(this.chunkSize=J,this.stream)this.stream=new PU(this.cipher,this.chunkSize);return J}getChunkSize(){return this.chunkSize}setVerbose(U){this.log.level=U}getVerbose(){return this.log.level}async encryptText(U,$){if($===null)throw new x("Password can't be null");let Q={value:$};try{if($==="")this.log.log(0,"Empty passphrase provided to encryptText");this.log.log(1,`Start text encryption, scheme: ${this.getScheme()}`);let J=n.from(U),W=J.toUint8Array();this.log.log(2,"Deriving key for text encryption");let Z=this.genSalt();await this.deriveKey(Q,Z),u(Q),$=null,this.log.log(3,`Salt generated: ${TU(Z)}, KDF difficulty: ${this.difficulty}`),this.log.log(3,"Encoding header");let V=RU(this.v.id,this.difficulty,this.saltStrength,Z,this.cipher);this.log.log(2,"Encrypting text data");let Y=await this.cipher.encryptChunk(W);this.cipher.zeroKey();try{J.clear()}catch{}let q=XU(V,Y);return this.log.log(1,"Encryption finished"),new zU(q)}catch(J){throw new x(J instanceof Error?J.message:String(J))}}async decryptText(U,$){if($===null)throw new x("Password can't be null");let Q={value:$};try{if($==="")this.log.log(0,"Empty passphrase provided to decryptText");this.log.log(1,`Start text decryption, Version ${this.getScheme()}`);let J;if(typeof U==="string")this.log.log(3,"Decoding Base64 ciphertext"),J=IU(U);else if(U instanceof Uint8Array)J=U;else if(U instanceof n)J=U.toUint8Array();else throw new NU("Unsupported ciphertext input type");this.log.log(3,"Start header decoding");let W=i(J);this.log.log(3,"Selecting decryption engine");let Z=VU.getEngine(this.provider,W.scheme);this.log.log(2,`Deriving key via engine for scheme: ${W.scheme}`),this.log.log(3,`Salt use: ${TU(W.salt)}, KDF difficulty: ${W.difficulty}`);try{await VU.deriveKey(Z,Q,W.salt,W.difficulty)}finally{u(Q),$=null}this.log.log(2,"Decrypting text data"),i(J,Z.cipher);let V=await Z.cipher.decryptChunk(J.slice(W.headerLen));if(Z.cipher.zeroKey(),U instanceof n)try{U.clear()}catch{}return this.log.log(1,"Decryption finished"),new zU(V)}catch(J){if(J instanceof d||J instanceof h||J instanceof QU||J instanceof NU||J instanceof a)throw J;throw new d("Decryption failed: wrong passphrase or corrupted ciphertext")}}async encryptFile(U,$){if($===null)throw new x("Password can't be null");let Q={value:$};try{if(U.size===0){let V=this.genSalt();await this.deriveKey(Q,V),u(Q),$=null;let Y=RU(this.v.id,this.difficulty,this.saltStrength,V);return new Blob([Y],{type:"application/octet-stream"})}this.log.log(2,"Deriving key for file encryption");let J=this.genSalt();await this.deriveKey(Q,J),u(Q),$=null;let W=RU(this.v.id,this.difficulty,this.saltStrength,J,this.stream.getEngine()),Z=await this.stream.collect(U.stream(),new MU(this.cipher,this.chunkSize).toTransformStream(),W);return new Blob([Z],{type:"application/octet-stream"})}catch(J){throw new x(J instanceof Error?J.message:String(J))}}async decryptFile(U,$){if($===null)throw new x("Password can't be null");let Q={value:$};try{let J=await s.peekHeader(U),W=i(J),Z=VU.getEngine(this.provider,W.scheme);try{await VU.deriveKey(Z,Q,W.salt,W.difficulty)}finally{u(Q),$=null}if(U.size===W.headerLen)return new Blob([],{type:"application/octet-stream"});this.log.log(2,"Decrypting file data");let V=new PU(Z.cipher,Z.chunkSize);i(J,V.getEngine());let Y=await V.collect(U.slice(W.headerLen).stream(),new OU(Z.cipher,Z.chunkSize).toTransformStream());return new Blob([Y],{type:"application/octet-stream"})}catch(J){if(J instanceof d)throw J;throw new d(J instanceof Error?J.message:String(J))}}async createEncryptionStream(U){if(U===null)throw new x("Password can't be null");let $={value:U};this.log.log(2,"Deriving key for stream encryption");let Q=this.genSalt();await this.deriveKey($,Q),u($),U=null;let J=RU(this.v.id,this.difficulty,this.saltStrength,Q,this.stream.getEngine()),W=this.stream.encryptionStream();return{header:J,writable:W.writable,readable:W.readable}}async createDecryptionStream(U){if(U===null)throw new x("Password can't be null");let $=this.provider,Q={value:U},J=new Uint8Array(0),W=null,Z=65536,V=14,Y=async(q,G)=>{let N=q.getReader();while(!0){let{value:X,done:z}=await N.read();if(z)break;G.enqueue(X)}};return new TransformStream({transform:async(q,G)=>{if(!W){if(q&&q.byteLength){if(J.byteLength+q.byteLength>Z){u(Q),G.error(new h(`Header not found within ${Z} bytes`));return}J=XU(J,q)}if(J.byteLength<V)return;let X=J[1],z=X>>5,w=X>>2&1?"high":"low",O=0;try{O=2+p.get(z).saltLengths[w]}catch(R){u(Q),G.error(new QU(R instanceof Error?R.message:String(R)));return}if(J.byteLength<O)return;let P=J.subarray(0,O),I;try{I=i(P)}catch(R){u(Q),G.error(R instanceof Error?R:new QU("Invalid header"));return}let F=VU.getEngine($,I.scheme);try{await VU.deriveKey(F,Q,I.salt,I.difficulty)}finally{u(Q),U=null}i(P,F.cipher),W=new OU(F.cipher,F.chunkSize).toTransformStream(),Y(W.readable,G).catch((R)=>G.error(R));let M=J.subarray(O);if(J=new Uint8Array(0),M.byteLength){let R=W.writable.getWriter();await R.write(M),R.releaseLock()}return}let N=W.writable.getWriter();await N.write(q),N.releaseLock()},flush:async()=>{if(!W)throw u(Q),new h("Header not found before end of stream");let q=W.writable.getWriter();await q.close(),q.releaseLock()}})}async deriveKey(U,$,Q=this.difficulty){let J=performance.now();try{let W=await this.kdf.derive(U.value,$,Q,this.provider);u(U),await this.cipher.setKey(W),this.log.log(3,`Key derivation completed in ${(performance.now()-J).toFixed(1)} ms`)}catch(W){throw new a(W instanceof Error?W.message:String(W))}}genSalt(U=this.saltStrength){let $=this.v.saltLengths[U];return this.provider.getRandomValues(new Uint8Array($))}static async peekHeader(U){let $=await this.readAsUint8(U);if($ instanceof Uint8Array){if($.length<2)throw new h("Input too short");let{headerLen:Q}=i($.length>=16?$:Uint8Array.from($));if($.length<Q)throw new h("Incomplete header");return $.slice(0,Q)}throw new QU("Unsupported input type")}static async readAsUint8(U){if(typeof U==="string")return IU(U);if(U instanceof Blob){let $=U.slice(0,64);return new Uint8Array(await $.arrayBuffer())}return U}}var EU=require("node:crypto"),z0={subtle:EU.webcrypto.subtle,getRandomValues(U){return EU.randomFillSync(U),U},isNode:!0};function d0(U){return new s(z0,U)}

//# debugId=F9D48F62FF843AE064756E2164756E21
