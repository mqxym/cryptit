var F0=Object.create;var{getPrototypeOf:H0,defineProperty:RU,getOwnPropertyNames:dU,getOwnPropertyDescriptor:I0}=Object,iU=Object.prototype.hasOwnProperty;var MU=(U,$,J)=>{J=U!=null?F0(H0(U)):{};let Z=$||!U||!U.__esModule?RU(J,"default",{value:U,enumerable:!0}):J;for(let q of dU(U))if(!iU.call(Z,q))RU(Z,q,{get:()=>U[q],enumerable:!0});return Z},cU=new WeakMap,S0=(U)=>{var $=cU.get(U),J;if($)return $;if($=RU({},"__esModule",{value:!0}),U&&typeof U==="object"||typeof U==="function")dU(U).map((Z)=>!iU.call($,Z)&&RU($,Z,{get:()=>U[Z],enumerable:!(J=I0(U,Z))||J.enumerable}));return cU.set(U,$),$};var R0=(U,$)=>{for(var J in $)RU(U,J,{get:$[J],enumerable:!0,configurable:!0,set:(Z)=>$[J]=()=>Z})};var x0={};R0(x0,{createCryptit:()=>h0,Cryptit:()=>t,ConvertibleOutput:()=>SU,ConvertibleInput:()=>a});module.exports=S0(x0);class UU extends Error{constructor(U){super(U);Object.setPrototypeOf(this,new.target.prototype),this.name=new.target.name,this.stack=void 0}}class i extends UU{}class TU extends UU{}class bU extends UU{}class DU extends UU{}class QU extends UU{}class $U extends UU{}class s extends UU{}class f extends UU{}class x{static byId=new Map;static register(U){if(this.byId.has(U.id))throw new DU(`Scheme ${U.id} already registered`);this.byId.set(U.id,U)}static get(U){let $=this.byId.get(U);if(!$)throw new DU(`Unknown scheme: ${U}`);return $}static get current(){return this.get(0)}}class JU{p;padding=null;headerAAD=new Uint8Array(0);padAADMode="auto";padAlign=8;allowLegacyAADFallback=!0;legacyFallbackPolicy="auto";tryEmptyAADOnLegacyFallback=!1;setLegacyAADFallback(U={}){if(U.enabled!==void 0)this.allowLegacyAADFallback=!!U.enabled;if(U.policy)this.legacyFallbackPolicy=U.policy;if(U.tryEmptyAAD!==void 0)this.tryEmptyAADOnLegacyFallback=!!U.tryEmptyAAD}static PAD_AAD_MAGIC=new Uint8Array([80,65,68,49]);static PAD_AAD_VER=1;constructor(U){this.p=U}setPaddingScheme(U){this.padding=U}setPaddingAADMode(U){this.padAADMode=U}setPaddingAlign(U){if(!Number.isInteger(U)||U<1||U>255)throw Error("padAlign must be 1..255");this.padAlign=U|0}setAAD(U){this.headerAAD=U&&U.byteLength?new Uint8Array(U):new Uint8Array(0)}async encryptChunk(U){let $=this.resolveMode(),J=U;if($==="require"){if(!this.padding)throw Error("Padding required but no scheme set");let Y=(Q)=>this.p.getRandomValues(new Uint8Array(Q));J=this.padding.pad(U,Y,this.padAlign)}let Z=this.composeAAD($),q=await this.encryptWithAAD(J,Z);if(U.fill(0),J!==U)J.fill(0);return q}async decryptChunk(U){let $=this.resolveMode(),J=this.composeAAD($);try{let Z=await this.decryptWithAAD(U,J);return this.enforcePolicyAfterDecrypt(Z,$)}catch(Z){if(!this.allowLegacyAADFallback)throw Z;let q=[];if(this.headerAAD.length)q.push(this.headerAAD);if(this.tryEmptyAADOnLegacyFallback)q.push(new Uint8Array(0));let Y=Z;for(let Q of q)try{let w=await this.decryptWithAAD(U,Q),K=this.legacyFallbackPolicy==="auto"?"auto":this.legacyFallbackPolicy;return this.enforcePolicyAfterDecrypt(w,K)}catch(w){Y=w}throw Y}}enforcePolicyAfterDecrypt(U,$){if(!this.padding){if($==="require")throw new f("Expected padding but no scheme configured");return U}let{used:J,plain:Z}=this.padding.tryUnpad(U);if($==="require"){if(!J)throw new f("Expected padding trailer not found");return new Uint8Array(Z)}if($==="forbid"){if(J)throw new f("Padding forbidden by policy");return U}return J?new Uint8Array(Z):U}resolveMode(){if(this.padAADMode==="auto")return this.padding?"require":"forbid";return this.padAADMode}buildPadAAD(U){let $=U==="require"?0:1,J=new Uint8Array(JU.PAD_AAD_MAGIC.length+1+1+1),Z=0;return J.set(JU.PAD_AAD_MAGIC,Z),Z+=JU.PAD_AAD_MAGIC.length,J[Z++]=JU.PAD_AAD_VER&255,J[Z++]=$,J[Z++]=this.padAlign&255,J}composeAAD(U){let $=this.buildPadAAD(U);if(!this.headerAAD.length)return $;let J=new Uint8Array(this.headerAAD.length+$.length);return J.set(this.headerAAD,0),J.set($,this.headerAAD.length),J}}class n extends JU{static IV_LENGTH=12;static TAG_LENGTH=16;IV_LENGTH=n.IV_LENGTH;TAG_LENGTH=n.TAG_LENGTH;key=null;constructor(U){super(U)}async setKey(U){this.key=U}zeroKey(){this.key=null}async encryptWithAAD(U,$){let J=this.p.getRandomValues(new Uint8Array(n.IV_LENGTH)),Z={name:"AES-GCM",iv:J,additionalData:$},q=await this.p.subtle.encrypt(Z,this.requireKey(),U),Y=new Uint8Array(q),Q=new Uint8Array(J.length+Y.length);return Q.set(J,0),Q.set(Y,J.length),Q}async decryptWithAAD(U,$){if(U.byteLength<n.IV_LENGTH+n.TAG_LENGTH)throw new f("Invalid ciphertext: too short.");let J=U.subarray(0,n.IV_LENGTH),Z=U.subarray(n.IV_LENGTH),q={name:"AES-GCM",iv:J,additionalData:$};try{let Y=await this.p.subtle.decrypt(q,this.requireKey(),Z);return new Uint8Array(Y)}catch{throw new f("Decryption failed: wrong passphrase or corrupted ciphertext")}}requireKey(){if(!this.key)throw Error("Encryption key not set");return this.key}}/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function j0(U){return U instanceof Uint8Array||ArrayBuffer.isView(U)&&U.constructor.name==="Uint8Array"}function PU(U){if(typeof U!=="boolean")throw Error(`boolean expected, not ${U}`)}function _U(U){if(!Number.isSafeInteger(U)||U<0)throw Error("positive integer expected, got "+U)}function u(U,$,J=""){let Z=j0(U),q=U?.length,Y=$!==void 0;if(!Z||Y&&q!==$){let Q=J&&`"${J}" `,w=Y?` of length ${$}`:"",K=Z?`length=${q}`:`type=${typeof U}`;throw Error(Q+"expected Uint8Array"+w+", got "+K)}return U}function fU(U,$=!0){if(U.destroyed)throw Error("Hash instance has been destroyed");if($&&U.finished)throw Error("Hash#digest() has already been called")}function sU(U,$){u(U,void 0,"output");let J=$.outputLen;if(U.length<J)throw Error("digestInto() expects output buffer of length at least "+J)}function ZU(U){return new Uint32Array(U.buffer,U.byteOffset,Math.floor(U.byteLength/4))}function qU(...U){for(let $=0;$<U.length;$++)U[$].fill(0)}function B0(U){return new DataView(U.buffer,U.byteOffset,U.byteLength)}var v0=(()=>new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68)();function nU(U,$){if($==null||typeof $!=="object")throw Error("options must be defined");return Object.assign(U,$)}function oU(U,$){if(U.length!==$.length)return!1;let J=0;for(let Z=0;Z<U.length;Z++)J|=U[Z]^$[Z];return J===0}var gU=(U,$)=>{function J(Z,...q){if(u(Z,void 0,"key"),!v0)throw Error("Non little-endian hardware is not yet supported");if(U.nonceLength!==void 0){let O=q[0];u(O,U.varSizeNonce?void 0:U.nonceLength,"nonce")}let Y=U.tagLength;if(Y&&q[1]!==void 0)u(q[1],void 0,"AAD");let Q=$(Z,...q),w=(O,N)=>{if(N!==void 0){if(O!==2)throw Error("cipher output not supported");u(N,void 0,"output")}},K=!1;return{encrypt(O,N){if(K)throw Error("cannot encrypt() twice with same key + nonce");return K=!0,u(O),w(Q.encrypt.length,N),Q.encrypt(O,N)},decrypt(O,N){if(u(O),Y&&O.length<Y)throw Error('"ciphertext" expected length bigger than tagLength='+Y);return w(Q.decrypt.length,N),Q.decrypt(O,N)}}}return Object.assign(J,U),J};function yU(U,$,J=!0){if($===void 0)return new Uint8Array(U);if($.length!==U)throw Error('"output" expected Uint8Array of length '+U+", got: "+$.length);if(J&&!M0($))throw Error("invalid output, must be aligned");return $}function rU(U,$,J){PU(J);let Z=new Uint8Array(16),q=B0(Z);return q.setBigUint64(0,BigInt($),J),q.setBigUint64(8,BigInt(U),J),Z}function M0(U){return U.byteOffset%4===0}function zU(U){return Uint8Array.from(U)}var tU=(U)=>Uint8Array.from(U.split(""),($)=>$.charCodeAt(0)),D0=tU("expand 16-byte k"),P0=tU("expand 32-byte k"),_0=ZU(D0),m0=ZU(P0);function W(U,$){return U<<$|U>>>32-$}function lU(U){return U.byteOffset%4===0}var mU=64,A0=16,eU=4294967295,aU=Uint32Array.of();function L0(U,$,J,Z,q,Y,Q,w){let K=q.length,G=new Uint8Array(mU),O=ZU(G),N=lU(q)&&lU(Y),X=N?ZU(q):aU,V=N?ZU(Y):aU;for(let F=0;F<K;Q++){if(U($,J,Z,O,Q,w),Q>=eU)throw Error("arx: counter overflow");let z=Math.min(mU,K-F);if(N&&z===mU){let I=F/4;if(F%4!==0)throw Error("arx: invalid block position");for(let H=0,S;H<A0;H++)S=I+H,V[S]=X[S]^O[H];F+=mU;continue}for(let I=0,H;I<z;I++)H=F+I,Y[H]=q[H]^G[I];F+=z}}function uU(U,$){let{allowShortKeys:J,extendNonceFn:Z,counterLength:q,counterRight:Y,rounds:Q}=nU({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},$);if(typeof U!=="function")throw Error("core must be a function");return _U(q),_U(Q),PU(Y),PU(J),(w,K,G,O,N=0)=>{u(w,void 0,"key"),u(K,void 0,"nonce"),u(G,void 0,"data");let X=G.length;if(O===void 0)O=new Uint8Array(X);if(u(O,void 0,"output"),_U(N),N<0||N>=eU)throw Error("arx: counter overflow");if(O.length<X)throw Error(`arx: output (${O.length}) is shorter than data (${X})`);let V=[],F=w.length,z,I;if(F===32)V.push(z=zU(w)),I=m0;else if(F===16&&J)z=new Uint8Array(32),z.set(w),z.set(w,16),I=_0,V.push(z);else throw u(w,32,"arx key"),Error("invalid key size");if(!lU(K))V.push(K=zU(K));let H=ZU(z);if(Z){if(K.length!==24)throw Error("arx: extended nonce must be 24 bytes");Z(I,H,ZU(K.subarray(0,16)),H),K=K.subarray(16)}let S=16-q;if(S!==K.length)throw Error(`arx: nonce must be ${S} or 16 bytes`);if(S!==12){let R=new Uint8Array(12);R.set(K,Y?0:12-K.length),K=R,V.push(K)}let j=ZU(K);return L0(U,I,H,j,G,O,N,Q),qU(...V),O}}function p(U,$){return U[$++]&255|(U[$++]&255)<<8}class U0{blockLen=16;outputLen=16;buffer=new Uint8Array(16);r=new Uint16Array(10);h=new Uint16Array(10);pad=new Uint16Array(8);pos=0;finished=!1;constructor(U){U=zU(u(U,32,"key"));let $=p(U,0),J=p(U,2),Z=p(U,4),q=p(U,6),Y=p(U,8),Q=p(U,10),w=p(U,12),K=p(U,14);this.r[0]=$&8191,this.r[1]=($>>>13|J<<3)&8191,this.r[2]=(J>>>10|Z<<6)&7939,this.r[3]=(Z>>>7|q<<9)&8191,this.r[4]=(q>>>4|Y<<12)&255,this.r[5]=Y>>>1&8190,this.r[6]=(Y>>>14|Q<<2)&8191,this.r[7]=(Q>>>11|w<<5)&8065,this.r[8]=(w>>>8|K<<8)&8191,this.r[9]=K>>>5&127;for(let G=0;G<8;G++)this.pad[G]=p(U,16+2*G)}process(U,$,J=!1){let Z=J?0:2048,{h:q,r:Y}=this,Q=Y[0],w=Y[1],K=Y[2],G=Y[3],O=Y[4],N=Y[5],X=Y[6],V=Y[7],F=Y[8],z=Y[9],I=p(U,$+0),H=p(U,$+2),S=p(U,$+4),j=p(U,$+6),R=p(U,$+8),d=p(U,$+10),g=p(U,$+12),h=p(U,$+14),B=q[0]+(I&8191),v=q[1]+((I>>>13|H<<3)&8191),M=q[2]+((H>>>10|S<<6)&8191),D=q[3]+((S>>>7|j<<9)&8191),P=q[4]+((j>>>4|R<<12)&8191),_=q[5]+(R>>>1&8191),m=q[6]+((R>>>14|d<<2)&8191),A=q[7]+((d>>>11|g<<5)&8191),L=q[8]+((g>>>8|h<<8)&8191),E=q[9]+(h>>>5|Z),T=0,k=T+B*Q+v*(5*z)+M*(5*F)+D*(5*V)+P*(5*X);T=k>>>13,k&=8191,k+=_*(5*N)+m*(5*O)+A*(5*G)+L*(5*K)+E*(5*w),T+=k>>>13,k&=8191;let b=T+B*w+v*Q+M*(5*z)+D*(5*F)+P*(5*V);T=b>>>13,b&=8191,b+=_*(5*X)+m*(5*N)+A*(5*O)+L*(5*G)+E*(5*K),T+=b>>>13,b&=8191;let y=T+B*K+v*w+M*Q+D*(5*z)+P*(5*F);T=y>>>13,y&=8191,y+=_*(5*V)+m*(5*X)+A*(5*N)+L*(5*O)+E*(5*G),T+=y>>>13,y&=8191;let C=T+B*G+v*K+M*w+D*Q+P*(5*z);T=C>>>13,C&=8191,C+=_*(5*F)+m*(5*V)+A*(5*X)+L*(5*N)+E*(5*O),T+=C>>>13,C&=8191;let e=T+B*O+v*G+M*K+D*w+P*Q;T=e>>>13,e&=8191,e+=_*(5*z)+m*(5*F)+A*(5*V)+L*(5*X)+E*(5*N),T+=e>>>13,e&=8191;let wU=T+B*N+v*O+M*G+D*K+P*w;T=wU>>>13,wU&=8191,wU+=_*Q+m*(5*z)+A*(5*F)+L*(5*V)+E*(5*X),T+=wU>>>13,wU&=8191;let WU=T+B*X+v*N+M*O+D*G+P*K;T=WU>>>13,WU&=8191,WU+=_*w+m*Q+A*(5*z)+L*(5*F)+E*(5*V),T+=WU>>>13,WU&=8191;let GU=T+B*V+v*X+M*N+D*O+P*G;T=GU>>>13,GU&=8191,GU+=_*K+m*w+A*Q+L*(5*z)+E*(5*F),T+=GU>>>13,GU&=8191;let OU=T+B*F+v*V+M*X+D*N+P*O;T=OU>>>13,OU&=8191,OU+=_*G+m*K+A*w+L*Q+E*(5*z),T+=OU>>>13,OU&=8191;let NU=T+B*z+v*F+M*V+D*X+P*N;T=NU>>>13,NU&=8191,NU+=_*O+m*G+A*K+L*w+E*Q,T+=NU>>>13,NU&=8191,T=(T<<2)+T|0,T=T+k|0,k=T&8191,T=T>>>13,b+=T,q[0]=k,q[1]=b,q[2]=y,q[3]=C,q[4]=e,q[5]=wU,q[6]=WU,q[7]=GU,q[8]=OU,q[9]=NU}finalize(){let{h:U,pad:$}=this,J=new Uint16Array(10),Z=U[1]>>>13;U[1]&=8191;for(let Q=2;Q<10;Q++)U[Q]+=Z,Z=U[Q]>>>13,U[Q]&=8191;U[0]+=Z*5,Z=U[0]>>>13,U[0]&=8191,U[1]+=Z,Z=U[1]>>>13,U[1]&=8191,U[2]+=Z,J[0]=U[0]+5,Z=J[0]>>>13,J[0]&=8191;for(let Q=1;Q<10;Q++)J[Q]=U[Q]+Z,Z=J[Q]>>>13,J[Q]&=8191;J[9]-=8192;let q=(Z^1)-1;for(let Q=0;Q<10;Q++)J[Q]&=q;q=~q;for(let Q=0;Q<10;Q++)U[Q]=U[Q]&q|J[Q];U[0]=(U[0]|U[1]<<13)&65535,U[1]=(U[1]>>>3|U[2]<<10)&65535,U[2]=(U[2]>>>6|U[3]<<7)&65535,U[3]=(U[3]>>>9|U[4]<<4)&65535,U[4]=(U[4]>>>12|U[5]<<1|U[6]<<14)&65535,U[5]=(U[6]>>>2|U[7]<<11)&65535,U[6]=(U[7]>>>5|U[8]<<8)&65535,U[7]=(U[8]>>>8|U[9]<<5)&65535;let Y=U[0]+$[0];U[0]=Y&65535;for(let Q=1;Q<8;Q++)Y=(U[Q]+$[Q]|0)+(Y>>>16)|0,U[Q]=Y&65535;qU(J)}update(U){fU(this),u(U),U=zU(U);let{buffer:$,blockLen:J}=this,Z=U.length;for(let q=0;q<Z;){let Y=Math.min(J-this.pos,Z-q);if(Y===J){for(;J<=Z-q;q+=J)this.process(U,q);continue}if($.set(U.subarray(q,q+Y),this.pos),this.pos+=Y,q+=Y,this.pos===J)this.process($,0,!1),this.pos=0}return this}destroy(){qU(this.h,this.r,this.buffer,this.pad)}digestInto(U){fU(this),sU(U,this),this.finished=!0;let{buffer:$,h:J}=this,{pos:Z}=this;if(Z){$[Z++]=1;for(;Z<16;Z++)$[Z]=0;this.process($,0,!0)}this.finalize();let q=0;for(let Y=0;Y<8;Y++)U[q++]=J[Y]>>>0,U[q++]=J[Y]>>>8;return U}digest(){let{buffer:U,outputLen:$}=this;this.digestInto(U);let J=U.slice(0,$);return this.destroy(),J}}function E0(U){let $=(Z,q)=>U(q).update(Z).digest(),J=U(new Uint8Array(32));return $.outputLen=J.outputLen,$.blockLen=J.blockLen,$.create=(Z)=>U(Z),$}var $0=(()=>E0((U)=>new U0(U)))();function q0(U,$,J,Z,q,Y=20){let Q=U[0],w=U[1],K=U[2],G=U[3],O=$[0],N=$[1],X=$[2],V=$[3],F=$[4],z=$[5],I=$[6],H=$[7],S=q,j=J[0],R=J[1],d=J[2],g=Q,h=w,B=K,v=G,M=O,D=N,P=X,_=V,m=F,A=z,L=I,E=H,T=S,k=j,b=R,y=d;for(let e=0;e<Y;e+=2)g=g+M|0,T=W(T^g,16),m=m+T|0,M=W(M^m,12),g=g+M|0,T=W(T^g,8),m=m+T|0,M=W(M^m,7),h=h+D|0,k=W(k^h,16),A=A+k|0,D=W(D^A,12),h=h+D|0,k=W(k^h,8),A=A+k|0,D=W(D^A,7),B=B+P|0,b=W(b^B,16),L=L+b|0,P=W(P^L,12),B=B+P|0,b=W(b^B,8),L=L+b|0,P=W(P^L,7),v=v+_|0,y=W(y^v,16),E=E+y|0,_=W(_^E,12),v=v+_|0,y=W(y^v,8),E=E+y|0,_=W(_^E,7),g=g+D|0,y=W(y^g,16),L=L+y|0,D=W(D^L,12),g=g+D|0,y=W(y^g,8),L=L+y|0,D=W(D^L,7),h=h+P|0,T=W(T^h,16),E=E+T|0,P=W(P^E,12),h=h+P|0,T=W(T^h,8),E=E+T|0,P=W(P^E,7),B=B+_|0,k=W(k^B,16),m=m+k|0,_=W(_^m,12),B=B+_|0,k=W(k^B,8),m=m+k|0,_=W(_^m,7),v=v+M|0,b=W(b^v,16),A=A+b|0,M=W(M^A,12),v=v+M|0,b=W(b^v,8),A=A+b|0,M=W(M^A,7);let C=0;Z[C++]=Q+g|0,Z[C++]=w+h|0,Z[C++]=K+B|0,Z[C++]=G+v|0,Z[C++]=O+M|0,Z[C++]=N+D|0,Z[C++]=X+P|0,Z[C++]=V+_|0,Z[C++]=F+m|0,Z[C++]=z+A|0,Z[C++]=I+L|0,Z[C++]=H+E|0,Z[C++]=S+T|0,Z[C++]=j+k|0,Z[C++]=R+b|0,Z[C++]=d+y|0}function C0(U,$,J,Z){let q=U[0],Y=U[1],Q=U[2],w=U[3],K=$[0],G=$[1],O=$[2],N=$[3],X=$[4],V=$[5],F=$[6],z=$[7],I=J[0],H=J[1],S=J[2],j=J[3];for(let d=0;d<20;d+=2)q=q+K|0,I=W(I^q,16),X=X+I|0,K=W(K^X,12),q=q+K|0,I=W(I^q,8),X=X+I|0,K=W(K^X,7),Y=Y+G|0,H=W(H^Y,16),V=V+H|0,G=W(G^V,12),Y=Y+G|0,H=W(H^Y,8),V=V+H|0,G=W(G^V,7),Q=Q+O|0,S=W(S^Q,16),F=F+S|0,O=W(O^F,12),Q=Q+O|0,S=W(S^Q,8),F=F+S|0,O=W(O^F,7),w=w+N|0,j=W(j^w,16),z=z+j|0,N=W(N^z,12),w=w+N|0,j=W(j^w,8),z=z+j|0,N=W(N^z,7),q=q+G|0,j=W(j^q,16),F=F+j|0,G=W(G^F,12),q=q+G|0,j=W(j^q,8),F=F+j|0,G=W(G^F,7),Y=Y+O|0,I=W(I^Y,16),z=z+I|0,O=W(O^z,12),Y=Y+O|0,I=W(I^Y,8),z=z+I|0,O=W(O^z,7),Q=Q+N|0,H=W(H^Q,16),X=X+H|0,N=W(N^X,12),Q=Q+N|0,H=W(H^Q,8),X=X+H|0,N=W(N^X,7),w=w+K|0,S=W(S^w,16),V=V+S|0,K=W(K^V,12),w=w+K|0,S=W(S^w,8),V=V+S|0,K=W(K^V,7);let R=0;Z[R++]=q,Z[R++]=Y,Z[R++]=Q,Z[R++]=w,Z[R++]=I,Z[R++]=H,Z[R++]=S,Z[R++]=j}var k0=uU(q0,{counterRight:!1,counterLength:4,allowShortKeys:!1}),b0=uU(q0,{counterRight:!1,counterLength:8,extendNonceFn:C0,allowShortKeys:!1});var f0=new Uint8Array(16),J0=(U,$)=>{U.update($);let J=$.length%16;if(J)U.update(f0.subarray(J))},g0=new Uint8Array(32);function Z0(U,$,J,Z,q){if(q!==void 0)u(q,void 0,"AAD");let Y=U($,J,g0),Q=rU(Z.length,q?q.length:0,!0),w=$0.create(Y);if(q)J0(w,q);J0(w,Z),w.update(Q);let K=w.digest();return qU(Y,Q),K}var Y0=(U)=>($,J,Z)=>{return{encrypt(Y,Q){let w=Y.length;Q=yU(w+16,Q,!1),Q.set(Y);let K=Q.subarray(0,-16);U($,J,K,K,1);let G=Z0(U,$,J,K,Z);return Q.set(G,w),qU(G),Q},decrypt(Y,Q){Q=yU(Y.length-16,Q,!1);let w=Y.subarray(0,-16),K=Y.subarray(-16),G=Z0(U,$,J,w,Z);if(!oU(K,G))throw Error("invalid tag");return Q.set(Y.subarray(0,-16)),U($,J,Q,Q,1),qU(G),Q}}},T$=gU({blockSize:64,nonceLength:12,tagLength:16},Y0(k0)),pU=gU({blockSize:64,nonceLength:24,tagLength:16},Y0(b0));class o extends JU{static IV_LENGTH=24;static TAG_LENGTH=16;IV_LENGTH=o.IV_LENGTH;TAG_LENGTH=o.TAG_LENGTH;key=null;constructor(U){super(U)}async setKey(U){this.key=new Uint8Array(await this.p.subtle.exportKey("raw",U))}zeroKey(){if(this.key)this.key.fill(0);this.key=null}async encryptWithAAD(U,$){let J=this.p.getRandomValues(new Uint8Array(o.IV_LENGTH)),q=pU(this.requireRawKey(),J,$).encrypt(U),Y=new Uint8Array(J.length+q.length);return Y.set(J,0),Y.set(q,J.length),Y}async decryptWithAAD(U,$){if(U.byteLength<o.IV_LENGTH+o.TAG_LENGTH)throw new f("Invalid ciphertext: too short.");let J=U.subarray(0,o.IV_LENGTH),Z=U.subarray(o.IV_LENGTH),q=pU(this.requireRawKey(),J,$);try{return q.decrypt(Z)}catch{throw new f("Decryption failed: wrong passphrase or corrupted ciphertext")}}requireRawKey(){if(!this.key)throw Error("Encryption key not set");return this.key}}var AU=MU(require("argon2-browser"));async function y0(){if(typeof window<"u")return;if(globalThis.loadArgon2WasmModule)return;try{let{createRequire:U}=await import("node:module"),{readFile:$}=await import("node:fs/promises"),J=U(import.meta.url),Z=J.resolve("argon2-browser/dist/argon2.js"),q=J.resolve("argon2-browser/dist/argon2.wasm");globalThis.loadArgon2WasmModule=async()=>{let Y=new Uint8Array(await $(q));return globalThis.Module={wasmBinary:Y,locateFile:(Q)=>Q==="argon2.wasm"?q:Q},J(Z)}}catch{}}async function Q0(U,$,J,Z){if(Z==="node"){let q=await import("@node-rs/argon2"),Y=typeof U==="string"?Buffer.from(U,"utf8"):Buffer.from(U),w=(await q.hash(Y,{salt:$,timeCost:J.time,memoryCost:J.mem,parallelism:J.parallelism,outputLen:32,algorithm:q.Algorithm.Argon2id})).split("$").pop();if(!w)throw Error("Unexpected argon2 hash format");let K=Buffer.from(w,"base64");return Y.fill(0),{hash:new Uint8Array(K)}}if(Z==="browser")return await y0(),AU.hash({pass:U,salt:$,time:J.time,mem:J.mem,parallelism:J.parallelism,hashLen:32,type:AU.ArgonType.Argon2id}).then((q)=>{if(!q||!q.hash)throw new $U("Failed to produce key derivation");return{hash:q.hash}}).catch((q)=>{let Y=q instanceof Error?q.message:typeof q==="string"?q:"Unknown error";throw new $U(`argon2-browser failure: ${Y}`)});throw Error(`Unsupported environment: ${Z}`)}class LU{presets;exportExtractable;name="argon2id";constructor(U,$=!1){this.presets=U;this.exportExtractable=$}async derive(U,$,J,Z){let{hash:q}=await Q0(U,$,this.presets[J],Z.isNode?"node":"browser");if(this.exportExtractable)return Z.subtle.importKey("raw",q,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]);else return Z.subtle.importKey("raw",q,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}}var K0={low:{time:5,mem:65536,parallelism:1},middle:{time:20,mem:65536,parallelism:1},high:{time:40,mem:65536,parallelism:1}},l0={id:0,cipher:n,kdf:new LU(K0),saltLengths:{low:12,high:16},difficulties:K0,defaultChunkSize:524288};x.register(l0);var w0={low:{time:5,mem:65536,parallelism:2},middle:{time:10,mem:98304,parallelism:4},high:{time:20,mem:98304,parallelism:4}},u0={id:1,cipher:o,kdf:new LU(w0,!0),saltLengths:{low:12,high:16},difficulties:w0,defaultChunkSize:524288};x.register(u0);var EU=1;function W0(){return typeof process<"u"&&typeof process.versions==="object"&&!0}function XU(...U){let $=U.reduce((q,Y)=>q+Y.byteLength,0),J=new Uint8Array($),Z=0;for(let q of U)J.set(q,Z),Z+=q.byteLength;return J}function VU(...U){try{let $=XU(...U);if(W0())return Buffer.from($).toString("base64");let J="";for(let Z=0;Z<$.length;Z++)J+=String.fromCharCode($[Z]);return btoa(J)}catch{throw new bU("Base64 Encoding Error")}}function jU(U){try{if(!/^[A-Za-z0-9+/]+={0,2}$/.test(U)||U.length%4!==0)throw Error("Invalid Base64");if(W0())return new Uint8Array(Buffer.from(U,"base64"));let $=atob(U),J=new Uint8Array($.length);for(let Z=0;Z<$.length;Z++)J[Z]=$.charCodeAt(Z);return J}catch{throw new TU(`Invalid Base64: length=${U.length}, content='${U.slice(0,12)}…'`)}}function c(U){let $=U.value.length,J=Array($).fill("\x00").join("");U.value=J}function FU(U,$,J,Z,q){let Y={low:0,middle:1,high:2};if(!($ in Y))throw TypeError(`Unsupported difficulty: ${$}`);let Q=Y[$],w=U<<5|(J==="high"?1:0)<<2|Q,K=XU(new Uint8Array([EU,w]),Z);if(q)q.setAAD(K);return K}function r(U,$){if(U[0]!==EU)throw new i("Invalid input format. The input is unknown.");if(U.length<14)throw new i("Invalid input format. Header too short.");try{let J=U[1],Z=J>>5,q=J>>2&1?"high":"low",Y=J&3,Q=["low","middle","high"][Y],w=x.get(Z).saltLengths[q],K=2+w;if(U.length<K)throw new i("Invalid input format. Header truncated.");if($)$.setAAD(U.subarray(0,K));let G=U.slice(2,2+w);return{scheme:Z,difficulty:Q,saltStrength:q,salt:G,headerLen:K}}catch(J){throw new QU(J instanceof Error?J.message:String(J))}}async function CU(U){if(U instanceof Uint8Array)return U;if(U instanceof ArrayBuffer)return new Uint8Array(U);return new Uint8Array(await U.arrayBuffer())}function hU(U){let $=new Uint8Array(4);return new DataView($.buffer).setUint32(0,U,!1),$}function G0(U,$=0){if(U.length-$<4)throw RangeError("Not enough bytes for frame header");return new DataView(U.buffer,U.byteOffset+$,4).getUint32(0,!1)}var YU=4;class BU{engine;chunkSize;buffer=new Uint8Array(0);constructor(U,$=524288){this.engine=U;this.chunkSize=$}toTransformStream(){return new TransformStream({transform:async(U,$)=>{await this.transform(await CU(U),$)},flush:async(U)=>this.flush(U)})}async transform(U,$){if(U.length>Math.min(this.chunkSize*4,67108864))throw RangeError(`Input block (${U.length} B) exceeds maximum allowed ${Math.min(this.chunkSize*4,67108864)} B`);let Z=new Uint8Array(this.buffer.length+U.length);Z.set(this.buffer),Z.set(U,this.buffer.length);let q=0;while(Z.length-q>=this.chunkSize){let Y=Z.slice(q,q+this.chunkSize);q+=this.chunkSize;let Q=await this.engine.encryptChunk(Y),w=new Uint8Array(YU+Q.length);w.set(hU(Q.length)),w.set(Q,YU),$.enqueue(w)}this.buffer=Z.slice(q)}async flush(U){if(!this.buffer.length)return;let $=await this.engine.encryptChunk(this.buffer),J=new Uint8Array(YU+$.length);J.set(hU($.length)),J.set($,YU),U.enqueue(J),this.buffer=new Uint8Array(0),this.engine.zeroKey()}}class HU{engine;chunkSize;buffer=new Uint8Array(0);constructor(U,$=524288){this.engine=U;this.chunkSize=$}toTransformStream(){return new TransformStream({transform:async(U,$)=>{await this.transform(await CU(U),$)},flush:async(U)=>this.flush(U)})}async transform(U,$){let J=new Uint8Array(this.buffer.length+U.length);J.set(this.buffer),J.set(U,this.buffer.length);let Z=0;while(!0){if(J.length-Z<YU)break;let q=G0(J,Z),Y=67108864,Q=this.engine.IV_LENGTH+this.engine.TAG_LENGTH;if(!Number.isInteger(q)||q<Q||q>Y){$.error(new f(`Invalid frame length ${q} (min=${Q}, max=${Y})`));return}if(J.length-Z-YU<q)break;Z+=YU;let w=J.slice(Z,Z+q);Z+=q;try{let K=await this.engine.decryptChunk(w);$.enqueue(K)}catch(K){$.error(K instanceof f?K:new f("Decryption failed: Wrong passphrase or corrupted ciphertext"));return}}this.buffer=J.slice(Z)}async flush(U){await this.transform(new Uint8Array(0),U);let $=this.buffer.byteLength;if(this.buffer=new Uint8Array(0),this.engine.zeroKey(),$!==0){U.error(new f("Truncated ciphertext: incomplete final frame"));return}}}async function O0(U,$){let J=U.getReader(),Z=$&&$.length?[$]:[];try{while(!0){let{value:w,done:K}=await J.read();if(K)break;Z.push(w)}}finally{J.releaseLock()}let q=Z.reduce((w,K)=>w+K.byteLength,0),Y=new Uint8Array(q),Q=0;for(let w of Z)Y.set(w,Q),Q+=w.byteLength;return Y}class IU{engine;chunkSize;constructor(U,$=524288){this.engine=U;this.chunkSize=$}encryptionStream(){let U=new BU(this.engine,this.chunkSize).toTransformStream();return{writable:U.writable,readable:U.readable}}decryptionStream(U){let $=U,J=new TransformStream({transform(q,Y){if($===0){Y.enqueue(q);return}if(q.byteLength<=$){$-=q.byteLength;return}Y.enqueue(q.slice($)),$=0}}),Z=new HU(this.engine,this.chunkSize).toTransformStream();return{writable:J.writable,readable:J.readable.pipeThrough(Z)}}async collect(U,$,J=null){return O0(U.pipeThrough($),J??void 0)}getEngine(){return this.engine}}function N0(U){try{if(U)U.fill(0)}catch{}}function p0(U){let $="";for(let J=0;J<U.length;J++){let Z=U[J].toString(16).padStart(2,"0");$+=Z}return $}class a{bytes;destroyed=!1;static from(U){if(U instanceof a)return U;if(typeof U==="string")return new a(new TextEncoder().encode(U));if(U instanceof Uint8Array)return new a(U);throw TypeError("ConvertibleInput: unsupported input type")}constructor(U){this.bytes=U}toUint8Array(){if(this.destroyed)throw Error("ConvertibleInput: already cleared");return this.bytes}clear(){if(!this.destroyed)N0(this.bytes),this.bytes=new Uint8Array(0),this.destroyed=!0}}class SU{bytes;destroyed=!1;constructor(U){this.bytes=U}get uint8array(){if(this.destroyed)throw Error("ConvertibleOutput: already cleared");return this.bytes}get base64(){if(this.destroyed)throw Error("ConvertibleOutput: already cleared");return VU(this.bytes)}get hex(){if(this.destroyed)throw Error("ConvertibleOutput: already cleared");return p0(this.bytes)}get text(){if(this.destroyed)throw Error("ConvertibleOutput: already cleared");return new TextDecoder().decode(this.bytes)}clear(){if(!this.destroyed)N0(this.bytes),this.bytes=new Uint8Array(0),this.destroyed=!0}toString(){return this.base64}}class vU extends Error{constructor(U="Malformed padding"){super(U)}}class l{static STRUCT_SIZE=8;static MAGIC40=new Uint8Array([196,231,155,173,242]);static VERSION=41;static CRC8_POLY=7;maxPad=l.STRUCT_SIZE+8-1;static ctEqU8(U,$){return(((U|0)^($|0))&255)===0}static ctEqFixedLen(U,$){let J=0,Z=U.length;for(let q=0;q<Z;q++)J|=U[q]^$[q];return J===0}crc8(U){let $=0;for(let J=0;J<U.length;J++){$^=U[J]&255;for(let Z=0;Z<8;Z++)$=$&128?$<<1^l.CRC8_POLY:$<<1,$&=255}return $&255}computeK(U,$){let J=l.STRUCT_SIZE;if(!Number.isInteger($)||$<1)throw new vU("align must be a positive integer");if(J+$-1>255)throw new vU("align too large for 1-byte LEN");let Z=J+$-1,q=($-U%$)%$;if(q===0)q=$;while(q<J)q+=$;if(q>Z)throw new vU("Cannot satisfy alignment within 1-byte LEN");return q}pad(U,$,J=8){let Z=l.STRUCT_SIZE,q=this.computeK(U.length,J),Y=q-Z,Q=new Uint8Array(U.length+q);if(Q.set(U,0),Y>0){let G=$(Y);if(!G||G.length!==Y)throw new vU("rng returned wrong length");Q.set(G,U.length)}let w=U.length+Y;Q.set(l.MAGIC40,w+0),Q[w+5]=l.VERSION&255,Q[w+6]=q&255;let K=new Uint8Array(7);return K.set(l.MAGIC40,0),K[5]=l.VERSION&255,K[6]=q&255,Q[w+7]=this.crc8(K),Q}tryUnpad(U){let $=l.STRUCT_SIZE,J=()=>({used:!1,plain:U});if(U.length<$)return J();let Z=U.length,q=U[Z-1]&255,Y=U[Z-2]&255,Q=U[Z-3]&255;if(Y<$||Y>U.length)return J();let w=Z-$,K=U.subarray(w,w+5);if(!l.ctEqFixedLen(K,l.MAGIC40))return J();if(!l.ctEqU8(Q,l.VERSION&255))return J();let O=new Uint8Array(7);O.set(l.MAGIC40,0),O[5]=Q,O[6]=Y;let N=this.crc8(O);if(!l.ctEqU8(N,q))return J();return{used:!0,plain:U.subarray(0,Z-Y)}}}function T0(U=0,$=console.info){return{level:U,log(J,Z){if(J<=U)$(`${J}| ${Z}`)}}}function z0(U,$,J){if($<0||J<0||$+J>U)throw RangeError("read() slice exceeds data bounds")}class xU{src;#U=null;constructor(U){this.src=U}get length(){if(this.src instanceof Uint8Array)return this.src.byteLength;if(this.src instanceof Blob)return this.src.size;return this.ensureUint8().byteLength}async read(U,$){if(z0(this.length,U,$),this.src instanceof Uint8Array)return this.src.slice(U,U+$);if(this.src instanceof Blob){let J=await this.src.slice(U,U+$).arrayBuffer();return new Uint8Array(J)}return this.ensureUint8().slice(U,U+$)}ensureUint8(){if(!this.#U)this.#U=jU(this.src);return this.#U}}var X0=new WeakMap;class KU{static getEngine(U,$){let J=X0.get(U);if(!J)J=new Map,X0.set(U,J);let Z=J.get($);if(Z)return Z;let q=x.get($);return Z={desc:q,cipher:new q.cipher(U),kdf:q.kdf,chunkSize:q.defaultChunkSize,provider:U},J.set($,Z),Z}static async deriveKey(U,$,J,Z){try{let q=await U.kdf.derive($.value,J,Z,U.provider);await U.cipher.setKey(q)}catch(q){let Y=q instanceof Error?q.message:String(q);throw new $U(Y)}finally{c($)}}}class t{provider;v;cipher;kdf;chunkSize;stream;acceptUnauthenticatedHeader;difficulty;saltStrength;engines=new Map;log;constructor(U,$={}){this.provider=U;this.v=x.get($.scheme??x.current.id),this.cipher=new this.v.cipher(U),this.kdf=this.v.kdf,this.chunkSize=this.setChunkSize($.chunkSize??this.v.defaultChunkSize),this.stream=new IU(this.cipher,this.chunkSize),this.difficulty=$.difficulty??"middle",this.saltStrength=$.saltStrength??"high",this.acceptUnauthenticatedHeader=$.acceptUnauthenticatedHeader??!1,this.log=T0($.verbose??0,$.logger)}static async isEncrypted(U){try{return await t.peekHeader(U),!0}catch{return!1}}static async decodeHeader(U){let $=await t.peekHeader(U),J=r($);return{scheme:J.scheme,difficulty:J.difficulty,salt:VU(J.salt),saltBytes:J.salt,saltLength:J.salt.byteLength}}static async headerDecode(U){return this.decodeHeader(U)}static isRandomAccessSource(U){return typeof U==="object"&&U!==null&&typeof U.read==="function"}static async decodeData(U){let $=t.isRandomAccessSource(U)?U:new xU(U),J=await $.read(0,Math.min(256,$.length)),Z=await t.peekHeader(J),{scheme:q,headerLen:Y}=r(Z),Q=$.length,w=Q-Y;if(w<0)throw new i("Payload underflow");if(w===0)return{isChunked:!0,chunks:{chunkSize:0,count:0,totalPayload:0}};let K=await $.read(Y,4),G=new DataView(K.buffer,K.byteOffset,4).getUint32(0,!1);if(G+4<=w&&G>=28){let F=G,z=Y,I=0,H=0;while(z+4<=Q){let S=await $.read(z,4),j=new DataView(S.buffer,S.byteOffset,4).getUint32(0,!1);if(j===0||z+4+j>Q)break;I++,H+=j,z+=4+j}return{isChunked:!0,chunks:{chunkSize:F,count:I,totalPayload:H}}}let N=await $.read(Y,w),X=x.get(q).cipher.IV_LENGTH,V=x.get(q).cipher.TAG_LENGTH;if(N.length<X+V)throw new i("Ciphertext too short for IV & tag");return{isChunked:!1,payloadLength:w-X-V,params:{iv:N.slice(0,X),ivLength:X,tag:N.slice(N.length-V),tagLength:V}}}setDifficulty(U){this.difficulty=U}getDifficulty(){return this.difficulty}setScheme(U){this.v=x.get(U),this.cipher=new this.v.cipher(this.provider),this.kdf=this.v.kdf,this.stream=new IU(this.cipher,this.chunkSize)}getScheme(){return this.v.id}setSaltDifficulty(U){this.saltStrength=U}getSaltDifficulty(){return this.saltStrength}setChunkSize(U){let J=U,Z;if(J==null)Z=this.v.defaultChunkSize;else{if(Z=Number(J),!Number.isInteger(Z)||Z<1)throw Error(`Invalid chunkSize: ${J}. Must be a positive integer.`);if(Z>134217728)throw RangeError("chunkSize cannot exceed 134217728 bytes.")}if(this.chunkSize=Z,this.stream)this.stream=new IU(this.cipher,this.chunkSize);return Z}getChunkSize(){return this.chunkSize}setVerbose(U){this.log.level=U}getVerbose(){return this.log.level}async encryptText(U,$){if($===null)throw new s("Password can't be null");let J={value:$};try{if($==="")this.log.log(0,"Empty passphrase provided to encryptText");this.log.log(1,`Start text encryption, scheme: ${this.getScheme()}`);let Z=a.from(U),q=Z.toUint8Array();this.log.log(2,"Deriving key for text encryption");let Y=this.genSalt();await this.deriveKey(J,Y),c(J),$=null,this.log.log(3,`Salt generated: ${VU(Y)}, KDF difficulty: ${this.difficulty}`),this.log.log(3,"Encoding header");let Q=FU(this.v.id,this.difficulty,this.saltStrength,Y,this.cipher);this.cipher.setPaddingScheme(new l),this.cipher.setPaddingAlign(8),this.cipher.setPaddingAADMode("require"),this.log.log(2,"Encrypting text data");let w=await this.cipher.encryptChunk(q);this.cipher.zeroKey();try{Z.clear()}catch{}let K=XU(Q,w);return this.log.log(1,"Encryption finished"),new SU(K)}catch(Z){throw new s(Z instanceof Error?Z.message:String(Z))}}async decryptText(U,$){if($===null)throw new s("Password can't be null");let J={value:$};try{if($==="")this.log.log(0,"Empty passphrase provided to decryptText");this.log.log(1,`Start text decryption, Version ${this.getScheme()}`);let Z;if(typeof U==="string")this.log.log(3,"Decoding Base64 ciphertext"),Z=jU(U);else if(U instanceof Uint8Array)Z=U;else if(U instanceof a)Z=U.toUint8Array();else throw new TU("Unsupported ciphertext input type");this.log.log(3,"Start header decoding");let q=r(Z);this.log.log(3,"Selecting decryption engine");let Y=KU.getEngine(this.provider,q.scheme);this.log.log(2,`Deriving key via engine for scheme: ${q.scheme}`),this.log.log(3,`Salt use: ${VU(q.salt)}, KDF difficulty: ${q.difficulty}`);try{await KU.deriveKey(Y,J,q.salt,q.difficulty)}finally{c(J),$=null}Y.cipher.setPaddingScheme(new l),Y.cipher.setPaddingAlign(8),Y.cipher.setPaddingAADMode("require"),Y.cipher.setLegacyAADFallback({enabled:!0,policy:"auto",tryEmptyAAD:this.acceptUnauthenticatedHeader?!0:!1}),this.log.log(2,"Decrypting text data"),r(Z,Y.cipher);let Q=await Y.cipher.decryptChunk(Z.slice(q.headerLen));if(Y.cipher.zeroKey(),U instanceof a)try{U.clear()}catch{}return this.log.log(1,"Decryption finished"),new SU(Q)}catch(Z){if(Z instanceof f||Z instanceof i||Z instanceof QU||Z instanceof TU||Z instanceof $U)throw Z;throw new f("Decryption failed: wrong passphrase or corrupted ciphertext")}}async encryptFile(U,$){if($===null)throw new s("Password can't be null");let J={value:$};try{if(U.size===0){let Q=this.genSalt();await this.deriveKey(J,Q),c(J),$=null;let w=FU(this.v.id,this.difficulty,this.saltStrength,Q);return new Blob([w],{type:"application/octet-stream"})}this.log.log(2,"Deriving key for file encryption");let Z=this.genSalt();await this.deriveKey(J,Z),c(J),$=null;let q=FU(this.v.id,this.difficulty,this.saltStrength,Z,this.stream.getEngine());this.stream.getEngine().setPaddingAADMode("forbid");let Y=await this.stream.collect(U.stream(),new BU(this.cipher,this.chunkSize).toTransformStream(),q);return new Blob([Y],{type:"application/octet-stream"})}catch(Z){throw new s(Z instanceof Error?Z.message:String(Z))}}async decryptFile(U,$){if($===null)throw new s("Password can't be null");let J={value:$};try{let Z=await t.peekHeader(U),q=r(Z),Y=KU.getEngine(this.provider,q.scheme);try{await KU.deriveKey(Y,J,q.salt,q.difficulty)}finally{c(J),$=null}if(U.size===q.headerLen)return new Blob([],{type:"application/octet-stream"});this.log.log(2,"Decrypting file data");let Q=new IU(Y.cipher,Y.chunkSize);r(Z,Q.getEngine()),Y.cipher.setPaddingAADMode("forbid"),Y.cipher.setLegacyAADFallback({enabled:!0,policy:"auto",tryEmptyAAD:this.acceptUnauthenticatedHeader?!0:!1});let w=await Q.collect(U.slice(q.headerLen).stream(),new HU(Y.cipher,Y.chunkSize).toTransformStream());return new Blob([w],{type:"application/octet-stream"})}catch(Z){if(Z instanceof f)throw Z;throw new f(Z instanceof Error?Z.message:String(Z))}}async createEncryptionStream(U){if(U===null)throw new s("Password can't be null");let $={value:U};this.log.log(2,"Deriving key for stream encryption");let J=this.genSalt();await this.deriveKey($,J),c($),U=null;let Z=FU(this.v.id,this.difficulty,this.saltStrength,J,this.stream.getEngine());this.stream.getEngine().setPaddingAADMode("forbid");let q=this.stream.encryptionStream();return{header:Z,writable:q.writable,readable:q.readable}}async createDecryptionStream(U){if(U===null)throw new s("Password can't be null");let $=this.provider,J={value:U},Z=new Uint8Array(0),q=null,Y=65536,Q=2,w=async(K,G)=>{let O=K.getReader();while(!0){let{value:N,done:X}=await O.read();if(X)break;G.enqueue(N)}};return new TransformStream({transform:async(K,G)=>{if(!q){let N=new Uint8Array(0);if(K&&K.byteLength){let R=Math.max(0,Y-Z.byteLength),d=R?K.subarray(0,R):new Uint8Array(0);if(N=K.subarray(d.byteLength),d.byteLength){let g=new Uint8Array(Z.byteLength+d.byteLength);g.set(Z),g.set(d,Z.byteLength),Z=g}}if(Z.byteLength<Q)return;let X=Z[1],V=X>>5,F=X>>2&1?"high":"low",z=0;try{z=2+x.get(V).saltLengths[F]}catch(R){c(J),G.error(new QU(R instanceof Error?R.message:String(R)));return}if(Z.byteLength<z){if(Z.byteLength>=Y)c(J),G.error(new i(`Header not found within ${Y} bytes`));return}let I=Z.subarray(0,z),H;try{H=r(I)}catch(R){c(J),G.error(R instanceof Error?R:new QU("Invalid header"));return}let S=KU.getEngine($,H.scheme);try{await KU.deriveKey(S,J,H.salt,H.difficulty)}finally{c(J),U=null}r(I,S.cipher),S.cipher.setPaddingAADMode("forbid"),S.cipher.setLegacyAADFallback({enabled:!0,policy:"auto",tryEmptyAAD:this.acceptUnauthenticatedHeader?!0:!1}),q=new HU(S.cipher,S.chunkSize).toTransformStream(),w(q.readable,G).catch((R)=>G.error(R));let j=Z.subarray(z);if(Z=new Uint8Array(0),j.byteLength||N.byteLength){let R=q.writable.getWriter();if(j.byteLength)await R.write(j);if(N.byteLength)await R.write(N);R.releaseLock()}return}let O=q.writable.getWriter();await O.write(K),O.releaseLock()},flush:async()=>{if(!q)throw c(J),new i("Header not found before end of stream");let K=q.writable.getWriter();await K.close(),K.releaseLock()}})}generateFakeData(U=0,$=!1){if(!Number.isInteger(U)||U<0)throw RangeError("payloadLength must be a non-negative integer.");let J=this.genSalt(),Z=FU(this.v.id,this.difficulty,this.saltStrength,J,this.cipher),q=U;if($){let K=Math.max(16,q);q=Math.ceil(K/8)*8}let Y=q>0?this.provider.getRandomValues(new Uint8Array(q)):new Uint8Array(0);return XU(Z,Y)}async deriveKey(U,$,J=this.difficulty){let Z=performance.now();try{let q=await this.kdf.derive(U.value,$,J,this.provider);c(U),await this.cipher.setKey(q),this.log.log(3,`Key derivation completed in ${(performance.now()-Z).toFixed(1)} ms`)}catch(q){throw new $U(q instanceof Error?q.message:String(q))}}genSalt(U=this.saltStrength){let $=this.v.saltLengths[U];return this.provider.getRandomValues(new Uint8Array($))}static async peekHeader(U){let $=await this.readAsUint8(U);if($.length<2)throw new i("Input too short");let{headerLen:J}=r($.length>=32?$:$.slice());if($.length<J)throw new i("Incomplete header");return $.slice(0,J)}static async readAsUint8(U){if(typeof U==="string")return jU(U);if(U instanceof Uint8Array)return U;if(U instanceof Blob){let $=Math.max(32,Math.min(256,U.size)),J=U.slice(0,$);return new Uint8Array(await J.arrayBuffer())}throw new QU("Unsupported input type")}}var kU=require("node:crypto"),V0={subtle:kU.webcrypto.subtle,getRandomValues(U){return kU.randomFillSync(U),U},isNode:!0};function h0(U){return new t(V0,U)}

//# debugId=94B60A1B964686C364756E2164756E21
