var sU=Object.create;var{getPrototypeOf:aU,defineProperty:P0,getOwnPropertyNames:UU,getOwnPropertyDescriptor:tU}=Object,$U=Object.prototype.hasOwnProperty;var YU=(U,$,J)=>{J=U!=null?sU(aU(U)):{};let Y=$||!U||!U.__esModule?P0(J,"default",{value:U,enumerable:!0}):J;for(let Q of UU(U))if(!$U.call(Y,Q))P0(Y,Q,{get:()=>U[Q],enumerable:!0});return Y},e0=new WeakMap,eU=(U)=>{var $=e0.get(U),J;if($)return $;if($=P0({},"__esModule",{value:!0}),U&&typeof U==="object"||typeof U==="function")UU(U).map((Y)=>!$U.call($,Y)&&P0($,Y,{get:()=>U[Y],enumerable:!(J=tU(U,Y))||J.enumerable}));return e0.set(U,$),$},S0=(U,$)=>()=>($||U(($={exports:{}}).exports,$),$.exports);var U$=(U,$)=>{for(var J in $)P0(U,J,{get:$[J],enumerable:!0,configurable:!0,set:(Y)=>$[J]=()=>Y})};var AU=S0((VY,TU)=>{var v0=/^[a-z0-9-]{1,32}$/,C0=/^[a-z0-9-]{1,32}$/,L0=/^[a-zA-Z0-9/+.-]+$/,zU=/^([a-zA-Z0-9/+.-]+|)$/,F$=/^((-)?[1-9]\d*|0)$/,x0=/^v=(\d+)$/;function z$(U){return M0(U).map(($)=>[$,U[$]].join("=")).join(",")}function O$(U){let $={};return U.split(",").forEach((J)=>{let Y=J.split("=");if(Y.length<2)throw new TypeError("params must be in the format name=value");$[Y.shift()]=Y.join("=")}),$}function M0(U){return Object.keys(U)}function OU(U){if(typeof Object.values==="function")return Object.values(U);return M0(U).map(($)=>U[$])}function T$(U){let $=[""];if(typeof U!=="object"||U===null)throw new TypeError("opts must be an object");if(typeof U.id!=="string")throw new TypeError("id must be a string");if(!v0.test(U.id))throw new TypeError(`id must satisfy ${v0}`);if($.push(U.id),typeof U.version!=="undefined"){if(typeof U.version!=="number"||U.version<0||!Number.isInteger(U.version))throw new TypeError("version must be a positive integer number");$.push(`v=${U.version}`)}if(typeof U.params!=="undefined"){if(typeof U.params!=="object"||U.params===null)throw new TypeError("params must be an object");let Y=M0(U.params);if(!Y.every((W)=>C0.test(W)))throw new TypeError(`params names must satisfy ${C0}`);Y.forEach((W)=>{if(typeof U.params[W]==="number")U.params[W]=U.params[W].toString();else if(Buffer.isBuffer(U.params[W]))U.params[W]=U.params[W].toString("base64").split("=")[0]});let Q=OU(U.params);if(!Q.every((W)=>typeof W==="string"))throw new TypeError("params values must be strings");if(!Q.every((W)=>L0.test(W)))throw new TypeError(`params values must satisfy ${L0}`);let Z=z$(U.params);$.push(Z)}if(typeof U.salt!=="undefined"){if(!Buffer.isBuffer(U.salt))throw new TypeError("salt must be a Buffer");if($.push(U.salt.toString("base64").split("=")[0]),typeof U.hash!=="undefined"){if(!Buffer.isBuffer(U.hash))throw new TypeError("hash must be a Buffer");$.push(U.hash.toString("base64").split("=")[0])}}return $.join("$")}function A$(U){if(typeof U!=="string"||U==="")throw new TypeError("pchstr must be a non-empty string");if(U[0]!=="$")throw new TypeError("pchstr must contain a $ as first char");let $=U.split("$");$.shift();let J=5;if(!x0.test($[1]))J--;if($.length>J)throw new TypeError(`pchstr contains too many fileds: ${$.length}/${J}`);let Y=$.shift();if(!v0.test(Y))throw new TypeError(`id must satisfy ${v0}`);let Q;if(x0.test($[0]))Q=parseInt($.shift().match(x0)[1],10);let Z,W;if(zU.test($[$.length-1]))if($.length>1&&zU.test($[$.length-2]))Z=Buffer.from($.pop(),"base64"),W=Buffer.from($.pop(),"base64");else W=Buffer.from($.pop(),"base64");let q;if($.length>0){let G=$.pop();if(q=O$(G),!M0(q).every((P)=>C0.test(P)))throw new TypeError(`params names must satisfy ${C0}`);if(!OU(q).every((P)=>L0.test(P)))throw new TypeError(`params values must satisfy ${L0}`);M0(q).forEach((P)=>{q[P]=F$.test(q[P])?parseInt(q[P],10):q[P]})}if($.length>0)throw new TypeError(`pchstr contains unrecognized fileds: ${$}`);let V={id:Y};if(Q)V.version=Q;if(q)V.params=q;if(W)V.salt=W;if(Z)V.hash=Z;return V}TU.exports={serialize:T$,deserialize:A$}});var bU=S0((GY,yU)=>{var RU=require("fs"),a=require("path"),BU=require("os"),EU=typeof __webpack_require__==="function"?__non_webpack_require__:require,S$=process.config&&process.config.variables||{},D$=!!process.env.PREBUILDS_ONLY,SU=process.versions.modules,n0=B$()?"electron":R$()?"node-webkit":"node",p0=process.env.npm_config_arch||BU.arch(),i0=process.env.npm_config_platform||BU.platform(),jU=process.env.LIBC||(E$(i0)?"musl":"glibc"),o0=process.env.ARM_VERSION||(p0==="arm64"?"8":S$.arm_version)||"",_U=(process.versions.uv||"").split(".")[0];yU.exports=n;function n(U){return EU(n.resolve(U))}n.resolve=n.path=function(U){U=a.resolve(U||".");try{var $=EU(a.join(U,"package.json")).name.toUpperCase().replace(/-/g,"_");if(process.env[$+"_PREBUILD"])U=process.env[$+"_PREBUILD"]}catch(V){}if(!D$){var J=DU(a.join(U,"build/Release"),wU);if(J)return J;var Y=DU(a.join(U,"build/Debug"),wU);if(Y)return Y}var Q=q(U);if(Q)return Q;var Z=q(a.dirname(process.execPath));if(Z)return Z;var W=["platform="+i0,"arch="+p0,"runtime="+n0,"abi="+SU,"uv="+_U,o0?"armv="+o0:"","libc="+jU,"node="+process.versions.node,process.versions.electron?"electron="+process.versions.electron:"",typeof __webpack_require__==="function"?"webpack=true":""].filter(Boolean).join(" ");throw new Error("No native build was found for "+W+`
    loaded from: `+U+`
`);function q(V){var G=r0(a.join(V,"prebuilds")).map(vU),I=G.filter(CU(i0,p0)).sort(LU)[0];if(!I)return;var H=a.join(V,"prebuilds",I.name),P=r0(H).map(mU),N=P.filter(kU(n0,SU)),M=N.sort(gU(n0))[0];if(M)return a.join(H,M.file)}};function r0(U){try{return RU.readdirSync(U)}catch($){return[]}}function DU(U,$){var J=r0(U).filter($);return J[0]&&a.join(U,J[0])}function wU(U){return/\.node$/.test(U)}function vU(U){var $=U.split("-");if($.length!==2)return;var J=$[0],Y=$[1].split("+");if(!J)return;if(!Y.length)return;if(!Y.every(Boolean))return;return{name:U,platform:J,architectures:Y}}function CU(U,$){return function(J){if(J==null)return!1;if(J.platform!==U)return!1;return J.architectures.includes($)}}function LU(U,$){return U.architectures.length-$.architectures.length}function mU(U){var $=U.split("."),J=$.pop(),Y={file:U,specificity:0};if(J!=="node")return;for(var Q=0;Q<$.length;Q++){var Z=$[Q];if(Z==="node"||Z==="electron"||Z==="node-webkit")Y.runtime=Z;else if(Z==="napi")Y.napi=!0;else if(Z.slice(0,3)==="abi")Y.abi=Z.slice(3);else if(Z.slice(0,2)==="uv")Y.uv=Z.slice(2);else if(Z.slice(0,4)==="armv")Y.armv=Z.slice(4);else if(Z==="glibc"||Z==="musl")Y.libc=Z;else continue;Y.specificity++}return Y}function kU(U,$){return function(J){if(J==null)return!1;if(J.runtime&&J.runtime!==U&&!w$(J))return!1;if(J.abi&&J.abi!==$&&!J.napi)return!1;if(J.uv&&J.uv!==_U)return!1;if(J.armv&&J.armv!==o0)return!1;if(J.libc&&J.libc!==jU)return!1;return!0}}function w$(U){return U.runtime==="node"&&U.napi}function gU(U){return function($,J){if($.runtime!==J.runtime)return $.runtime===U?-1:1;else if($.abi!==J.abi)return $.abi?-1:1;else if($.specificity!==J.specificity)return $.specificity>J.specificity?-1:1;else return 0}}function R$(){return!!(process.versions&&process.versions.nw)}function B$(){if(process.versions&&process.versions.electron)return!0;if(process.env.ELECTRON_RUN_AS_NODE)return!0;return typeof window!=="undefined"&&window.process&&window.process.type==="renderer"}function E$(U){return U==="linux"&&RU.existsSync("/etc/alpine-release")}n.parseTags=mU;n.matchTags=kU;n.compareTags=gU;n.parseTuple=vU;n.matchTuple=CU;n.compareTuples=LU});var fU=S0((XY,a0)=>{var s0=typeof __webpack_require__==="function"?__non_webpack_require__:require;if(typeof s0.addon==="function")a0.exports=s0.addon.bind(s0);else a0.exports=bU()});var uU=S0((HY,Q0)=>{var __dirname="/Users/maxim/Projects/Private/Sites/cryptit/node_modules/argon2",IY=require("node:assert"),{randomBytes:j$,timingSafeEqual:_$}=require("node:crypto"),{promisify:v$}=require("node:util"),{deserialize:cU,serialize:C$}=AU(),L$=fU(),{hash:lU}=L$(__dirname),m$=v$(j$);Q0.exports.argon2d=0;Q0.exports.argon2i=1;Q0.exports.argon2id=2;var N0=Object.freeze({argon2d:0,argon2i:1,argon2id:2}),k$=Object.freeze({[N0.argon2d]:"argon2d",[N0.argon2i]:"argon2i",[N0.argon2id]:"argon2id"}),dU={hashLength:32,timeCost:3,memoryCost:65536,parallelism:4,type:2,version:19};async function g$(U,$){let{raw:J,salt:Y,...Q}={...dU,...$};if(Q.hashLength>4294967295)throw new RangeError("Hash length is too large");if(Q.memoryCost>4294967295)throw new RangeError("Memory cost is too large");if(Q.timeCost>4294967295)throw new RangeError("Time cost is too large");if(Q.parallelism>16777215)throw new RangeError("Parallelism is too large");Y=Y??await m$(16);let{hashLength:Z,secret:W=Buffer.alloc(0),type:q,version:V,memoryCost:G,timeCost:I,parallelism:H,associatedData:P=Buffer.alloc(0)}=Q,N=await lU({password:Buffer.from(U),salt:Y,secret:W,data:P,hashLength:Z,m:G,t:I,p:H,version:V,type:q});if(J)return N;return C$({id:k$[q],version:V,params:{m:G,t:I,p:H,...P.byteLength>0?{data:P}:{}},salt:Y,hash:N})}Q0.exports.hash=g$;function y$(U,$={}){let{memoryCost:J,timeCost:Y,parallelism:Q,version:Z}={...dU,...$},{version:W,params:{m:q,t:V,p:G}}=cU(U);return+W!==+Z||+q!==+J||+V!==+Y||+G!==+Q}Q0.exports.needsRehash=y$;async function b$(U,$,J={}){let{id:Y,...Q}=cU(U);if(!(Y in N0))return!1;let{version:Z=16,params:{m:W,t:q,p:V,data:G=""},salt:I,hash:H}=Q,{secret:P=Buffer.alloc(0)}=J;return _$(await lU({password:Buffer.from($),salt:I,secret:P,data:Buffer.from(G,"base64"),hashLength:H.byteLength,m:+W,t:+q,p:+V,version:+Z,type:N0[Y]}),H)}Q0.exports.verify=b$});var d$={};U$(d$,{createCryptit:()=>l$});module.exports=eU(d$);class i extends Error{constructor(U){super(U);Object.setPrototypeOf(this,new.target.prototype),this.name=new.target.name,this.stack=void 0}}class x extends i{}class K0 extends i{}class b0 extends i{}class D0 extends i{}class $0 extends i{}class o extends i{}class w0 extends i{}class u extends i{}class d{static byId=new Map;static register(U){if(this.byId.has(U.id))throw new D0(`Scheme ${U.id} already registered`);this.byId.set(U.id,U)}static get(U){let $=this.byId.get(U);if(!$)throw new D0(`Unknown scheme: ${U}`);return $}static get current(){return this.get(0)}}class Y0{p;static IV_LENGTH=12;IV_LENGTH=Y0.IV_LENGTH;key;constructor(U){this.p=U}async setKey(U){this.key=U}async encryptChunk(U){let $=this.p.getRandomValues(new Uint8Array(Y0.IV_LENGTH)),J=new Uint8Array(await this.p.subtle.encrypt({name:"AES-GCM",iv:$},this.key,U));U.fill(0);let Y=new Uint8Array($.length+J.length);return Y.set($),Y.set(J,$.length),Y}async decryptChunk(U){let $=U.slice(0,Y0.IV_LENGTH),J=U.slice(Y0.IV_LENGTH);try{let Y=await this.p.subtle.decrypt({name:"AES-GCM",iv:$},this.key,J);return new Uint8Array(Y)}catch{throw new u("Decryption failed: wrong passphrase or corrupted ciphertext")}}zeroKey(){}}/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function QU(U){return U instanceof Uint8Array||ArrayBuffer.isView(U)&&U.constructor.name==="Uint8Array"}function R0(U){if(typeof U!=="boolean")throw new Error(`boolean expected, not ${U}`)}function B0(U){if(!Number.isSafeInteger(U)||U<0)throw new Error("positive integer expected, got "+U)}function l(U,...$){if(!QU(U))throw new Error("Uint8Array expected");if($.length>0&&!$.includes(U.length))throw new Error("Uint8Array expected of length "+$+", got length="+U.length)}function f0(U,$=!0){if(U.destroyed)throw new Error("Hash instance has been destroyed");if($&&U.finished)throw new Error("Hash#digest() has already been called")}function WU(U,$){l(U);let J=$.outputLen;if(U.length<J)throw new Error("digestInto() expects output buffer of length at least "+J)}function r(U){return new Uint32Array(U.buffer,U.byteOffset,Math.floor(U.byteLength/4))}function s(...U){for(let $=0;$<U.length;$++)U[$].fill(0)}function $$(U){return new DataView(U.buffer,U.byteOffset,U.byteLength)}var Y$=(()=>new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68)();function J$(U){if(typeof U!=="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(U))}function E0(U){if(typeof U==="string")U=J$(U);else if(QU(U))U=j0(U);else throw new Error("Uint8Array expected, got "+typeof U);return U}function ZU(U,$){if($==null||typeof $!=="object")throw new Error("options must be defined");return Object.assign(U,$)}function qU(U,$){if(U.length!==$.length)return!1;let J=0;for(let Y=0;Y<U.length;Y++)J|=U[Y]^$[Y];return J===0}var c0=(U,$)=>{function J(Y,...Q){if(l(Y),!Y$)throw new Error("Non little-endian hardware is not yet supported");if(U.nonceLength!==void 0){let I=Q[0];if(!I)throw new Error("nonce / iv required");if(U.varSizeNonce)l(I);else l(I,U.nonceLength)}let Z=U.tagLength;if(Z&&Q[1]!==void 0)l(Q[1]);let W=$(Y,...Q),q=(I,H)=>{if(H!==void 0){if(I!==2)throw new Error("cipher output not supported");l(H)}},V=!1;return{encrypt(I,H){if(V)throw new Error("cannot encrypt() twice with same key + nonce");return V=!0,l(I),q(W.encrypt.length,H),W.encrypt(I,H)},decrypt(I,H){if(l(I),Z&&I.length<Z)throw new Error("invalid ciphertext length: smaller than tagLength="+Z);return q(W.decrypt.length,H),W.decrypt(I,H)}}}return Object.assign(J,U),J};function l0(U,$,J=!0){if($===void 0)return new Uint8Array(U);if($.length!==U)throw new Error("invalid output length, expected "+U+", got: "+$.length);if(J&&!Q$($))throw new Error("invalid output, must be aligned");return $}function JU(U,$,J,Y){if(typeof U.setBigUint64==="function")return U.setBigUint64($,J,Y);let Q=BigInt(32),Z=BigInt(4294967295),W=Number(J>>Q&Z),q=Number(J&Z),V=Y?4:0,G=Y?0:4;U.setUint32($+V,W,Y),U.setUint32($+G,q,Y)}function VU(U,$,J){R0(J);let Y=new Uint8Array(16),Q=$$(Y);return JU(Q,0,BigInt($),J),JU(Q,8,BigInt(U),J),Y}function Q$(U){return U.byteOffset%4===0}function j0(U){return Uint8Array.from(U)}var XU=(U)=>Uint8Array.from(U.split("").map(($)=>$.charCodeAt(0))),W$=XU("expand 16-byte k"),Z$=XU("expand 32-byte k"),q$=r(W$),V$=r(Z$);function X(U,$){return U<<$|U>>>32-$}function d0(U){return U.byteOffset%4===0}var _0=64,G$=16,IU=4294967295,GU=new Uint32Array;function X$(U,$,J,Y,Q,Z,W,q){let V=Q.length,G=new Uint8Array(_0),I=r(G),H=d0(Q)&&d0(Z),P=H?r(Q):GU,N=H?r(Z):GU;for(let M=0;M<V;W++){if(U($,J,Y,I,W,q),W>=IU)throw new Error("arx: counter overflow");let F=Math.min(_0,V-M);if(H&&F===_0){let z=M/4;if(M%4!==0)throw new Error("arx: invalid block position");for(let O=0,T;O<G$;O++)T=z+O,N[T]=P[T]^I[O];M+=_0;continue}for(let z=0,O;z<F;z++)O=M+z,Z[O]=Q[O]^G[z];M+=F}}function u0(U,$){let{allowShortKeys:J,extendNonceFn:Y,counterLength:Q,counterRight:Z,rounds:W}=ZU({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},$);if(typeof U!=="function")throw new Error("core must be a function");return B0(Q),B0(W),R0(Z),R0(J),(q,V,G,I,H=0)=>{l(q),l(V),l(G);let P=G.length;if(I===void 0)I=new Uint8Array(P);if(l(I),B0(H),H<0||H>=IU)throw new Error("arx: counter overflow");if(I.length<P)throw new Error(`arx: output (${I.length}) is shorter than data (${P})`);let N=[],M=q.length,F,z;if(M===32)N.push(F=j0(q)),z=V$;else if(M===16&&J)F=new Uint8Array(32),F.set(q),F.set(q,16),z=q$,N.push(F);else throw new Error(`arx: invalid 32-byte key, got length=${M}`);if(!d0(V))N.push(V=j0(V));let O=r(F);if(Y){if(V.length!==24)throw new Error("arx: extended nonce must be 24 bytes");Y(z,O,r(V.subarray(0,16)),O),V=V.subarray(16)}let T=16-Q;if(T!==V.length)throw new Error(`arx: nonce must be ${T} or 16 bytes`);if(T!==12){let y=new Uint8Array(12);y.set(V,Z?0:12-V.length),V=y,N.push(V)}let m=r(V);return X$(U,z,O,m,G,I,H,W),s(...N),I}}var b=(U,$)=>U[$++]&255|(U[$++]&255)<<8;class HU{constructor(U){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,U=E0(U),l(U,32);let $=b(U,0),J=b(U,2),Y=b(U,4),Q=b(U,6),Z=b(U,8),W=b(U,10),q=b(U,12),V=b(U,14);this.r[0]=$&8191,this.r[1]=($>>>13|J<<3)&8191,this.r[2]=(J>>>10|Y<<6)&7939,this.r[3]=(Y>>>7|Q<<9)&8191,this.r[4]=(Q>>>4|Z<<12)&255,this.r[5]=Z>>>1&8190,this.r[6]=(Z>>>14|W<<2)&8191,this.r[7]=(W>>>11|q<<5)&8065,this.r[8]=(q>>>8|V<<8)&8191,this.r[9]=V>>>5&127;for(let G=0;G<8;G++)this.pad[G]=b(U,16+2*G)}process(U,$,J=!1){let Y=J?0:2048,{h:Q,r:Z}=this,W=Z[0],q=Z[1],V=Z[2],G=Z[3],I=Z[4],H=Z[5],P=Z[6],N=Z[7],M=Z[8],F=Z[9],z=b(U,$+0),O=b(U,$+2),T=b(U,$+4),m=b(U,$+6),y=b(U,$+8),t=b(U,$+10),f=b(U,$+12),c=b(U,$+14),A=Q[0]+(z&8191),S=Q[1]+((z>>>13|O<<3)&8191),D=Q[2]+((O>>>10|T<<6)&8191),w=Q[3]+((T>>>7|m<<9)&8191),R=Q[4]+((m>>>4|y<<12)&8191),B=Q[5]+(y>>>1&8191),E=Q[6]+((y>>>14|t<<2)&8191),j=Q[7]+((t>>>11|f<<5)&8191),_=Q[8]+((f>>>8|c<<8)&8191),v=Q[9]+(c>>>5|Y),K=0,L=K+A*W+S*(5*F)+D*(5*M)+w*(5*N)+R*(5*P);K=L>>>13,L&=8191,L+=B*(5*H)+E*(5*I)+j*(5*G)+_*(5*V)+v*(5*q),K+=L>>>13,L&=8191;let k=K+A*q+S*W+D*(5*F)+w*(5*M)+R*(5*N);K=k>>>13,k&=8191,k+=B*(5*P)+E*(5*H)+j*(5*I)+_*(5*G)+v*(5*V),K+=k>>>13,k&=8191;let g=K+A*V+S*q+D*W+w*(5*F)+R*(5*M);K=g>>>13,g&=8191,g+=B*(5*N)+E*(5*P)+j*(5*H)+_*(5*I)+v*(5*G),K+=g>>>13,g&=8191;let C=K+A*G+S*V+D*q+w*W+R*(5*F);K=C>>>13,C&=8191,C+=B*(5*M)+E*(5*N)+j*(5*P)+_*(5*H)+v*(5*I),K+=C>>>13,C&=8191;let p=K+A*I+S*G+D*V+w*q+R*W;K=p>>>13,p&=8191,p+=B*(5*F)+E*(5*M)+j*(5*N)+_*(5*P)+v*(5*H),K+=p>>>13,p&=8191;let Z0=K+A*H+S*I+D*G+w*V+R*q;K=Z0>>>13,Z0&=8191,Z0+=B*W+E*(5*F)+j*(5*M)+_*(5*N)+v*(5*P),K+=Z0>>>13,Z0&=8191;let q0=K+A*P+S*H+D*I+w*G+R*V;K=q0>>>13,q0&=8191,q0+=B*q+E*W+j*(5*F)+_*(5*M)+v*(5*N),K+=q0>>>13,q0&=8191;let V0=K+A*N+S*P+D*H+w*I+R*G;K=V0>>>13,V0&=8191,V0+=B*V+E*q+j*W+_*(5*F)+v*(5*M),K+=V0>>>13,V0&=8191;let G0=K+A*M+S*N+D*P+w*H+R*I;K=G0>>>13,G0&=8191,G0+=B*G+E*V+j*q+_*W+v*(5*F),K+=G0>>>13,G0&=8191;let X0=K+A*F+S*M+D*N+w*P+R*H;K=X0>>>13,X0&=8191,X0+=B*I+E*G+j*V+_*q+v*W,K+=X0>>>13,X0&=8191,K=(K<<2)+K|0,K=K+L|0,L=K&8191,K=K>>>13,k+=K,Q[0]=L,Q[1]=k,Q[2]=g,Q[3]=C,Q[4]=p,Q[5]=Z0,Q[6]=q0,Q[7]=V0,Q[8]=G0,Q[9]=X0}finalize(){let{h:U,pad:$}=this,J=new Uint16Array(10),Y=U[1]>>>13;U[1]&=8191;for(let W=2;W<10;W++)U[W]+=Y,Y=U[W]>>>13,U[W]&=8191;U[0]+=Y*5,Y=U[0]>>>13,U[0]&=8191,U[1]+=Y,Y=U[1]>>>13,U[1]&=8191,U[2]+=Y,J[0]=U[0]+5,Y=J[0]>>>13,J[0]&=8191;for(let W=1;W<10;W++)J[W]=U[W]+Y,Y=J[W]>>>13,J[W]&=8191;J[9]-=8192;let Q=(Y^1)-1;for(let W=0;W<10;W++)J[W]&=Q;Q=~Q;for(let W=0;W<10;W++)U[W]=U[W]&Q|J[W];U[0]=(U[0]|U[1]<<13)&65535,U[1]=(U[1]>>>3|U[2]<<10)&65535,U[2]=(U[2]>>>6|U[3]<<7)&65535,U[3]=(U[3]>>>9|U[4]<<4)&65535,U[4]=(U[4]>>>12|U[5]<<1|U[6]<<14)&65535,U[5]=(U[6]>>>2|U[7]<<11)&65535,U[6]=(U[7]>>>5|U[8]<<8)&65535,U[7]=(U[8]>>>8|U[9]<<5)&65535;let Z=U[0]+$[0];U[0]=Z&65535;for(let W=1;W<8;W++)Z=(U[W]+$[W]|0)+(Z>>>16)|0,U[W]=Z&65535;s(J)}update(U){f0(this),U=E0(U),l(U);let{buffer:$,blockLen:J}=this,Y=U.length;for(let Q=0;Q<Y;){let Z=Math.min(J-this.pos,Y-Q);if(Z===J){for(;J<=Y-Q;Q+=J)this.process(U,Q);continue}if($.set(U.subarray(Q,Q+Z),this.pos),this.pos+=Z,Q+=Z,this.pos===J)this.process($,0,!1),this.pos=0}return this}destroy(){s(this.h,this.r,this.buffer,this.pad)}digestInto(U){f0(this),WU(U,this),this.finished=!0;let{buffer:$,h:J}=this,{pos:Y}=this;if(Y){$[Y++]=1;for(;Y<16;Y++)$[Y]=0;this.process($,0,!0)}this.finalize();let Q=0;for(let Z=0;Z<8;Z++)U[Q++]=J[Z]>>>0,U[Q++]=J[Z]>>>8;return U}digest(){let{buffer:U,outputLen:$}=this;this.digestInto(U);let J=U.slice(0,$);return this.destroy(),J}}function I$(U){let $=(Y,Q)=>U(Q).update(E0(Y)).digest(),J=U(new Uint8Array(32));return $.outputLen=J.outputLen,$.blockLen=J.blockLen,$.create=(Y)=>U(Y),$}var PU=I$((U)=>new HU(U));function NU(U,$,J,Y,Q,Z=20){let W=U[0],q=U[1],V=U[2],G=U[3],I=$[0],H=$[1],P=$[2],N=$[3],M=$[4],F=$[5],z=$[6],O=$[7],T=Q,m=J[0],y=J[1],t=J[2],f=W,c=q,A=V,S=G,D=I,w=H,R=P,B=N,E=M,j=F,_=z,v=O,K=T,L=m,k=y,g=t;for(let p=0;p<Z;p+=2)f=f+D|0,K=X(K^f,16),E=E+K|0,D=X(D^E,12),f=f+D|0,K=X(K^f,8),E=E+K|0,D=X(D^E,7),c=c+w|0,L=X(L^c,16),j=j+L|0,w=X(w^j,12),c=c+w|0,L=X(L^c,8),j=j+L|0,w=X(w^j,7),A=A+R|0,k=X(k^A,16),_=_+k|0,R=X(R^_,12),A=A+R|0,k=X(k^A,8),_=_+k|0,R=X(R^_,7),S=S+B|0,g=X(g^S,16),v=v+g|0,B=X(B^v,12),S=S+B|0,g=X(g^S,8),v=v+g|0,B=X(B^v,7),f=f+w|0,g=X(g^f,16),_=_+g|0,w=X(w^_,12),f=f+w|0,g=X(g^f,8),_=_+g|0,w=X(w^_,7),c=c+R|0,K=X(K^c,16),v=v+K|0,R=X(R^v,12),c=c+R|0,K=X(K^c,8),v=v+K|0,R=X(R^v,7),A=A+B|0,L=X(L^A,16),E=E+L|0,B=X(B^E,12),A=A+B|0,L=X(L^A,8),E=E+L|0,B=X(B^E,7),S=S+D|0,k=X(k^S,16),j=j+k|0,D=X(D^j,12),S=S+D|0,k=X(k^S,8),j=j+k|0,D=X(D^j,7);let C=0;Y[C++]=W+f|0,Y[C++]=q+c|0,Y[C++]=V+A|0,Y[C++]=G+S|0,Y[C++]=I+D|0,Y[C++]=H+w|0,Y[C++]=P+R|0,Y[C++]=N+B|0,Y[C++]=M+E|0,Y[C++]=F+j|0,Y[C++]=z+_|0,Y[C++]=O+v|0,Y[C++]=T+K|0,Y[C++]=m+L|0,Y[C++]=y+k|0,Y[C++]=t+g|0}function H$(U,$,J,Y){let Q=U[0],Z=U[1],W=U[2],q=U[3],V=$[0],G=$[1],I=$[2],H=$[3],P=$[4],N=$[5],M=$[6],F=$[7],z=J[0],O=J[1],T=J[2],m=J[3];for(let t=0;t<20;t+=2)Q=Q+V|0,z=X(z^Q,16),P=P+z|0,V=X(V^P,12),Q=Q+V|0,z=X(z^Q,8),P=P+z|0,V=X(V^P,7),Z=Z+G|0,O=X(O^Z,16),N=N+O|0,G=X(G^N,12),Z=Z+G|0,O=X(O^Z,8),N=N+O|0,G=X(G^N,7),W=W+I|0,T=X(T^W,16),M=M+T|0,I=X(I^M,12),W=W+I|0,T=X(T^W,8),M=M+T|0,I=X(I^M,7),q=q+H|0,m=X(m^q,16),F=F+m|0,H=X(H^F,12),q=q+H|0,m=X(m^q,8),F=F+m|0,H=X(H^F,7),Q=Q+G|0,m=X(m^Q,16),M=M+m|0,G=X(G^M,12),Q=Q+G|0,m=X(m^Q,8),M=M+m|0,G=X(G^M,7),Z=Z+I|0,z=X(z^Z,16),F=F+z|0,I=X(I^F,12),Z=Z+I|0,z=X(z^Z,8),F=F+z|0,I=X(I^F,7),W=W+H|0,O=X(O^W,16),P=P+O|0,H=X(H^P,12),W=W+H|0,O=X(O^W,8),P=P+O|0,H=X(H^P,7),q=q+V|0,T=X(T^q,16),N=N+T|0,V=X(V^N,12),q=q+V|0,T=X(T^q,8),N=N+T|0,V=X(V^N,7);let y=0;Y[y++]=Q,Y[y++]=Z,Y[y++]=W,Y[y++]=q,Y[y++]=z,Y[y++]=O,Y[y++]=T,Y[y++]=m}var P$=u0(NU,{counterRight:!1,counterLength:4,allowShortKeys:!1}),K$=u0(NU,{counterRight:!1,counterLength:8,extendNonceFn:H$,allowShortKeys:!1});var M$=new Uint8Array(16),KU=(U,$)=>{U.update($);let J=$.length%16;if(J)U.update(M$.subarray(J))},N$=new Uint8Array(32);function MU(U,$,J,Y,Q){let Z=U($,J,N$),W=PU.create(Z);if(Q)KU(W,Q);KU(W,Y);let q=VU(Y.length,Q?Q.length:0,!0);W.update(q);let V=W.digest();return s(Z,q),V}var FU=(U)=>($,J,Y)=>{return{encrypt(Z,W){let q=Z.length;W=l0(q+16,W,!1),W.set(Z);let V=W.subarray(0,-16);U($,J,V,V,1);let G=MU(U,$,J,V,Y);return W.set(G,q),s(G),W},decrypt(Z,W){W=l0(Z.length-16,W,!1);let q=Z.subarray(0,-16),V=Z.subarray(-16),G=MU(U,$,J,q,Y);if(!qU(V,G))throw new Error("invalid tag");return W.set(Z.subarray(0,-16)),U($,J,W,W,1),s(G),W}}},JY=c0({blockSize:64,nonceLength:12,tagLength:16},FU(P$)),h0=c0({blockSize:64,nonceLength:24,tagLength:16},FU(K$));class J0{p;static IV_LENGTH=24;IV_LENGTH=J0.IV_LENGTH;key;constructor(U){this.p=U}async setKey(U){this.key=new Uint8Array(await this.p.subtle.exportKey("raw",U))}async encryptChunk(U){let $=this.p.getRandomValues(new Uint8Array(J0.IV_LENGTH)),Y=h0(this.key,$).encrypt(U);U.fill(0);let Q=new Uint8Array($.length+Y.length);return Q.set($,0),Q.set(Y,$.length),Q}async decryptChunk(U){let $=U.slice(0,J0.IV_LENGTH),J=U.slice(J0.IV_LENGTH),Y=h0(this.key,$);try{return Y.decrypt(J)}catch{throw new u("Decryption failed: wrong passphrase or corrupted ciphertext")}}zeroKey(){this.key.fill(0)}}var m0=YU(require("argon2-browser"));async function hU(U,$,J,Y){if(Y==="node"){let Q=await Promise.resolve().then(() => YU(uU())),Z=typeof U==="string"?Buffer.from(U,"utf8"):Buffer.from(U),W=Buffer.from($),q=await Q.hash(Z,{salt:W,timeCost:J.time,memoryCost:J.mem,parallelism:J.parallelism,hashLength:32,raw:!0,type:Q.argon2id});return W.fill(0),Z.fill(0),{hash:new Uint8Array(q)}}if(Y==="browser"){if(!("loadArgon2WasmBinary"in globalThis))globalThis.loadArgon2WasmBinary=()=>fetch("argon2.wasm").then((Q)=>{if(!Q.ok)throw new Error("Failed to load argon2.wasm");return Q.arrayBuffer()}).then((Q)=>new Uint8Array(Q));return m0.hash({pass:U,salt:$,time:J.time,mem:J.mem,parallelism:J.parallelism,hashLen:32,type:m0.ArgonType.Argon2id}).then((Q)=>{if(!Q||!Q.hash)throw new o("Failed to produce key derivation");return{hash:Q.hash}}).catch((Q)=>{let Z=Q instanceof Error?Q.message:typeof Q==="string"?Q:"Unknown error";throw new o(`argon2-browser failure: ${Z}`)})}throw new Error(`Unsupported environment: ${Y}`)}class k0{presets;exportExtractable;name="argon2id";constructor(U,$=!1){this.presets=U;this.exportExtractable=$}async derive(U,$,J,Y){let{hash:Q}=await hU(U,$,this.presets[J],Y.isNode?"node":"browser");if(this.exportExtractable)return Y.subtle.importKey("raw",Q,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]);else return Y.subtle.importKey("raw",Q,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}}var xU={low:{time:5,mem:65536,parallelism:1},middle:{time:20,mem:65536,parallelism:1},high:{time:40,mem:65536,parallelism:1}},f$={id:0,cipher:Y0,kdf:new k0(xU),saltLengths:{low:12,high:16},difficulties:xU,defaultChunkSize:524288};d.register(f$);var nU={low:{time:5,mem:65536,parallelism:2},middle:{time:10,mem:98304,parallelism:4},high:{time:20,mem:98304,parallelism:4}},c$={id:1,cipher:J0,kdf:new k0(nU,!0),saltLengths:{low:12,high:16},difficulties:nU,defaultChunkSize:524288};d.register(c$);var g0=1;function pU(){return typeof process!=="undefined"&&typeof process.versions==="object"&&!0}function F0(...U){let $=U.reduce((Q,Z)=>Q+Z.byteLength,0),J=new Uint8Array($),Y=0;for(let Q of U)J.set(Q,Y),Y+=Q.byteLength;return J}function z0(...U){try{let $=F0(...U);if(pU())return Buffer.from($).toString("base64");let J="";for(let Y=0;Y<$.length;Y++)J+=String.fromCharCode($[Y]);return btoa(J)}catch($){throw new b0("Base64 Encoding Error")}}function O0(U){try{if(!/^[A-Za-z0-9+/]+={0,2}$/.test(U)||U.length%4!==0)throw new Error("Invalid Base64");if(pU())return new Uint8Array(Buffer.from(U,"base64"));let $=atob(U),J=new Uint8Array($.length);for(let Y=0;Y<$.length;Y++)J[Y]=$.charCodeAt(Y);return J}catch($){throw new K0(`Invalid Base64: length=${U.length}, content='${U.slice(0,12)}â€¦'`)}}function h(U){let $=U.value.length,J=new Array($).fill("\x00").join("");U.value=J}function T0(U,$,J,Y){let Q={low:0,middle:1,high:2}[$]??0,Z=U<<5|(J==="high"?1:0)<<2|Q;return F0(new Uint8Array([g0,Z]),Y)}function W0(U){if(U[0]!==g0)throw new x("Invalid input format. The input is unknown.");if(U.length<14)throw new x("Invalid input format. Header too short.");try{let $=U[1],J=$>>5,Y=$>>2&1?"high":"low",Q=$&3,Z=["low","middle","high"][Q],W=d.get(J).saltLengths[Y],q=U.slice(2,2+W);return{scheme:J,difficulty:Z,saltStrength:Y,salt:q,headerLen:2+W}}catch($){throw new $0($ instanceof Error?$.message:String($))}}class A0{engine;chunkSize;buffer=new Uint8Array(0);constructor(U,$=524288){this.engine=U;this.chunkSize=$}toTransformStream(){return new TransformStream({transform:async(U,$)=>{await this.transform(await this.asUint8Array(U),$)},flush:async(U)=>this.flush(U)})}async transform(U,$){if(U.length>this.chunkSize*4)throw new RangeError(`Input block (${U.length} B) exceeds sane limit`);let J=new Uint8Array(this.buffer.length+U.length);J.set(this.buffer),J.set(U,this.buffer.length);let Y=0;while(J.length-Y>=this.chunkSize){let Q=J.slice(Y,Y+this.chunkSize);Y+=this.chunkSize;let Z=await this.engine.encryptChunk(Q),W=new Uint8Array(4);new DataView(W.buffer).setUint32(0,Z.length,!1);let q=new Uint8Array(4+Z.length);q.set(W),q.set(Z,W.length),$.enqueue(q)}this.buffer=J.slice(Y)}async flush(U){if(!this.buffer.length)return;let $=await this.engine.encryptChunk(this.buffer),J=new Uint8Array(4);new DataView(J.buffer).setUint32(0,$.length,!1);let Y=new Uint8Array(4+$.length);Y.set(J),Y.set($,4),U.enqueue(Y),this.buffer=new Uint8Array(0),this.engine.zeroKey()}async asUint8Array(U){if(U instanceof Uint8Array)return U;if(U instanceof ArrayBuffer)return new Uint8Array(U);return new Uint8Array(await U.arrayBuffer())}}class I0{engine;chunkSize;buffer=new Uint8Array(0);constructor(U,$=524288){this.engine=U;this.chunkSize=$}toTransformStream(){return new TransformStream({transform:async(U,$)=>{await this.transform(await this.asUint8Array(U),$)},flush:async(U)=>this.flush(U)})}async transform(U,$){let J=new Uint8Array(this.buffer.length+U.length);J.set(this.buffer),J.set(U,this.buffer.length);let Y=0;while(!0){if(J.length-Y<4)break;let Q=new DataView(J.buffer,J.byteOffset+Y,4).getUint32(0,!1);if(Q>this.chunkSize*2)throw new u(`Frame length ${Q} exceeds maximum allowed ${this.chunkSize*2}`);if(J.length-Y-4<Q)break;Y+=4;let Z=J.slice(Y,Y+Q);Y+=Q;try{let W=await this.engine.decryptChunk(Z);$.enqueue(W)}catch(W){throw W instanceof u?W:new u("Decryption failed: Wrong passphrase or corrupted ciphertext")}}this.buffer=J.slice(Y)}async flush(U){await this.transform(new Uint8Array(0),U),this.buffer=new Uint8Array(0),this.engine.zeroKey()}async asUint8Array(U){if(U instanceof Uint8Array)return U;if(U instanceof ArrayBuffer)return new Uint8Array(U);return new Uint8Array(await U.arrayBuffer())}}class H0{engine;chunkSize;constructor(U,$=524288){this.engine=U;this.chunkSize=$}encryptionStream(){let U=new A0(this.engine,this.chunkSize).toTransformStream();return{writable:U.writable,readable:U.readable}}decryptionStream(U){let $=U,J=new TransformStream({transform(Q,Z){if($===0){Z.enqueue(Q);return}if(Q.byteLength<=$){$-=Q.byteLength;return}Z.enqueue(Q.slice($)),$=0}}),Y=new I0(this.engine,this.chunkSize).toTransformStream();return{writable:J.writable,readable:J.readable.pipeThrough(Y)}}async collect(U,$,J=null){let Y=U.pipeThrough($).getReader(),Q=[];if(J?.length)Q.push(J);try{while(!0){let{value:V,done:G}=await Y.read();if(G)break;Q.push(V)}await Y.closed}finally{Y.releaseLock()}let Z=Q.reduce((V,G)=>V+G.byteLength,0),W=new Uint8Array(Z),q=0;for(let V of Q)W.set(V,q),q+=V.byteLength;return W}}function iU(U=0,$=console.info){return{level:U,log(J,Y){if(J<=U)$(`${J}| ${Y}`)}}}class t0{src;#U=null;constructor(U){this.src=U}get length(){if(this.src instanceof Uint8Array)return this.src.byteLength;if(this.src instanceof Blob)return this.src.size;return this.ensureUint8().byteLength}async read(U,$){if(U<0||$<0||U+$>this.length)throw new RangeError("read() slice exceeds data bounds");if(this.src instanceof Uint8Array)return this.src.slice(U,U+$);if(this.src instanceof Blob){let J=await this.src.slice(U,U+$).arrayBuffer();return new Uint8Array(J)}return this.ensureUint8().slice(U,U+$)}ensureUint8(){if(!this.#U)this.#U=O0(this.src);return this.#U}}var oU=new WeakMap;class e{static getEngine(U,$){let J=oU.get(U);if(!J)J=new Map,oU.set(U,J);let Y=J.get($);if(Y)return Y;let Q=d.get($);return Y={desc:Q,cipher:new Q.cipher(U),kdf:Q.kdf,chunkSize:Q.defaultChunkSize,provider:U},J.set($,Y),Y}static async deriveKey(U,$,J,Y){try{let Q=await U.kdf.derive($.value,J,Y,U.provider);h($),await U.cipher.setKey(Q)}catch(Q){let Z=Q instanceof Error?Q.message:String(Q);throw new o(Z)}}}class U0{provider;v;cipher;kdf;chunkSize;stream;difficulty;saltStrength;engines=new Map;log;constructor(U,$={}){this.provider=U;this.v=d.get($.scheme??d.current.id),this.cipher=new this.v.cipher(U),this.kdf=this.v.kdf,this.chunkSize=this.setChunkSize($.chunkSize??this.v.defaultChunkSize),this.stream=new H0(this.cipher,this.chunkSize),this.difficulty=$.difficulty??"middle",this.saltStrength=$.saltStrength??"high",this.log=iU($.verbose??0,$.logger)}static async isEncrypted(U){try{return await U0.peekHeader(U),!0}catch{return!1}}static async headerDecode(U){let $=await U0.peekHeader(U),J=W0($);return{scheme:J.scheme,difficulty:J.difficulty,salt:z0(J.salt),saltLength:J.salt.byteLength}}static async decodeData(U){let $=typeof U?.read==="function"?U:new t0(U),J=await $.read(0,Math.min(256,$.length)),Y=await U0.peekHeader(J),{scheme:Q,headerLen:Z}=W0(Y),W=$.length,q=W-Z;if(q<=0)throw new x("Payload is empty");let V=await $.read(Z,4),G=new DataView(V.buffer,V.byteOffset,4).getUint32(0,!1);if(G+4<=q&&G>=28){let N=G,M=Z,F=0,z=0;while(M+4<=W){let O=await $.read(M,4),T=new DataView(O.buffer,O.byteOffset,4).getUint32(0,!1);if(T===0||M+4+T>W)break;F++,z+=T,M+=4+T}return{isChunked:!0,chunks:{chunkSize:N,count:F,totalPayload:z}}}let H=await $.read(Z,q),P=d.get(Q).cipher.IV_LENGTH;if(H.length<P+16)throw new x("Ciphertext too short for IV & tag");return{isChunked:!1,payloadLength:q,params:{iv:H.slice(0,P),tag:H.slice(H.length-16)}}}setDifficulty(U){this.difficulty=U}getDifficulty(){return this.difficulty}setScheme(U){this.v=d.get(U),this.cipher=new this.v.cipher(this.provider),this.kdf=this.v.kdf,this.stream=new H0(this.cipher,this.chunkSize)}getScheme(){return this.v.id}setSaltDifficulty(U){this.saltStrength=U}getSaltDifficulty(){return this.saltStrength}setChunkSize(U){let $=U,J;if($==null)J=this.v.defaultChunkSize;else if(J=Number($),!Number.isInteger(J)||J<1)throw new Error(`Invalid chunkSize: ${$}. Must be a positive integer.`);return this.chunkSize=J,this.stream=new H0(this.cipher,this.chunkSize),J}getChunkSize(){return this.chunkSize}setVerbose(U){this.log.level=U}getVerbose(){return this.log.level}async encryptText(U,$){let J={value:$};try{this.log.log(1,`Start text encryption, scheme: ${this.getScheme()}`),this.log.log(2,"Deriving key for text encryption");let Y=this.genSalt();await this.deriveKey(J,Y),h(J),$=null,this.log.log(3,`Salt generated: ${z0(Y)}, KDF difficulty: ${this.difficulty}`),this.log.log(2,"Encrypting text data");let Q=await this.cipher.encryptChunk(typeof U==="string"?new TextEncoder().encode(U):U);this.cipher.zeroKey(),this.log.log(3,"Encoding header");let Z=T0(this.v.id,this.difficulty,this.saltStrength,Y);this.log.log(3,"Encoding text");let W=z0(Z,Q);return this.log.log(1,"Decryption finished"),W}catch(Y){throw new w0(Y instanceof Error?Y.message:String(Y))}}async decryptText(U,$){let J={value:$};try{this.log.log(1,`Start text decryption, Version ${this.getScheme()}`),this.log.log(3,"Start text decoding");let Y=O0(U);this.log.log(3,"Start header decoding"),await U0.peekHeader(U);let Q=W0(Y);this.log.log(3,"Trying to get engine");let Z=e.getEngine(this.provider,Q.scheme);this.log.log(2,`Deriving key via engine for scheme: ${Q.scheme}`),this.log.log(3,`Salt use: ${z0(Q.salt)}, KDF difficulty: ${Q.difficulty}`);try{await e.deriveKey(Z,J,Q.salt,Q.difficulty)}finally{h(J),$=null}this.log.log(2,"Decrypting text data");let W=await Z.cipher.decryptChunk(Y.slice(Q.headerLen));Z.cipher.zeroKey(),this.log.log(3,"Decoding text");let q=new TextDecoder().decode(W);return this.log.log(1,"Decryption finished"),q}catch(Y){if(Y instanceof u||Y instanceof x||Y instanceof $0||Y instanceof K0||Y instanceof o)throw Y;throw new u("Decryption failed: wrong passphrase or corrupted ciphertext")}}async encryptFile(U,$){let J={value:$};try{if(U.size===0){let W=this.genSalt();await this.deriveKey(J,W),h(J),$=null;let q=T0(this.v.id,this.difficulty,this.saltStrength,W);return new Blob([q],{type:"application/octet-stream"})}this.log.log(2,"Deriving key for file encryption");let Y=this.genSalt();await this.deriveKey(J,Y),h(J),$=null;let Q=T0(this.v.id,this.difficulty,this.saltStrength,Y),Z=await this.stream.collect(U.stream(),new A0(this.cipher,this.chunkSize).toTransformStream(),Q);return new Blob([Z],{type:"application/octet-stream"})}catch(Y){throw new w0(Y instanceof Error?Y.message:String(Y))}}async decryptFile(U,$){let J={value:$};try{let Y=await U0.peekHeader(U),Q=W0(Y),Z=e.getEngine(this.provider,Q.scheme);try{await e.deriveKey(Z,J,Q.salt,Q.difficulty)}finally{h(J),$=null}if(U.size===Q.headerLen)return new Blob([],{type:"application/octet-stream"});this.log.log(2,"Decrypting file data");let q=await new H0(Z.cipher,Z.chunkSize).collect(U.slice(Q.headerLen).stream(),new I0(Z.cipher,Z.chunkSize).toTransformStream());return new Blob([q],{type:"application/octet-stream"})}catch(Y){if(Y instanceof u)throw Y;throw new u(Y instanceof Error?Y.message:String(Y))}}async createEncryptionStream(U){let $={value:U};this.log.log(2,"Deriving key for stream encryption");let J=this.genSalt();await this.deriveKey($,J),h($),U=null;let Y=T0(this.v.id,this.difficulty,this.saltStrength,J),Q=this.stream.encryptionStream();return{header:Y,writable:Q.writable,readable:Q.readable}}async createDecryptionStream(U){let $={value:U},J=this,Y=new Uint8Array(0),Q=null;async function Z(W,q){let V=W.getReader();while(!0){let{value:G,done:I}=await V.read();if(I)break;q.enqueue(G)}}return new TransformStream({async transform(W,q){if(!Q){if(Y=F0(Y,W),Y.length<2)return;let G=Y.slice(0,30),{salt:I,difficulty:H}=W0(G),P=Y[1]>>5,N=Y[1]>>2&1?"high":"low",F=2+d.get(P).saltLengths[N];if(Y.length<F)return;let z=e.getEngine(J.provider,P);try{await e.deriveKey(z,$,I,H)}finally{h($),U=null}Q=new I0(z.cipher,z.chunkSize).toTransformStream(),Z(Q.readable,q).catch((T)=>{q.error(T)});let O=Y.slice(F);if(O.length){let T=Q.writable.getWriter();await T.write(O),T.releaseLock()}return}let V=Q.writable.getWriter();await V.write(W),V.releaseLock()},async flush(){if(Q){let W=Q.writable.getWriter();await W.close(),W.releaseLock()}}})}async deriveKey(U,$,J=this.difficulty){let Y=performance.now();try{let Q=await this.kdf.derive(U.value,$,J,this.provider);h(U),await this.cipher.setKey(Q),this.log.log(3,`Key derivation completed in ${(performance.now()-Y).toFixed(1)} ms`)}catch(Q){throw new o(Q instanceof Error?Q.message:String(Q))}}genSalt(U=this.saltStrength){let $=this.v.saltLengths[this.saltStrength];return this.provider.getRandomValues(new Uint8Array($))}static async peekHeader(U){let $=await this.readAsUint8(U);if($ instanceof Uint8Array){if($.length<2)throw new x("Input too short");let{headerLen:J}=W0($.length>=16?$:Uint8Array.from($));if($.length<J)throw new x("Incomplete header");return $.slice(0,J)}throw new $0("Unsupported input type")}static async readAsUint8(U){if(typeof U==="string")return O0(U);if(U instanceof Uint8Array)return U;if(U instanceof Blob)return new Uint8Array(await U.arrayBuffer());throw new $0("Unsupported input type")}}var y0=require("node:crypto"),rU={subtle:y0.webcrypto.subtle,getRandomValues(U){return y0.randomFillSync(U),U},isNode:!0};function l$(U){return new U0(rU,U)}

//# debugId=ABECDBEDF6F95BE164756E2164756E21
