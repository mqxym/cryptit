var J$=Object.create;var{getPrototypeOf:Q$,defineProperty:wU,getOwnPropertyNames:Q0,getOwnPropertyDescriptor:W$}=Object,W0=Object.prototype.hasOwnProperty;var Y0=(U,$,Q)=>{Q=U!=null?J$(Q$(U)):{};let J=$||!U||!U.__esModule?wU(Q,"default",{value:U,enumerable:!0}):Q;for(let W of Q0(U))if(!W0.call(J,W))wU(J,W,{get:()=>U[W],enumerable:!0});return J},J0=new WeakMap,Y$=(U)=>{var $=J0.get(U),Q;if($)return $;if($=wU({},"__esModule",{value:!0}),U&&typeof U==="object"||typeof U==="function")Q0(U).map((J)=>!W0.call($,J)&&wU($,J,{get:()=>U[J],enumerable:!(Q=W$(U,J))||Q.enumerable}));return J0.set(U,$),$},FU=(U,$)=>()=>($||U(($={exports:{}}).exports,$),$.exports);var Z$=(U,$)=>{for(var Q in $)wU(U,Q,{get:$[Q],enumerable:!0,configurable:!0,set:(J)=>$[Q]=()=>J})};var D0=FU((wJ,F0)=>{var jU=/^[a-z0-9-]{1,32}$/,_U=/^[a-z0-9-]{1,32}$/,mU=/^[a-zA-Z0-9/+.-]+$/,A0=/^([a-zA-Z0-9/+.-]+|)$/,F$=/^((-)?[1-9]\d*|0)$/,xU=/^v=(\d+)$/;function D$(U){return HU(U).map(($)=>[$,U[$]].join("=")).join(",")}function B$(U){let $={};return U.split(",").forEach((Q)=>{let J=Q.split("=");if(J.length<2)throw new TypeError("params must be in the format name=value");$[J.shift()]=J.join("=")}),$}function HU(U){return Object.keys(U)}function S0(U){if(typeof Object.values==="function")return Object.values(U);return HU(U).map(($)=>U[$])}function R$(U){let $=[""];if(typeof U!=="object"||U===null)throw new TypeError("opts must be an object");if(typeof U.id!=="string")throw new TypeError("id must be a string");if(!jU.test(U.id))throw new TypeError(`id must satisfy ${jU}`);if($.push(U.id),typeof U.version!=="undefined"){if(typeof U.version!=="number"||U.version<0||!Number.isInteger(U.version))throw new TypeError("version must be a positive integer number");$.push(`v=${U.version}`)}if(typeof U.params!=="undefined"){if(typeof U.params!=="object"||U.params===null)throw new TypeError("params must be an object");let J=HU(U.params);if(!J.every((Y)=>_U.test(Y)))throw new TypeError(`params names must satisfy ${_U}`);J.forEach((Y)=>{if(typeof U.params[Y]==="number")U.params[Y]=U.params[Y].toString();else if(Buffer.isBuffer(U.params[Y]))U.params[Y]=U.params[Y].toString("base64").split("=")[0]});let W=S0(U.params);if(!W.every((Y)=>typeof Y==="string"))throw new TypeError("params values must be strings");if(!W.every((Y)=>mU.test(Y)))throw new TypeError(`params values must satisfy ${mU}`);let Z=D$(U.params);$.push(Z)}if(typeof U.salt!=="undefined"){if(!Buffer.isBuffer(U.salt))throw new TypeError("salt must be a Buffer");if($.push(U.salt.toString("base64").split("=")[0]),typeof U.hash!=="undefined"){if(!Buffer.isBuffer(U.hash))throw new TypeError("hash must be a Buffer");$.push(U.hash.toString("base64").split("=")[0])}}return $.join("$")}function E$(U){if(typeof U!=="string"||U==="")throw new TypeError("pchstr must be a non-empty string");if(U[0]!=="$")throw new TypeError("pchstr must contain a $ as first char");let $=U.split("$");$.shift();let Q=5;if(!xU.test($[1]))Q--;if($.length>Q)throw new TypeError(`pchstr contains too many fileds: ${$.length}/${Q}`);let J=$.shift();if(!jU.test(J))throw new TypeError(`id must satisfy ${jU}`);let W;if(xU.test($[0]))W=parseInt($.shift().match(xU)[1],10);let Z,Y;if(A0.test($[$.length-1]))if($.length>1&&A0.test($[$.length-2]))Z=Buffer.from($.pop(),"base64"),Y=Buffer.from($.pop(),"base64");else Y=Buffer.from($.pop(),"base64");let q;if($.length>0){let G=$.pop();if(q=B$(G),!HU(q).every((N)=>_U.test(N)))throw new TypeError(`params names must satisfy ${_U}`);if(!S0(q).every((N)=>mU.test(N)))throw new TypeError(`params values must satisfy ${mU}`);HU(q).forEach((N)=>{q[N]=F$.test(q[N])?parseInt(q[N],10):q[N]})}if($.length>0)throw new TypeError(`pchstr contains unrecognized fileds: ${$}`);let V={id:J};if(W)V.version=W;if(q)V.params=q;if(Y)V.salt=Y;if(Z)V.hash=Z;return V}F0.exports={serialize:R$,deserialize:E$}});var n0=FU((KJ,c0)=>{var L0=require("fs"),a=require("path"),v0=require("os"),C0=typeof __webpack_require__==="function"?__non_webpack_require__:require,L$=process.config&&process.config.variables||{},v$=!!process.env.PREBUILDS_ONLY,B0=process.versions.modules,iU=_$()?"electron":j$()?"node-webkit":"node",rU=process.env.npm_config_arch||v0.arch(),oU=process.env.npm_config_platform||v0.platform(),j0=process.env.LIBC||(m$(oU)?"musl":"glibc"),sU=process.env.ARM_VERSION||(rU==="arm64"?"8":L$.arm_version)||"",_0=(process.versions.uv||"").split(".")[0];c0.exports=p;function p(U){return C0(p.resolve(U))}p.resolve=p.path=function(U){U=a.resolve(U||".");try{var $=C0(a.join(U,"package.json")).name.toUpperCase().replace(/-/g,"_");if(process.env[$+"_PREBUILD"])U=process.env[$+"_PREBUILD"]}catch(V){}if(!v$){var Q=R0(a.join(U,"build/Release"),E0);if(Q)return Q;var J=R0(a.join(U,"build/Debug"),E0);if(J)return J}var W=q(U);if(W)return W;var Z=q(a.dirname(process.execPath));if(Z)return Z;var Y=["platform="+oU,"arch="+rU,"runtime="+iU,"abi="+B0,"uv="+_0,sU?"armv="+sU:"","libc="+j0,"node="+process.versions.node,process.versions.electron?"electron="+process.versions.electron:"",typeof __webpack_require__==="function"?"webpack=true":""].filter(Boolean).join(" ");throw new Error("No native build was found for "+Y+`
    loaded from: `+U+`
`);function q(V){var G=aU(a.join(V,"prebuilds")).map(m0),I=G.filter(k0(oU,rU)).sort(y0)[0];if(!I)return;var P=a.join(V,"prebuilds",I.name),N=aU(P).map(f0),H=N.filter(g0(iU,B0)),K=H.sort(b0(iU))[0];if(K)return a.join(P,K.file)}};function aU(U){try{return L0.readdirSync(U)}catch($){return[]}}function R0(U,$){var Q=aU(U).filter($);return Q[0]&&a.join(U,Q[0])}function E0(U){return/\.node$/.test(U)}function m0(U){var $=U.split("-");if($.length!==2)return;var Q=$[0],J=$[1].split("+");if(!Q)return;if(!J.length)return;if(!J.every(Boolean))return;return{name:U,platform:Q,architectures:J}}function k0(U,$){return function(Q){if(Q==null)return!1;if(Q.platform!==U)return!1;return Q.architectures.includes($)}}function y0(U,$){return U.architectures.length-$.architectures.length}function f0(U){var $=U.split("."),Q=$.pop(),J={file:U,specificity:0};if(Q!=="node")return;for(var W=0;W<$.length;W++){var Z=$[W];if(Z==="node"||Z==="electron"||Z==="node-webkit")J.runtime=Z;else if(Z==="napi")J.napi=!0;else if(Z.slice(0,3)==="abi")J.abi=Z.slice(3);else if(Z.slice(0,2)==="uv")J.uv=Z.slice(2);else if(Z.slice(0,4)==="armv")J.armv=Z.slice(4);else if(Z==="glibc"||Z==="musl")J.libc=Z;else continue;J.specificity++}return J}function g0(U,$){return function(Q){if(Q==null)return!1;if(Q.runtime&&Q.runtime!==U&&!C$(Q))return!1;if(Q.abi&&Q.abi!==$&&!Q.napi)return!1;if(Q.uv&&Q.uv!==_0)return!1;if(Q.armv&&Q.armv!==sU)return!1;if(Q.libc&&Q.libc!==j0)return!1;return!0}}function C$(U){return U.runtime==="node"&&U.napi}function b0(U){return function($,Q){if($.runtime!==Q.runtime)return $.runtime===U?-1:1;else if($.abi!==Q.abi)return $.abi?-1:1;else if($.specificity!==Q.specificity)return $.specificity>Q.specificity?-1:1;else return 0}}function j$(){return!!(process.versions&&process.versions.nw)}function _$(){if(process.versions&&process.versions.electron)return!0;if(process.env.ELECTRON_RUN_AS_NODE)return!0;return typeof window!=="undefined"&&window.process&&window.process.type==="renderer"}function m$(U){return U==="linux"&&L0.existsSync("/etc/alpine-release")}p.parseTags=f0;p.matchTags=g0;p.compareTags=b0;p.parseTuple=m0;p.matchTuple=k0;p.compareTuples=y0});var l0=FU((HJ,eU)=>{var tU=typeof __webpack_require__==="function"?__non_webpack_require__:require;if(typeof tU.addon==="function")eU.exports=tU.addon.bind(tU);else eU.exports=n0()});var p0=FU((OJ,WU)=>{var __dirname="/Users/maxim/Projects/Private/Sites/cryptit/node_modules/argon2",MJ=require("node:assert"),{randomBytes:k$,timingSafeEqual:y$}=require("node:crypto"),{promisify:f$}=require("node:util"),{deserialize:u0,serialize:g$}=D0(),b$=l0(),{hash:d0}=b$(__dirname),c$=f$(k$);WU.exports.argon2d=0;WU.exports.argon2i=1;WU.exports.argon2id=2;var MU=Object.freeze({argon2d:0,argon2i:1,argon2id:2}),n$=Object.freeze({[MU.argon2d]:"argon2d",[MU.argon2i]:"argon2i",[MU.argon2id]:"argon2id"}),h0={hashLength:32,timeCost:3,memoryCost:65536,parallelism:4,type:2,version:19};async function l$(U,$){let{raw:Q,salt:J,...W}={...h0,...$};if(W.hashLength>4294967295)throw new RangeError("Hash length is too large");if(W.memoryCost>4294967295)throw new RangeError("Memory cost is too large");if(W.timeCost>4294967295)throw new RangeError("Time cost is too large");if(W.parallelism>16777215)throw new RangeError("Parallelism is too large");J=J??await c$(16);let{hashLength:Z,secret:Y=Buffer.alloc(0),type:q,version:V,memoryCost:G,timeCost:I,parallelism:P,associatedData:N=Buffer.alloc(0)}=W,H=await d0({password:Buffer.from(U),salt:J,secret:Y,data:N,hashLength:Z,m:G,t:I,p:P,version:V,type:q});if(Q)return H;return g$({id:n$[q],version:V,params:{m:G,t:I,p:P,...N.byteLength>0?{data:N}:{}},salt:J,hash:H})}WU.exports.hash=l$;function u$(U,$={}){let{memoryCost:Q,timeCost:J,parallelism:W,version:Z}={...h0,...$},{version:Y,params:{m:q,t:V,p:G}}=u0(U);return+Y!==+Z||+q!==+Q||+V!==+J||+G!==+W}WU.exports.needsRehash=u$;async function d$(U,$,Q={}){let{id:J,...W}=u0(U);if(!(J in MU))return!1;let{version:Z=16,params:{m:Y,t:q,p:V,data:G=""},salt:I,hash:P}=W,{secret:N=Buffer.alloc(0)}=Q;return y$(await d0({password:Buffer.from($),salt:I,secret:N,data:Buffer.from(G,"base64"),hashLength:P.byteLength,m:+Y,t:+q,p:+V,version:+Z,type:MU[J]}),P)}WU.exports.verify=d$});var i$={};Z$(i$,{createCryptit:()=>x$});module.exports=Y$(i$);class i extends Error{constructor(U){super(U);Object.setPrototypeOf(this,new.target.prototype),this.name=new.target.name,this.stack=void 0}}class h extends i{}class KU extends i{}class cU extends i{}class DU extends i{}class IU extends i{}class r extends i{}class BU extends i{}class u extends i{}class l{static byId=new Map;static register(U){if(this.byId.has(U.id))throw new DU(`Scheme ${U.id} already registered`);this.byId.set(U.id,U)}static get(U){let $=this.byId.get(U);if(!$)throw new DU(`Unknown scheme: ${U}`);return $}static get current(){return this.get(0)}}class JU{p;static IV_LENGTH=12;IV_LENGTH=JU.IV_LENGTH;key;constructor(U){this.p=U}async setKey(U){this.key=U}async encryptChunk(U){let $=this.p.getRandomValues(new Uint8Array(JU.IV_LENGTH)),Q=new Uint8Array(await this.p.subtle.encrypt({name:"AES-GCM",iv:$},this.key,U));U.fill(0);let J=new Uint8Array($.length+Q.length);return J.set($),J.set(Q,$.length),J}async decryptChunk(U){let $=U.slice(0,JU.IV_LENGTH),Q=U.slice(JU.IV_LENGTH);try{let J=await this.p.subtle.decrypt({name:"AES-GCM",iv:$},this.key,Q);return new Uint8Array(J)}catch{throw new u("Decryption failed: wrong passphrase or corrupted ciphertext")}}zeroKey(){}}/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function q0(U){return U instanceof Uint8Array||ArrayBuffer.isView(U)&&U.constructor.name==="Uint8Array"}function RU(U){if(typeof U!=="boolean")throw new Error(`boolean expected, not ${U}`)}function EU(U){if(!Number.isSafeInteger(U)||U<0)throw new Error("positive integer expected, got "+U)}function n(U,...$){if(!q0(U))throw new Error("Uint8Array expected");if($.length>0&&!$.includes(U.length))throw new Error("Uint8Array expected of length "+$+", got length="+U.length)}function nU(U,$=!0){if(U.destroyed)throw new Error("Hash instance has been destroyed");if($&&U.finished)throw new Error("Hash#digest() has already been called")}function V0(U,$){n(U);let Q=$.outputLen;if(U.length<Q)throw new Error("digestInto() expects output buffer of length at least "+Q)}function o(U){return new Uint32Array(U.buffer,U.byteOffset,Math.floor(U.byteLength/4))}function s(...U){for(let $=0;$<U.length;$++)U[$].fill(0)}function q$(U){return new DataView(U.buffer,U.byteOffset,U.byteLength)}var V$=(()=>new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68)();function G$(U){if(typeof U!=="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(U))}function LU(U){if(typeof U==="string")U=G$(U);else if(q0(U))U=vU(U);else throw new Error("Uint8Array expected, got "+typeof U);return U}function G0(U,$){if($==null||typeof $!=="object")throw new Error("options must be defined");return Object.assign(U,$)}function X0(U,$){if(U.length!==$.length)return!1;let Q=0;for(let J=0;J<U.length;J++)Q|=U[J]^$[J];return Q===0}var lU=(U,$)=>{function Q(J,...W){if(n(J),!V$)throw new Error("Non little-endian hardware is not yet supported");if(U.nonceLength!==void 0){let I=W[0];if(!I)throw new Error("nonce / iv required");if(U.varSizeNonce)n(I);else n(I,U.nonceLength)}let Z=U.tagLength;if(Z&&W[1]!==void 0)n(W[1]);let Y=$(J,...W),q=(I,P)=>{if(P!==void 0){if(I!==2)throw new Error("cipher output not supported");n(P)}},V=!1;return{encrypt(I,P){if(V)throw new Error("cannot encrypt() twice with same key + nonce");return V=!0,n(I),q(Y.encrypt.length,P),Y.encrypt(I,P)},decrypt(I,P){if(n(I),Z&&I.length<Z)throw new Error("invalid ciphertext length: smaller than tagLength="+Z);return q(Y.decrypt.length,P),Y.decrypt(I,P)}}}return Object.assign(Q,U),Q};function uU(U,$,Q=!0){if($===void 0)return new Uint8Array(U);if($.length!==U)throw new Error("invalid output length, expected "+U+", got: "+$.length);if(Q&&!X$($))throw new Error("invalid output, must be aligned");return $}function Z0(U,$,Q,J){if(typeof U.setBigUint64==="function")return U.setBigUint64($,Q,J);let W=BigInt(32),Z=BigInt(4294967295),Y=Number(Q>>W&Z),q=Number(Q&Z),V=J?4:0,G=J?0:4;U.setUint32($+V,Y,J),U.setUint32($+G,q,J)}function I0(U,$,Q){RU(Q);let J=new Uint8Array(16),W=q$(J);return Z0(W,0,BigInt($),Q),Z0(W,8,BigInt(U),Q),J}function X$(U){return U.byteOffset%4===0}function vU(U){return Uint8Array.from(U)}var N0=(U)=>Uint8Array.from(U.split("").map(($)=>$.charCodeAt(0))),I$=N0("expand 16-byte k"),P$=N0("expand 32-byte k"),N$=o(I$),w$=o(P$);function X(U,$){return U<<$|U>>>32-$}function dU(U){return U.byteOffset%4===0}var CU=64,K$=16,w0=4294967295,P0=new Uint32Array;function H$(U,$,Q,J,W,Z,Y,q){let V=W.length,G=new Uint8Array(CU),I=o(G),P=dU(W)&&dU(Z),N=P?o(W):P0,H=P?o(Z):P0;for(let K=0;K<V;Y++){if(U($,Q,J,I,Y,q),Y>=w0)throw new Error("arx: counter overflow");let M=Math.min(CU,V-K);if(P&&M===CU){let O=K/4;if(K%4!==0)throw new Error("arx: invalid block position");for(let z=0,T;z<K$;z++)T=O+z,H[T]=N[T]^I[z];K+=CU;continue}for(let O=0,z;O<M;O++)z=K+O,Z[z]=W[z]^G[O];K+=M}}function hU(U,$){let{allowShortKeys:Q,extendNonceFn:J,counterLength:W,counterRight:Z,rounds:Y}=G0({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},$);if(typeof U!=="function")throw new Error("core must be a function");return EU(W),EU(Y),RU(Z),RU(Q),(q,V,G,I,P=0)=>{n(q),n(V),n(G);let N=G.length;if(I===void 0)I=new Uint8Array(N);if(n(I),EU(P),P<0||P>=w0)throw new Error("arx: counter overflow");if(I.length<N)throw new Error(`arx: output (${I.length}) is shorter than data (${N})`);let H=[],K=q.length,M,O;if(K===32)H.push(M=vU(q)),O=w$;else if(K===16&&Q)M=new Uint8Array(32),M.set(q),M.set(q,16),O=N$,H.push(M);else throw new Error(`arx: invalid 32-byte key, got length=${K}`);if(!dU(V))H.push(V=vU(V));let z=o(M);if(J){if(V.length!==24)throw new Error("arx: extended nonce must be 24 bytes");J(O,z,o(V.subarray(0,16)),z),V=V.subarray(16)}let T=16-W;if(T!==V.length)throw new Error(`arx: nonce must be ${T} or 16 bytes`);if(T!==12){let f=new Uint8Array(12);f.set(V,Z?0:12-V.length),V=f,H.push(V)}let m=o(V);return H$(U,O,z,m,G,I,P,Y),s(...H),I}}var g=(U,$)=>U[$++]&255|(U[$++]&255)<<8;class K0{constructor(U){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,U=LU(U),n(U,32);let $=g(U,0),Q=g(U,2),J=g(U,4),W=g(U,6),Z=g(U,8),Y=g(U,10),q=g(U,12),V=g(U,14);this.r[0]=$&8191,this.r[1]=($>>>13|Q<<3)&8191,this.r[2]=(Q>>>10|J<<6)&7939,this.r[3]=(J>>>7|W<<9)&8191,this.r[4]=(W>>>4|Z<<12)&255,this.r[5]=Z>>>1&8190,this.r[6]=(Z>>>14|Y<<2)&8191,this.r[7]=(Y>>>11|q<<5)&8065,this.r[8]=(q>>>8|V<<8)&8191,this.r[9]=V>>>5&127;for(let G=0;G<8;G++)this.pad[G]=g(U,16+2*G)}process(U,$,Q=!1){let J=Q?0:2048,{h:W,r:Z}=this,Y=Z[0],q=Z[1],V=Z[2],G=Z[3],I=Z[4],P=Z[5],N=Z[6],H=Z[7],K=Z[8],M=Z[9],O=g(U,$+0),z=g(U,$+2),T=g(U,$+4),m=g(U,$+6),f=g(U,$+8),e=g(U,$+10),b=g(U,$+12),c=g(U,$+14),A=W[0]+(O&8191),S=W[1]+((O>>>13|z<<3)&8191),F=W[2]+((z>>>10|T<<6)&8191),D=W[3]+((T>>>7|m<<9)&8191),B=W[4]+((m>>>4|f<<12)&8191),R=W[5]+(f>>>1&8191),E=W[6]+((f>>>14|e<<2)&8191),L=W[7]+((e>>>11|b<<5)&8191),v=W[8]+((b>>>8|c<<8)&8191),C=W[9]+(c>>>5|J),w=0,_=w+A*Y+S*(5*M)+F*(5*K)+D*(5*H)+B*(5*N);w=_>>>13,_&=8191,_+=R*(5*P)+E*(5*I)+L*(5*G)+v*(5*V)+C*(5*q),w+=_>>>13,_&=8191;let k=w+A*q+S*Y+F*(5*M)+D*(5*K)+B*(5*H);w=k>>>13,k&=8191,k+=R*(5*N)+E*(5*P)+L*(5*I)+v*(5*G)+C*(5*V),w+=k>>>13,k&=8191;let y=w+A*V+S*q+F*Y+D*(5*M)+B*(5*K);w=y>>>13,y&=8191,y+=R*(5*H)+E*(5*N)+L*(5*P)+v*(5*I)+C*(5*G),w+=y>>>13,y&=8191;let j=w+A*G+S*V+F*q+D*Y+B*(5*M);w=j>>>13,j&=8191,j+=R*(5*K)+E*(5*H)+L*(5*N)+v*(5*P)+C*(5*I),w+=j>>>13,j&=8191;let x=w+A*I+S*G+F*V+D*q+B*Y;w=x>>>13,x&=8191,x+=R*(5*M)+E*(5*K)+L*(5*H)+v*(5*N)+C*(5*P),w+=x>>>13,x&=8191;let ZU=w+A*P+S*I+F*G+D*V+B*q;w=ZU>>>13,ZU&=8191,ZU+=R*Y+E*(5*M)+L*(5*K)+v*(5*H)+C*(5*N),w+=ZU>>>13,ZU&=8191;let qU=w+A*N+S*P+F*I+D*G+B*V;w=qU>>>13,qU&=8191,qU+=R*q+E*Y+L*(5*M)+v*(5*K)+C*(5*H),w+=qU>>>13,qU&=8191;let VU=w+A*H+S*N+F*P+D*I+B*G;w=VU>>>13,VU&=8191,VU+=R*V+E*q+L*Y+v*(5*M)+C*(5*K),w+=VU>>>13,VU&=8191;let GU=w+A*K+S*H+F*N+D*P+B*I;w=GU>>>13,GU&=8191,GU+=R*G+E*V+L*q+v*Y+C*(5*M),w+=GU>>>13,GU&=8191;let XU=w+A*M+S*K+F*H+D*N+B*P;w=XU>>>13,XU&=8191,XU+=R*I+E*G+L*V+v*q+C*Y,w+=XU>>>13,XU&=8191,w=(w<<2)+w|0,w=w+_|0,_=w&8191,w=w>>>13,k+=w,W[0]=_,W[1]=k,W[2]=y,W[3]=j,W[4]=x,W[5]=ZU,W[6]=qU,W[7]=VU,W[8]=GU,W[9]=XU}finalize(){let{h:U,pad:$}=this,Q=new Uint16Array(10),J=U[1]>>>13;U[1]&=8191;for(let Y=2;Y<10;Y++)U[Y]+=J,J=U[Y]>>>13,U[Y]&=8191;U[0]+=J*5,J=U[0]>>>13,U[0]&=8191,U[1]+=J,J=U[1]>>>13,U[1]&=8191,U[2]+=J,Q[0]=U[0]+5,J=Q[0]>>>13,Q[0]&=8191;for(let Y=1;Y<10;Y++)Q[Y]=U[Y]+J,J=Q[Y]>>>13,Q[Y]&=8191;Q[9]-=8192;let W=(J^1)-1;for(let Y=0;Y<10;Y++)Q[Y]&=W;W=~W;for(let Y=0;Y<10;Y++)U[Y]=U[Y]&W|Q[Y];U[0]=(U[0]|U[1]<<13)&65535,U[1]=(U[1]>>>3|U[2]<<10)&65535,U[2]=(U[2]>>>6|U[3]<<7)&65535,U[3]=(U[3]>>>9|U[4]<<4)&65535,U[4]=(U[4]>>>12|U[5]<<1|U[6]<<14)&65535,U[5]=(U[6]>>>2|U[7]<<11)&65535,U[6]=(U[7]>>>5|U[8]<<8)&65535,U[7]=(U[8]>>>8|U[9]<<5)&65535;let Z=U[0]+$[0];U[0]=Z&65535;for(let Y=1;Y<8;Y++)Z=(U[Y]+$[Y]|0)+(Z>>>16)|0,U[Y]=Z&65535;s(Q)}update(U){nU(this),U=LU(U),n(U);let{buffer:$,blockLen:Q}=this,J=U.length;for(let W=0;W<J;){let Z=Math.min(Q-this.pos,J-W);if(Z===Q){for(;Q<=J-W;W+=Q)this.process(U,W);continue}if($.set(U.subarray(W,W+Z),this.pos),this.pos+=Z,W+=Z,this.pos===Q)this.process($,0,!1),this.pos=0}return this}destroy(){s(this.h,this.r,this.buffer,this.pad)}digestInto(U){nU(this),V0(U,this),this.finished=!0;let{buffer:$,h:Q}=this,{pos:J}=this;if(J){$[J++]=1;for(;J<16;J++)$[J]=0;this.process($,0,!0)}this.finalize();let W=0;for(let Z=0;Z<8;Z++)U[W++]=Q[Z]>>>0,U[W++]=Q[Z]>>>8;return U}digest(){let{buffer:U,outputLen:$}=this;this.digestInto(U);let Q=U.slice(0,$);return this.destroy(),Q}}function M$(U){let $=(J,W)=>U(W).update(LU(J)).digest(),Q=U(new Uint8Array(32));return $.outputLen=Q.outputLen,$.blockLen=Q.blockLen,$.create=(J)=>U(J),$}var H0=M$((U)=>new K0(U));function z0(U,$,Q,J,W,Z=20){let Y=U[0],q=U[1],V=U[2],G=U[3],I=$[0],P=$[1],N=$[2],H=$[3],K=$[4],M=$[5],O=$[6],z=$[7],T=W,m=Q[0],f=Q[1],e=Q[2],b=Y,c=q,A=V,S=G,F=I,D=P,B=N,R=H,E=K,L=M,v=O,C=z,w=T,_=m,k=f,y=e;for(let x=0;x<Z;x+=2)b=b+F|0,w=X(w^b,16),E=E+w|0,F=X(F^E,12),b=b+F|0,w=X(w^b,8),E=E+w|0,F=X(F^E,7),c=c+D|0,_=X(_^c,16),L=L+_|0,D=X(D^L,12),c=c+D|0,_=X(_^c,8),L=L+_|0,D=X(D^L,7),A=A+B|0,k=X(k^A,16),v=v+k|0,B=X(B^v,12),A=A+B|0,k=X(k^A,8),v=v+k|0,B=X(B^v,7),S=S+R|0,y=X(y^S,16),C=C+y|0,R=X(R^C,12),S=S+R|0,y=X(y^S,8),C=C+y|0,R=X(R^C,7),b=b+D|0,y=X(y^b,16),v=v+y|0,D=X(D^v,12),b=b+D|0,y=X(y^b,8),v=v+y|0,D=X(D^v,7),c=c+B|0,w=X(w^c,16),C=C+w|0,B=X(B^C,12),c=c+B|0,w=X(w^c,8),C=C+w|0,B=X(B^C,7),A=A+R|0,_=X(_^A,16),E=E+_|0,R=X(R^E,12),A=A+R|0,_=X(_^A,8),E=E+_|0,R=X(R^E,7),S=S+F|0,k=X(k^S,16),L=L+k|0,F=X(F^L,12),S=S+F|0,k=X(k^S,8),L=L+k|0,F=X(F^L,7);let j=0;J[j++]=Y+b|0,J[j++]=q+c|0,J[j++]=V+A|0,J[j++]=G+S|0,J[j++]=I+F|0,J[j++]=P+D|0,J[j++]=N+B|0,J[j++]=H+R|0,J[j++]=K+E|0,J[j++]=M+L|0,J[j++]=O+v|0,J[j++]=z+C|0,J[j++]=T+w|0,J[j++]=m+_|0,J[j++]=f+k|0,J[j++]=e+y|0}function O$(U,$,Q,J){let W=U[0],Z=U[1],Y=U[2],q=U[3],V=$[0],G=$[1],I=$[2],P=$[3],N=$[4],H=$[5],K=$[6],M=$[7],O=Q[0],z=Q[1],T=Q[2],m=Q[3];for(let e=0;e<20;e+=2)W=W+V|0,O=X(O^W,16),N=N+O|0,V=X(V^N,12),W=W+V|0,O=X(O^W,8),N=N+O|0,V=X(V^N,7),Z=Z+G|0,z=X(z^Z,16),H=H+z|0,G=X(G^H,12),Z=Z+G|0,z=X(z^Z,8),H=H+z|0,G=X(G^H,7),Y=Y+I|0,T=X(T^Y,16),K=K+T|0,I=X(I^K,12),Y=Y+I|0,T=X(T^Y,8),K=K+T|0,I=X(I^K,7),q=q+P|0,m=X(m^q,16),M=M+m|0,P=X(P^M,12),q=q+P|0,m=X(m^q,8),M=M+m|0,P=X(P^M,7),W=W+G|0,m=X(m^W,16),K=K+m|0,G=X(G^K,12),W=W+G|0,m=X(m^W,8),K=K+m|0,G=X(G^K,7),Z=Z+I|0,O=X(O^Z,16),M=M+O|0,I=X(I^M,12),Z=Z+I|0,O=X(O^Z,8),M=M+O|0,I=X(I^M,7),Y=Y+P|0,z=X(z^Y,16),N=N+z|0,P=X(P^N,12),Y=Y+P|0,z=X(z^Y,8),N=N+z|0,P=X(P^N,7),q=q+V|0,T=X(T^q,16),H=H+T|0,V=X(V^H,12),q=q+V|0,T=X(T^q,8),H=H+T|0,V=X(V^H,7);let f=0;J[f++]=W,J[f++]=Z,J[f++]=Y,J[f++]=q,J[f++]=O,J[f++]=z,J[f++]=T,J[f++]=m}var z$=hU(z0,{counterRight:!1,counterLength:4,allowShortKeys:!1}),T$=hU(z0,{counterRight:!1,counterLength:8,extendNonceFn:O$,allowShortKeys:!1});var A$=new Uint8Array(16),M0=(U,$)=>{U.update($);let Q=$.length%16;if(Q)U.update(A$.subarray(Q))},S$=new Uint8Array(32);function O0(U,$,Q,J,W){let Z=U($,Q,S$),Y=H0.create(Z);if(W)M0(Y,W);M0(Y,J);let q=I0(J.length,W?W.length:0,!0);Y.update(q);let V=Y.digest();return s(Z,q),V}var T0=(U)=>($,Q,J)=>{return{encrypt(Z,Y){let q=Z.length;Y=uU(q+16,Y,!1),Y.set(Z);let V=Y.subarray(0,-16);U($,Q,V,V,1);let G=O0(U,$,Q,V,J);return Y.set(G,q),s(G),Y},decrypt(Z,Y){Y=uU(Z.length-16,Y,!1);let q=Z.subarray(0,-16),V=Z.subarray(-16),G=O0(U,$,Q,q,J);if(!X0(V,G))throw new Error("invalid tag");return Y.set(Z.subarray(0,-16)),U($,Q,Y,Y,1),s(G),Y}}},GJ=lU({blockSize:64,nonceLength:12,tagLength:16},T0(z$)),pU=lU({blockSize:64,nonceLength:24,tagLength:16},T0(T$));class QU{p;static IV_LENGTH=24;IV_LENGTH=QU.IV_LENGTH;key;constructor(U){this.p=U}async setKey(U){this.key=new Uint8Array(await this.p.subtle.exportKey("raw",U))}async encryptChunk(U){let $=this.p.getRandomValues(new Uint8Array(QU.IV_LENGTH)),J=pU(this.key,$).encrypt(U);U.fill(0);let W=new Uint8Array($.length+J.length);return W.set($,0),W.set(J,$.length),W}async decryptChunk(U){let $=U.slice(0,QU.IV_LENGTH),Q=U.slice(QU.IV_LENGTH),J=pU(this.key,$);try{return J.decrypt(Q)}catch{throw new u("Decryption failed: wrong passphrase or corrupted ciphertext")}}zeroKey(){this.key.fill(0)}}var kU=Y0(require("argon2-browser"));async function x0(U,$,Q,J){if(J==="node"){let W=await Promise.resolve().then(() => Y0(p0())),Z=typeof U==="string"?Buffer.from(U,"utf8"):Buffer.from(U),Y=Buffer.from($),q=await W.hash(Z,{salt:Y,timeCost:Q.time,memoryCost:Q.mem,parallelism:Q.parallelism,hashLength:32,raw:!0,type:W.argon2id});return Y.fill(0),Z.fill(0),{hash:new Uint8Array(q)}}if(J==="browser"){if(!("loadArgon2WasmBinary"in globalThis))globalThis.loadArgon2WasmBinary=()=>fetch("argon2.wasm").then((W)=>{if(!W.ok)throw new Error("Failed to load argon2.wasm");return W.arrayBuffer()}).then((W)=>new Uint8Array(W));return kU.hash({pass:U,salt:$,time:Q.time,mem:Q.mem,parallelism:Q.parallelism,hashLen:32,type:kU.ArgonType.Argon2id}).then((W)=>{if(!W||!W.hash)throw new r("Failed to produce key derivation");return{hash:W.hash}}).catch((W)=>{let Z=W instanceof Error?W.message:typeof W==="string"?W:"Unknown error";throw new r(`argon2-browser failure: ${Z}`)})}throw new Error(`Unsupported environment: ${J}`)}class yU{presets;exportExtractable;name="argon2id";constructor(U,$=!1){this.presets=U;this.exportExtractable=$}async derive(U,$,Q,J){let{hash:W}=await x0(U,$,this.presets[Q],J.isNode?"node":"browser");if(this.exportExtractable)return J.subtle.importKey("raw",W,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]);else return J.subtle.importKey("raw",W,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}}var i0={low:{time:5,mem:65536,parallelism:1},middle:{time:20,mem:65536,parallelism:1},high:{time:40,mem:65536,parallelism:1}},h$={id:0,cipher:JU,kdf:new yU(i0),saltLengths:{low:12,high:16},difficulties:i0,defaultChunkSize:524288};l.register(h$);var r0={low:{time:5,mem:65536,parallelism:2},middle:{time:10,mem:98304,parallelism:4},high:{time:20,mem:98304,parallelism:4}},p$={id:1,cipher:QU,kdf:new yU(r0,!0),saltLengths:{low:12,high:16},difficulties:r0,defaultChunkSize:524288};l.register(p$);var fU=1;function o0(){return typeof process!=="undefined"&&typeof process.versions==="object"&&!0}function OU(...U){let $=U.reduce((W,Z)=>W+Z.byteLength,0),Q=new Uint8Array($),J=0;for(let W of U)Q.set(W,J),J+=W.byteLength;return Q}function zU(...U){try{let $=OU(...U);if(o0())return Buffer.from($).toString("base64");let Q="";for(let J=0;J<$.length;J++)Q+=String.fromCharCode($[J]);return btoa(Q)}catch{throw new cU("Base64 Encoding Error")}}function TU(U){try{if(!/^[A-Za-z0-9+/]+={0,2}$/.test(U)||U.length%4!==0)throw new Error("Invalid Base64");if(o0())return new Uint8Array(Buffer.from(U,"base64"));let $=atob(U),Q=new Uint8Array($.length);for(let J=0;J<$.length;J++)Q[J]=$.charCodeAt(J);return Q}catch{throw new KU(`Invalid Base64: length=${U.length}, content='${U.slice(0,12)}…'`)}}function d(U){let $=U.value.length,Q=new Array($).fill("\x00").join("");U.value=Q}function AU(U,$,Q,J){let W={low:0,middle:1,high:2};if(!($ in W))throw new TypeError(`Unsupported difficulty: ${$}`);let Z=W[$],Y=U<<5|(Q==="high"?1:0)<<2|Z;return OU(new Uint8Array([fU,Y]),J)}function YU(U){if(U[0]!==fU)throw new h("Invalid input format. The input is unknown.");if(U.length<14)throw new h("Invalid input format. Header too short.");try{let $=U[1],Q=$>>5,J=$>>2&1?"high":"low",W=$&3,Z=["low","middle","high"][W],Y=l.get(Q).saltLengths[J],q=U.slice(2,2+Y);return{scheme:Q,difficulty:Z,saltStrength:J,salt:q,headerLen:2+Y}}catch($){throw new IU($ instanceof Error?$.message:String($))}}async function gU(U){if(U instanceof Uint8Array)return U;if(U instanceof ArrayBuffer)return new Uint8Array(U);return new Uint8Array(await U.arrayBuffer())}function U0(U){let $=new Uint8Array(4);return new DataView($.buffer).setUint32(0,U,!1),$}function s0(U,$=0){if(U.length-$<4)throw new RangeError("Not enough bytes for frame header");return new DataView(U.buffer,U.byteOffset+$,4).getUint32(0,!1)}var t=4;class SU{engine;chunkSize;buffer=new Uint8Array(0);constructor(U,$=524288){this.engine=U;this.chunkSize=$}toTransformStream(){return new TransformStream({transform:async(U,$)=>{await this.transform(await gU(U),$)},flush:async(U)=>this.flush(U)})}async transform(U,$){if(U.length>this.chunkSize*4)throw new RangeError(`Input block (${U.length} B) exceeds sane limit`);let Q=new Uint8Array(this.buffer.length+U.length);Q.set(this.buffer),Q.set(U,this.buffer.length);let J=0;while(Q.length-J>=this.chunkSize){let W=Q.slice(J,J+this.chunkSize);J+=this.chunkSize;let Z=await this.engine.encryptChunk(W),Y=new Uint8Array(t+Z.length);Y.set(U0(Z.length)),Y.set(Z,t),$.enqueue(Y)}this.buffer=Q.slice(J)}async flush(U){if(!this.buffer.length)return;let $=await this.engine.encryptChunk(this.buffer),Q=new Uint8Array(t+$.length);Q.set(U0($.length)),Q.set($,t),U.enqueue(Q),this.buffer=new Uint8Array(0),this.engine.zeroKey()}}class PU{engine;chunkSize;buffer=new Uint8Array(0);constructor(U,$=524288){this.engine=U;this.chunkSize=$}toTransformStream(){return new TransformStream({transform:async(U,$)=>{await this.transform(await gU(U),$)},flush:async(U)=>this.flush(U)})}async transform(U,$){let Q=new Uint8Array(this.buffer.length+U.length);Q.set(this.buffer),Q.set(U,this.buffer.length);let J=0;while(!0){if(Q.length-J<t)break;let W=s0(Q,J);if(W>this.chunkSize*2)throw new u(`Frame length ${W} exceeds …`);if(Q.length-J-t<W)break;J+=t;let Z=Q.slice(J,J+W);J+=W;try{let Y=await this.engine.decryptChunk(Z);$.enqueue(Y)}catch(Y){throw Y instanceof u?Y:new u("Decryption failed: Wrong passphrase or corrupted ciphertext")}}this.buffer=Q.slice(J)}async flush(U){await this.transform(new Uint8Array(0),U),this.buffer=new Uint8Array(0),this.engine.zeroKey()}}async function a0(U,$){let Q=U.getReader(),J=$&&$.length?[$]:[];try{while(!0){let{value:q,done:V}=await Q.read();if(V)break;J.push(q)}}finally{Q.releaseLock()}let W=J.reduce((q,V)=>q+V.byteLength,0),Z=new Uint8Array(W),Y=0;for(let q of J)Z.set(q,Y),Y+=q.byteLength;return Z}class NU{engine;chunkSize;constructor(U,$=524288){this.engine=U;this.chunkSize=$}encryptionStream(){let U=new SU(this.engine,this.chunkSize).toTransformStream();return{writable:U.writable,readable:U.readable}}decryptionStream(U){let $=U,Q=new TransformStream({transform(W,Z){if($===0){Z.enqueue(W);return}if(W.byteLength<=$){$-=W.byteLength;return}Z.enqueue(W.slice($)),$=0}}),J=new PU(this.engine,this.chunkSize).toTransformStream();return{writable:Q.writable,readable:Q.readable.pipeThrough(J)}}async collect(U,$,Q=null){return a0(U.pipeThrough($),Q??void 0)}}function t0(U=0,$=console.info){return{level:U,log(Q,J){if(Q<=U)$(`${Q}| ${J}`)}}}function e0(U,$,Q){if($<0||Q<0||$+Q>U)throw new RangeError("read() slice exceeds data bounds")}class $0{src;#U=null;constructor(U){this.src=U}get length(){if(this.src instanceof Uint8Array)return this.src.byteLength;if(this.src instanceof Blob)return this.src.size;return this.ensureUint8().byteLength}async read(U,$){if(e0(this.length,U,$),this.src instanceof Uint8Array)return this.src.slice(U,U+$);if(this.src instanceof Blob){let Q=await this.src.slice(U,U+$).arrayBuffer();return new Uint8Array(Q)}return this.ensureUint8().slice(U,U+$)}ensureUint8(){if(!this.#U)this.#U=TU(this.src);return this.#U}}var U$=new WeakMap;class UU{static getEngine(U,$){let Q=U$.get(U);if(!Q)Q=new Map,U$.set(U,Q);let J=Q.get($);if(J)return J;let W=l.get($);return J={desc:W,cipher:new W.cipher(U),kdf:W.kdf,chunkSize:W.defaultChunkSize,provider:U},Q.set($,J),J}static async deriveKey(U,$,Q,J){try{let W=await U.kdf.derive($.value,Q,J,U.provider);await U.cipher.setKey(W)}catch(W){let Z=W instanceof Error?W.message:String(W);throw new r(Z)}finally{d($)}}}class $U{provider;v;cipher;kdf;chunkSize;stream;difficulty;saltStrength;engines=new Map;log;constructor(U,$={}){this.provider=U;this.v=l.get($.scheme??l.current.id),this.cipher=new this.v.cipher(U),this.kdf=this.v.kdf,this.chunkSize=this.setChunkSize($.chunkSize??this.v.defaultChunkSize),this.stream=new NU(this.cipher,this.chunkSize),this.difficulty=$.difficulty??"middle",this.saltStrength=$.saltStrength??"high",this.log=t0($.verbose??0,$.logger)}static async isEncrypted(U){try{return await $U.peekHeader(U),!0}catch{return!1}}static async headerDecode(U){let $=await $U.peekHeader(U),Q=YU($);return{scheme:Q.scheme,difficulty:Q.difficulty,salt:zU(Q.salt),saltLength:Q.salt.byteLength}}static async decodeData(U){let $=typeof U?.read==="function"?U:new $0(U),Q=await $.read(0,Math.min(256,$.length)),J=await $U.peekHeader(Q),{scheme:W,headerLen:Z}=YU(J),Y=$.length,q=Y-Z;if(q<=0)throw new h("Payload is empty");let V=await $.read(Z,4),G=new DataView(V.buffer,V.byteOffset,4).getUint32(0,!1);if(G+4<=q&&G>=28){let H=G,K=Z,M=0,O=0;while(K+4<=Y){let z=await $.read(K,4),T=new DataView(z.buffer,z.byteOffset,4).getUint32(0,!1);if(T===0||K+4+T>Y)break;M++,O+=T,K+=4+T}return{isChunked:!0,chunks:{chunkSize:H,count:M,totalPayload:O}}}let P=await $.read(Z,q),N=l.get(W).cipher.IV_LENGTH;if(P.length<N+16)throw new h("Ciphertext too short for IV & tag");return{isChunked:!1,payloadLength:q,params:{iv:P.slice(0,N),tag:P.slice(P.length-16)}}}setDifficulty(U){this.difficulty=U}getDifficulty(){return this.difficulty}setScheme(U){this.v=l.get(U),this.cipher=new this.v.cipher(this.provider),this.kdf=this.v.kdf,this.stream=new NU(this.cipher,this.chunkSize)}getScheme(){return this.v.id}setSaltDifficulty(U){this.saltStrength=U}getSaltDifficulty(){return this.saltStrength}setChunkSize(U){let $=U,Q;if($==null)Q=this.v.defaultChunkSize;else if(Q=Number($),!Number.isInteger(Q)||Q<1)throw new Error(`Invalid chunkSize: ${$}. Must be a positive integer.`);return this.chunkSize=Q,this.stream=new NU(this.cipher,this.chunkSize),Q}getChunkSize(){return this.chunkSize}setVerbose(U){this.log.level=U}getVerbose(){return this.log.level}async encryptText(U,$){let Q={value:$};try{this.log.log(1,`Start text encryption, scheme: ${this.getScheme()}`),this.log.log(2,"Deriving key for text encryption");let J=this.genSalt();await this.deriveKey(Q,J),d(Q),$=null,this.log.log(3,`Salt generated: ${zU(J)}, KDF difficulty: ${this.difficulty}`),this.log.log(2,"Encrypting text data");let W=await this.cipher.encryptChunk(typeof U==="string"?new TextEncoder().encode(U):U);this.cipher.zeroKey(),this.log.log(3,"Encoding header");let Z=AU(this.v.id,this.difficulty,this.saltStrength,J);this.log.log(3,"Encoding text");let Y=zU(Z,W);return this.log.log(1,"Decryption finished"),Y}catch(J){throw new BU(J instanceof Error?J.message:String(J))}}async decryptText(U,$){let Q={value:$};try{this.log.log(1,`Start text decryption, Version ${this.getScheme()}`),this.log.log(3,"Start text decoding");let J=TU(U);this.log.log(3,"Start header decoding"),await $U.peekHeader(U);let W=YU(J);this.log.log(3,"Trying to get engine");let Z=UU.getEngine(this.provider,W.scheme);this.log.log(2,`Deriving key via engine for scheme: ${W.scheme}`),this.log.log(3,`Salt use: ${zU(W.salt)}, KDF difficulty: ${W.difficulty}`);try{await UU.deriveKey(Z,Q,W.salt,W.difficulty)}finally{d(Q),$=null}this.log.log(2,"Decrypting text data");let Y=await Z.cipher.decryptChunk(J.slice(W.headerLen));Z.cipher.zeroKey(),this.log.log(3,"Decoding text");let q=new TextDecoder().decode(Y);return this.log.log(1,"Decryption finished"),q}catch(J){if(J instanceof u||J instanceof h||J instanceof IU||J instanceof KU||J instanceof r)throw J;throw new u("Decryption failed: wrong passphrase or corrupted ciphertext")}}async encryptFile(U,$){let Q={value:$};try{if(U.size===0){let Y=this.genSalt();await this.deriveKey(Q,Y),d(Q),$=null;let q=AU(this.v.id,this.difficulty,this.saltStrength,Y);return new Blob([q],{type:"application/octet-stream"})}this.log.log(2,"Deriving key for file encryption");let J=this.genSalt();await this.deriveKey(Q,J),d(Q),$=null;let W=AU(this.v.id,this.difficulty,this.saltStrength,J),Z=await this.stream.collect(U.stream(),new SU(this.cipher,this.chunkSize).toTransformStream(),W);return new Blob([Z],{type:"application/octet-stream"})}catch(J){throw new BU(J instanceof Error?J.message:String(J))}}async decryptFile(U,$){let Q={value:$};try{let J=await $U.peekHeader(U),W=YU(J),Z=UU.getEngine(this.provider,W.scheme);try{await UU.deriveKey(Z,Q,W.salt,W.difficulty)}finally{d(Q),$=null}if(U.size===W.headerLen)return new Blob([],{type:"application/octet-stream"});this.log.log(2,"Decrypting file data");let q=await new NU(Z.cipher,Z.chunkSize).collect(U.slice(W.headerLen).stream(),new PU(Z.cipher,Z.chunkSize).toTransformStream());return new Blob([q],{type:"application/octet-stream"})}catch(J){if(J instanceof u)throw J;throw new u(J instanceof Error?J.message:String(J))}}async createEncryptionStream(U){let $={value:U};this.log.log(2,"Deriving key for stream encryption");let Q=this.genSalt();await this.deriveKey($,Q),d($),U=null;let J=AU(this.v.id,this.difficulty,this.saltStrength,Q),W=this.stream.encryptionStream();return{header:J,writable:W.writable,readable:W.readable}}async createDecryptionStream(U){let $={value:U},Q=this,J=new Uint8Array(0),W=null;async function Z(Y,q){let V=Y.getReader();while(!0){let{value:G,done:I}=await V.read();if(I)break;q.enqueue(G)}}return new TransformStream({async transform(Y,q){if(!W){if(J=OU(J,Y),J.length<2)return;let G=J.slice(0,30),{salt:I,difficulty:P}=YU(G),N=J[1]>>5,H=J[1]>>2&1?"high":"low",M=2+l.get(N).saltLengths[H];if(J.length<M)return;let O=UU.getEngine(Q.provider,N);try{await UU.deriveKey(O,$,I,P)}finally{d($),U=null}W=new PU(O.cipher,O.chunkSize).toTransformStream(),Z(W.readable,q).catch((T)=>{q.error(T)});let z=J.slice(M);if(z.length){let T=W.writable.getWriter();await T.write(z),T.releaseLock()}return}let V=W.writable.getWriter();await V.write(Y),V.releaseLock()},async flush(){if(W){let Y=W.writable.getWriter();await Y.close(),Y.releaseLock()}}})}async deriveKey(U,$,Q=this.difficulty){let J=performance.now();try{let W=await this.kdf.derive(U.value,$,Q,this.provider);d(U),await this.cipher.setKey(W),this.log.log(3,`Key derivation completed in ${(performance.now()-J).toFixed(1)} ms`)}catch(W){throw new r(W instanceof Error?W.message:String(W))}}genSalt(U=this.saltStrength){let $=this.v.saltLengths[this.saltStrength];return this.provider.getRandomValues(new Uint8Array($))}static async peekHeader(U){let $=await this.readAsUint8(U);if($ instanceof Uint8Array){if($.length<2)throw new h("Input too short");let{headerLen:Q}=YU($.length>=16?$:Uint8Array.from($));if($.length<Q)throw new h("Incomplete header");return $.slice(0,Q)}throw new IU("Unsupported input type")}static async readAsUint8(U){if(typeof U==="string")return TU(U);if(U instanceof Blob){let $=U.slice(0,64);return new Uint8Array(await $.arrayBuffer())}return U}}var bU=require("node:crypto"),$$={subtle:bU.webcrypto.subtle,getRandomValues(U){return bU.randomFillSync(U),U},isNode:!0};function x$(U){return new $U($$,U)}

//# debugId=D3B5987F7904F9CC64756E2164756E21
