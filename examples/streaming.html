<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Cryptit Browser Demo — File Encryption (Streaming)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="./favicon.ico" type="image/x-icon">

  <!-- Bootstrap 5 CSS -->
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
    rel="stylesheet"
  >



<script src="https://cdn.jsdelivr.net/npm/web-streams-polyfill@2.0.2/dist/ponyfill.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/streamsaver@2.0.3/StreamSaver.min.js"></script>
<script>
  import streamSaver from 'streamsaver'
  const streamSaver = require('streamsaver')
  const streamSaver = window.streamSaver
</script>

  <script>
    // Required by cryptit to load the Argon2 wasm
    window.loadArgon2WasmBinary = () =>
      fetch("./assets/argon2.wasm")
        .then(r => r.arrayBuffer())
        .then(buf => new Uint8Array(buf));
  </script>

  <style>
    .dropzone {
      border: 2px dashed #ced4da;
      border-radius: .5rem;
      padding: 2rem;
      text-align: center;
      transition: background-color .15s ease-in-out, border-color .15s ease-in-out;
    }
    .dropzone.dragover {
      background-color: #f8f9fa;
      border-color: #86b7fe;
    }
    .file-list { max-height: 12rem; overflow: auto; }
    code.kv { font-size: .875rem; }
    .log-textarea { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" crossorigin="anonymous"></script>
  <!-- Optional streaming download polyfill (uncomment to avoid in-memory blobs on non-Chromium browsers)
  <script src="https://unpkg.com/streamsaver@2.0.6/StreamSaver.min.js"></script>
  -->
</head>
<body>
  <nav class="navbar navbar-expand-lg navbar-light bg-light mb-4">
    <div class="container-fluid">
      <a class="navbar-brand" href="#">Cryptit Demo</a>
      <button
        class="navbar-toggler"
        type="button"
        data-bs-toggle="collapse"
        data-bs-target="#demoNav"
        aria-controls="demoNav"
        aria-expanded="false"
        aria-label="Toggle navigation"
      >
        <span class="navbar-toggler-icon"></span>
      </button>

      <div class="collapse navbar-collapse" id="demoNav">
        <ul class="navbar-nav me-auto mb-2 mb-lg-0">
          <li class="nav-item">
            <a class="nav-link" href="text-encryption.html">Text</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="text-decoding.html">Text Decoding</a>
          </li>
        <li class="nav-item">
            <a class="nav-link" href="file-encryption.html">File</a>
          </li>
          <li class="nav-item">
            <a class="nav-link active" aria-current="page" href="streaming.html">File (Streaming)</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="file-decoding.html">File Decoding</a>
          </li>
        </ul>
      </div>
    </div>
  </nav>

  <div class="container">
    <h1 class="mb-1">@mqyxm/cryptit</h1>
    <h2 class="mb-4">File Encryption / Decryption — Streaming</h2>
    <p>Via <a href="https://github.com/jimmywarting/StreamSaver.js">StreamSaver.js</a> or experimental <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/showSaveFilePicker">showSaveFilePicker()</a></p>

    <!-- Configuration -->
    <div class="card mb-4">
      <div class="card-header">Configuration</div>
      <div class="card-body">
        <form id="configForm" class="row g-3">
          <div class="col-md-4">
            <label for="secret" class="form-label">Passphrase</label>
            <input type="password" value="abc" class="form-control" id="secret" placeholder="Enter passphrase">
          </div>
          <div class="col-md-4">
            <label for="scheme" class="form-label">Scheme ID (0 - max. 7)</label>
            <input type="number" min="0" value="0" class="form-control" id="scheme">
            <div class="form-text">0 = AES-GCM / Argon2id (single thread)</div>
            <div class="form-text">1 = XChaCha20-Poly1305 / Argon2id (multithread*)</div>
            <small class="form-text">* not supported in browsers. </small>
          </div>
          <div class="col-md-4">
            <label for="difficulty" class="form-label">Argon2 Difficulty</label>
            <select id="difficulty" class="form-select">
              <option value="low">low</option>
              <option value="middle" selected>middle</option>
              <option value="high">high</option>
            </select>
          </div>
          <div class="col-md-4">
            <label for="saltStrength" class="form-label">Salt Strength</label>
            <select id="saltStrength" class="form-select">
              <option value="low">low</option>
              <option value="high" selected>high</option>
            </select>
          </div>
          <div class="col-md-4">
            <label for="verbose" class="form-label">Verbose Level</label>
            <input type="number" min="0" max="4" value="0" class="form-control" id="verbose">
            <div class="form-text">0 = errors only, 4 = maximum detail</div>
          </div>
        </form>
      </div>
    </div>

    <!-- File picker / drop area -->
    <div class="row g-3 mb-3">
      <div class="col-md-6">
        <label for="fileInput" class="form-label">Choose files</label>
        <input id="fileInput" class="form-control" type="file" multiple>
        <div class="form-text">You can select one or more files.</div>
      </div>
      <div class="col-md-6">
        <label class="form-label">Or drag & drop</label>
        <div id="dropZone" class="dropzone">Drop files here</div>
      </div>
    </div>

    <!-- Action buttons & error -->
    <div class="mb-3 d-flex align-items-center gap-2">
      <button id="encryptBtn" class="btn btn-primary">Encrypt</button>
      <button id="decryptBtn" class="btn btn-secondary">Decrypt</button>
      <button id="clearBtn" class="btn btn-outline-danger ms-auto">Clear results</button>
    </div>
    <div id="errorMsg" class="alert alert-danger d-none"></div>

    <!-- Results -->
    <div class="card">
      <div class="card-header">Results</div>
      <div class="card-body">
        <div class="table-responsive">
          <table class="table align-middle mb-0">
            <thead>
              <tr>
                <th scope="col">File</th>
                <th scope="col">Operation</th>
                <th scope="col">Size</th>
                <th scope="col">Download</th>
                <th scope="col" style="width: 30%">Notes</th>
              </tr>
            </thead>
            <tbody id="resultsBody">
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <p class="text-muted mt-3 mb-0">
      <strong>Notes:</strong> Encrypted files include a self-describing header (scheme, params, salt, etc.).
      Decryption uses this embedded header automatically. You only need the passphrase.
    </p>
  </div>

  <script type="module">
    import { createCryptit } from "./assets/cryptit.browser.min.js";
    window.createCryptit = createCryptit;
  </script>

  <!-- Inline demo logic -->
<script type="module">
  const { createCryptit } = window;

  // ===== Shortcuts & UI Elements =====
  const $ = (id) => document.getElementById(id);
  const els = {
    secret: $('secret'),
    scheme: $('scheme'),
    difficulty: $('difficulty'),
    saltStrength: $('saltStrength'),
    verbose: $('verbose'),
    fileInput: $('fileInput'),
    dropZone: $('dropZone'),
    resultsBody: $('resultsBody'),
    error: $('errorMsg'),
    encryptBtn: $('encryptBtn'),
    decryptBtn: $('decryptBtn'),
    clearBtn: $('clearBtn'),
  };

  // ===== Error UI =====
  function showError(msg) {
    els.error.textContent = `error: ${msg || 'Something went wrong.'}`;
    els.error.classList.remove('d-none');
  }
  function clearError() {
    els.error.textContent = '';
    els.error.classList.add('d-none');
  }

  // ===== Config / cryptit factory =====
  function cryptit() {
    return createCryptit({
      scheme: Number(els.scheme.value),
      difficulty: els.difficulty.value,
      saltStrength: els.saltStrength.value,
      verbose: Number(els.verbose.value),
    });
  }

  // ===== Helpers =====
  const sleep = (ms) => new Promise((r) => setTimeout(r, ms));
  let rowIdCounter = 0;

  async function setBusy(btn, busy) {
    const other = btn === els.encryptBtn ? els.decryptBtn : els.encryptBtn;
    if (busy) {
      if (!btn.dataset.original) btn.dataset.original = btn.textContent.trim();
      btn.textContent = '...';
      btn.disabled = true;
      other.disabled = true;
      els.clearBtn.disabled = true;
      await sleep(150);
    } else {
      btn.textContent = btn.dataset.original || btn.textContent;
      btn.disabled = false;
      other.disabled = false;
      els.clearBtn.disabled = false;
    }
  }

  function formatBytes(bytes) {
    if (!Number.isFinite(bytes)) return '-';
    const units = ['B','KB','MB','GB','TB'];
    const i = bytes === 0 ? 0 : Math.floor(Math.log(bytes) / Math.log(1024));
    const v = (bytes / Math.pow(1024, i));
    return `${v >= 100 ? v.toFixed(0) : v.toFixed(1)} ${units[i]}`;
  }

  function suggestEncName(name = 'file') {
    return `${name}.cryptit`;
  }
  function suggestDecName(name = 'file') {
    if (name.toLowerCase().endsWith('.cryptit')) return name.slice(0, -8);
    if (name.toLowerCase().endsWith('.enc')) return name.slice(0, -4);
    return `${name}.decrypted`;
  }

  function timestamp() {
    return new Date().toLocaleTimeString();
  }

  // ===== Progress reporter =====
  function makeProgressReporter({ total = 0, interval = 500, onTick, onFinal } = {}) {
    let transferred = 0;
    let lastShown = -1;
    let timer = null;

    const emit = (final=false) => {
      if (!final && transferred === lastShown) return;
      lastShown = transferred;
      const pct = total ? (transferred / total) * 100 : 0;
      onTick?.({ transferred, total, pct });
    };

    return {
      start() { if (!timer) { timer = setInterval(() => emit(false), interval); } },
      add(n) { transferred += n; },
      stop(finalMsg = '') {
        if (timer) { clearInterval(timer); timer = null; }
        emit(true);
        onFinal?.({ transferred, total, msg: finalMsg });
      }
    };
  }

  // ===== Streaming sink (REQUIRED) =====
  function supportsStreamSaver() {
    return !!(window.streamSaver && window.streamSaver.createWriteStream);
  }

  function streamingSinkAvailable() {
    return ('showSaveFilePicker' in window) || supportsStreamSaver();
  }

  async function createStreamingWritable(filename, mime = 'application/octet-stream') {
    // Prefer File System Access API
    if ('showSaveFilePicker' in window) {
      const handle = await window.showSaveFilePicker({
        suggestedName: filename,
        types: [{ description: 'Binary', accept: { [mime]: ['.cryptit', '.*'] } }]
      });
      return await handle.createWritable(); // FileSystemWritableFileStream (WritableStream)
    }
    // Fallback to StreamSaver
    if (supportsStreamSaver()) {
      // Optional: configure StreamSaver mitm path if applicable
      // window.streamSaver.mitm = '/streamsaver/mitm.html';
      return window.streamSaver.createWriteStream(filename);
    }
    throw new Error('No streaming sink available in this browser.');
  }

  // ===== Rows with collapsible per-file log =====
  function makeRowWithLog({ fileName, opInitial, sizeInitial, noteInitial }) {
    const id = ++rowIdCounter;
    const logId = `log-${id}`;

    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td class="file-cell"><span class="text-break">${fileName}</span></td>
      <td class="op-cell">${opInitial || '-'}</td>
      <td class="size-cell">${Number.isFinite(sizeInitial) ? formatBytes(sizeInitial) : '-'}</td>
      <td class="dl-cell">
        <button class="btn btn-sm btn-outline-secondary" data-bs-toggle="collapse" data-bs-target="#${logId}" aria-expanded="false">Log</button>
      </td>
      <td class="notes-cell"><small class="text-muted">${noteInitial || ''}</small></td>
    `;
    const logRow = document.createElement('tr');
    logRow.className = 'collapse';
    logRow.id = logId;
    logRow.innerHTML = `
      <td colspan="5">
        <textarea class="form-control log-textarea" rows="6" readonly></textarea>
      </td>
    `;
    els.resultsBody.prepend(logRow);
    els.resultsBody.prepend(tr);

    const logEl = logRow.querySelector('textarea');

    function appendLog(line) {
      logEl.value += `[${timestamp()}] ${line}\n`;
      logEl.scrollTop = logEl.scrollHeight;
    }
    function setOp(text) { tr.querySelector('.op-cell').textContent = text; }
    function setSize(n) { tr.querySelector('.size-cell').textContent = Number.isFinite(n) ? formatBytes(n) : '-'; }
    function setNote(html) { tr.querySelector('.notes-cell').innerHTML = `<small class="text-muted">${html}</small>`; }
    function setDownloadContent(elOrHtml) {
      const td = tr.querySelector('.dl-cell');
      if (typeof elOrHtml === 'string') td.innerHTML = elOrHtml;
      else { td.innerHTML = ''; td.appendChild(elOrHtml); }
      const logBtn = document.createElement('button');
      logBtn.className = 'btn btn-sm btn-outline-secondary ms-2';
      logBtn.textContent = 'Log';
      logBtn.setAttribute('data-bs-toggle','collapse');
      logBtn.setAttribute('data-bs-target',`#${logId}`);
      td.appendChild(logBtn);
    }

    return { appendLog, setOp, setSize, setNote, setDownloadContent };
  }

  // ===== Chunker =====
  function chunker(max = 65536, onBytes) {
    return new TransformStream({
      transform(chunk, ctl) {
        chunk = chunk instanceof Uint8Array ? chunk : new Uint8Array(chunk);
        for (let i = 0; i < chunk.byteLength; i += max) {
          const sub = chunk.subarray(i, i + max);
          onBytes?.(sub.byteLength);
          ctl.enqueue(sub);
        }
      }
    });
  }

  // ===== Encrypt one file (STREAMING SINK REQUIRED) =====
  async function encryptOneFile(file, pass) {
    const row = makeRowWithLog({
      fileName: file.name,
      opInitial: 'Encrypting…',
      sizeInitial: NaN,
      noteInitial: 'starting',
    });
    row.appendLog(`Begin encryption of ${file.name} (${formatBytes(file.size)})`);

    if (!streamingSinkAvailable()) {
      row.setOp('Blocked');
      row.setNote('No streaming file sink available. Use Chrome/Edge (File System Access) or include StreamSaver.');
      row.appendLog('Aborting to avoid in-memory buffering of large files.');
      return;
    }

    const c = cryptit();
    const { header, writable, readable } = await c.createEncryptionStream(pass);

    const suggested = suggestEncName(file.name || 'file');
    let outStream;
    try {
      outStream = await createStreamingWritable(suggested);
    } catch (e) {
      row.setOp('Blocked');
      row.setNote('User canceled save or streaming sink unavailable.');
      row.appendLog(e?.message ?? String(e));
      return;
    }

    // UI
    row.setDownloadContent('<span class="badge text-bg-secondary">Saving to disk…</span>');

    const prog = makeProgressReporter({
      total: file.size,
      interval: 500,
      onTick: ({ transferred, total, pct }) => {
        const p = total ? `${pct.toFixed(1)}%` : '';
        row.setNote(`encrypted ${formatBytes(transferred)} ${total ? `/ ${formatBytes(total)} (${p})` : ''}`);
      },
      onFinal: ({ transferred }) => {
        row.appendLog(`Encrypted ${formatBytes(transferred)} of plaintext`);
      }
    });
    prog.start();

    // OUTPUT: write header, then stream encrypted body to the same sink
    // Use writer if available (generic WritableStream), else .write (FS Access also supports it).
    const writer = outStream.getWriter?.();
    if (writer && writer.write) {
      await writer.write(header);
      writer.releaseLock(); // unlock before pipeTo
    } else if (typeof outStream.write === 'function') {
      await outStream.write(header);
    }

    const pumpOut = readable.pipeTo(outStream).then(async () => {
      if (typeof outStream.close === 'function') await outStream.close();
      row.setDownloadContent('<span class="badge text-bg-success">Saved to disk</span>');
    });

    // INPUT: plaintext → cryptit's writable (with progress)
    const pumpIn = file.stream().pipeThrough(chunker(65536, n => prog.add(n))).pipeTo(writable);

    await Promise.all([pumpIn, pumpOut]);
    prog.stop('complete');
    row.setOp('Encrypted');
    row.setNote('Header embedded; MIME: application/octet-stream');
    row.appendLog('Encryption complete');
  }

  // ===== Decrypt one file (STREAMING SINK REQUIRED) =====
  async function decryptOneFile(file, pass) {
    const row = makeRowWithLog({
      fileName: file.name,
      opInitial: 'Decrypting…',
      sizeInitial: NaN,
      noteInitial: 'starting',
    });
    row.appendLog(`Begin decryption of ${file.name} (${formatBytes(file.size)})`);

    if (!streamingSinkAvailable()) {
      row.setOp('Blocked');
      row.setNote('No streaming file sink available. Use Chrome/Edge (File System Access) or include StreamSaver.');
      row.appendLog('Aborting to avoid in-memory buffering of large files.');
      return;
    }

    const c = cryptit();
    const dec = await c.createDecryptionStream(pass); // Use once per file

    const outName = suggestDecName(file.name || 'file');
    let outStream;
    try {
      outStream = await createStreamingWritable(outName);
    } catch (e) {
      row.setOp('Blocked');
      row.setNote('User canceled save or streaming sink unavailable.');
      row.appendLog(e?.message ?? String(e));
      return;
    }

    row.setDownloadContent('<span class="badge text-bg-secondary">Saving to disk…</span>');

    const prog = makeProgressReporter({
      total: file.size, // ciphertext progress baseline
      interval: 500,
      onTick: ({ transferred, total, pct }) => {
        const p = total ? `${pct.toFixed(1)}%` : '';
        row.setNote(`processed ${formatBytes(transferred)} ${total ? `/ ${formatBytes(total)} (${p})` : ''}`);
      },
      onFinal: ({ transferred }) => {
        row.appendLog(`Read ${formatBytes(transferred)} of ciphertext`);
      }
    });
    prog.start();

    // One pipeline: ciphertext → count → decrypt → sink
    await file.stream()
      .pipeThrough(chunker(65536, n => prog.add(n)))
      .pipeThrough(dec)
      .pipeTo(outStream)
      .then(async () => {
        if (typeof outStream.close === 'function') await outStream.close();
        row.setDownloadContent('<span class="badge text-bg-success">Saved to disk</span>');
      });

    prog.stop('complete');
    row.setOp('Decrypted');
    row.setNote('Derived from embedded parameters');
    row.appendLog('Decryption complete');
  }

  // ===== Actions (multi-file) =====
  async function encryptFiles() {
    clearError();
    const pass = els.secret.value;
    if (!pass) { showError('Passphrase is required'); return; }

    const files = Array.from(els.fileInput.files || []);
    if (!files.length) { showError('Please choose at least one file.'); return; }

    if (!streamingSinkAvailable()) {
      showError('A streaming file sink is required. Use Chrome/Edge (File System Access) or include StreamSaver.');
      return;
    }

    await setBusy(els.encryptBtn, true);
    try {
      for (const file of files) {
        try {
          await encryptOneFile(file, pass);
        } catch (e) {
          const row = makeRowWithLog({
            fileName: file.name,
            opInitial: 'Error',
            sizeInitial: file.size,
            noteInitial: (e?.message ?? String(e)),
          });
          row.appendLog(`error: ${e?.message ?? String(e)}`);
        }
      }
    } catch (e) {
      showError(e?.message ?? String(e));
    } finally {
      await setBusy(els.encryptBtn, false);
    }
  }

  async function decryptFiles() {
    clearError();
    const pass = els.secret.value;
    if (!pass) { showError('Passphrase is required'); return; }

    const files = Array.from(els.fileInput.files || []);
    if (!files.length) { showError('Please choose at least one encrypted file.'); return; }

    if (!streamingSinkAvailable()) {
      showError('A streaming file sink is required. Use Chrome/Edge (File System Access) or include StreamSaver.');
      return;
    }

    await setBusy(els.decryptBtn, true);
    try {
      for (const file of files) {
        try {
          await decryptOneFile(file, pass);
        } catch (e) {
          const row = makeRowWithLog({
            fileName: file.name,
            opInitial: 'Error',
            sizeInitial: file.size,
            noteInitial: (e?.message ?? String(e)),
          });
          row.appendLog(`error: ${e?.message ?? String(e)}`);
        }
      }
    } catch (e) {
      showError(e?.message ?? String(e));
    } finally {
      await setBusy(els.decryptBtn, false);
    }
  }

  function clearResults() {
    els.resultsBody.innerHTML = '';
    clearError();
    els.fileInput.value = '';
  }

  // ===== Drag & drop wiring =====
  function addFilesFromDataTransfer(dt) {
    const files = Array.from(dt.files || []);
    if (!files.length) return;
    const current = new DataTransfer();
    Array.from(els.fileInput.files || []).forEach(f => current.items.add(f));
    files.forEach(f => current.items.add(f));
    els.fileInput.files = current.files;
  }
  ['dragenter','dragover'].forEach(evt => {
    els.dropZone.addEventListener(evt, (e) => {
      e.preventDefault();
      e.stopPropagation();
      els.dropZone.classList.add('dragover');
    });
  });
  ['dragleave','drop'].forEach(evt => {
    els.dropZone.addEventListener(evt, (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (evt === 'drop') {
        addFilesFromDataTransfer(e.dataTransfer);
      }
      els.dropZone.classList.remove('dragover');
    });
  });

  // ===== Events =====
  els.encryptBtn.addEventListener('click', encryptFiles);
  els.decryptBtn.addEventListener('click', decryptFiles);
  els.clearBtn.addEventListener('click', clearResults);
</script>
</body>
</html>