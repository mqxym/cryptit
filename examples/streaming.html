<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Cryptit Browser Demo — File Encryption (Streaming)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="./favicon.ico" type="image/x-icon">

  <!-- Bootstrap 5 CSS -->
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
    rel="stylesheet"
  >

  <script src="./assets/streamsaver/StreamSaver.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/web-streams-polyfill@2.0.2/dist/ponyfill.min.js"></script>
 
  <script>
    // Required by cryptit to load the Argon2 wasm
    window.loadArgon2WasmBinary = () =>
      fetch("./assets/argon2.wasm")
        .then(r => r.arrayBuffer())
        .then(buf => new Uint8Array(buf));
  </script>

  <style>
    .dropzone {
      border: 2px dashed #ced4da;
      border-radius: .5rem;
      padding: 2rem;
      text-align: center;
      transition: background-color .15s ease-in-out, border-color .15s ease-in-out;
    }
    .dropzone.dragover {
      background-color: #f8f9fa;
      border-color: #86b7fe;
    }
    .file-list { max-height: 12rem; overflow: auto; }
    code.kv { font-size: .875rem; }
    .log-textarea { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" crossorigin="anonymous"></script>
</head>
<body>
  <nav class="navbar navbar-expand-lg navbar-light bg-light mb-4">
    <div class="container-fluid">
      <a class="navbar-brand" href="#">Cryptit Demo</a>
      <button
        class="navbar-toggler"
        type="button"
        data-bs-toggle="collapse"
        data-bs-target="#demoNav"
        aria-controls="demoNav"
        aria-expanded="false"
        aria-label="Toggle navigation"
      >
        <span class="navbar-toggler-icon"></span>
      </button>

      <div class="collapse navbar-collapse" id="demoNav">
        <ul class="navbar-nav me-auto mb-2 mb-lg-0">
          <li class="nav-item">
            <a class="nav-link" href="text-encryption.html">Text</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="text-decoding.html">Text Decoding</a>
          </li>
        <li class="nav-item">
            <a class="nav-link" href="file-encryption.html">File</a>
          </li>
          <li class="nav-item">
            <a class="nav-link active" aria-current="page" href="streaming.html">File (Streaming)</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="file-decoding.html">File Decoding</a>
          </li>
        </ul>
      </div>
    </div>
  </nav>

  <div class="container">
    <h1 class="mb-1">@mqyxm/cryptit</h1>
    <h2 class="mb-4">File Encryption / Decryption — Streaming</h2>
    <p>Via <a href="https://github.com/jimmywarting/StreamSaver.js">StreamSaver.js</a> or experimental <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/showSaveFilePicker">showSaveFilePicker()</a>.</p>
    <p><b>Note:</b> Safari doesn’t support streaming browser-generated data directly to disk (no File System Access API, and service-worker downloads aren’t truly streamed). Libraries must buffer the whole file in memory, which can exhaust RAM for large files. That’s why a safeguard blocks processing over 500&nbsp;MB on Safari. On iOS safari, even smaller files can cause crashes.</p>

    <!-- Configuration -->
    <div class="card mb-4">
      <div class="card-header">Configuration</div>
      <div class="card-body">
        <form id="configForm" class="row g-3">
          <div class="col-md-4">
            <label for="secret" class="form-label">Passphrase</label>
            <input type="password" value="abc" class="form-control" id="secret" placeholder="Enter passphrase">
          </div>
          <div class="col-md-4">
            <label for="scheme" class="form-label">Scheme ID (0 - max. 7)</label>
            <input type="number" min="0" value="0" class="form-control" id="scheme">
            <div class="form-text">0 = AES-GCM / Argon2id (single thread)</div>
            <div class="form-text">1 = XChaCha20-Poly1305 / Argon2id (multithread*)</div>
            <small class="form-text">* not supported in browsers. </small>
          </div>
          <div class="col-md-4">
            <label for="difficulty" class="form-label">Argon2 Difficulty</label>
            <select id="difficulty" class="form-select">
              <option value="low">low</option>
              <option value="middle" selected>middle</option>
              <option value="high">high</option>
            </select>
          </div>
          <div class="col-md-4">
            <label for="saltStrength" class="form-label">Salt Strength</label>
            <select id="saltStrength" class="form-select">
              <option value="low">low</option>
              <option value="high" selected>high</option>
            </select>
          </div>
          <div class="col-md-4">
            <label for="verbose" class="form-label">Verbose Level</label>
            <input type="number" min="0" max="4" value="0" class="form-control" id="verbose">
            <div class="form-text">0 = errors only, 4 = maximum detail</div>
          </div>
        </form>
      </div>
    </div>

    <!-- File picker / drop area -->
    <div class="row g-3 mb-3">
      <div class="col-md-6">
        <label for="fileInput" class="form-label">Choose files</label>
        <input id="fileInput" class="form-control" type="file" multiple>
        <div class="form-text">You can select one or more files.</div>
      </div>
      <div class="col-md-6">
        <label class="form-label">Or drag & drop</label>
        <div id="dropZone" class="dropzone">Drop files here</div>
      </div>
    </div>

    <!-- Action buttons & error -->
    <div class="mb-3 d-flex align-items-center gap-2">
      <button id="encryptBtn" class="btn btn-primary">Encrypt</button>
      <button id="decryptBtn" class="btn btn-secondary">Decrypt</button>
      <button id="clearBtn" class="btn btn-outline-danger ms-auto">Clear results</button>
    </div>
    <div id="errorMsg" class="alert alert-danger d-none"></div>

    <!-- Results -->
    <div class="card">
      <div class="card-header">Results</div>
      <div class="card-body">
        <div class="table-responsive">
          <table class="table align-middle mb-0">
            <thead>
              <tr>
                <th scope="col">File</th>
                <th scope="col">Operation</th>
                <th scope="col">Size</th>
                <th scope="col">Download</th>
                <th scope="col" style="width: 30%">Notes</th>
              </tr>
            </thead>
            <tbody id="resultsBody">
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <p class="text-muted mt-3 mb-0">
      <strong>Notes:</strong> Encrypted files include a self-describing header (scheme, params, salt, etc.).
      Decryption uses this embedded header automatically. You only need the passphrase.
    </p>
  </div>

  <div class="modal fade" id="safariLimitModal" tabindex="-1" aria-labelledby="safariLimitLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="safariLimitLabel">Safari limitation for large files</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <p class="mb-2"><strong>Short version:</strong> Safari can’t save while the file is being processed. To keep the page stable, files larger than <strong>500&nbsp;MB</strong> aren’t processed here.</p>
        <ul class="small mb-3" id="safariLimitList" style="max-height:8rem;overflow:auto;"></ul>
        <p class="small text-muted mb-0"><strong>Technical details:</strong> Safari doesn’t support streaming browser-generated data directly to disk (no File System Access API, and service-worker downloads aren’t truly streamed). Libraries must buffer the whole file in memory, which can exhaust RAM for large files. That’s why this safeguard blocks processing over 500&nbsp;MB on Safari.</p>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-primary" data-bs-dismiss="modal">OK</button>
      </div>
    </div>
  </div>
</div>

  <script type="module">
    import { createCryptit } from "./assets/cryptit.browser.min.js";
    window.createCryptit = createCryptit;
  </script>

  <!-- Inline demo logic -->
<script type="module">
  const { createCryptit } = window;

  // ─────────────────────────────────────────────────────────────────────────────
  // iOS & StreamSaver environment helpers
  // ─────────────────────────────────────────────────────────────────────────────
  const isiOS = () => /iPad|iPhone|iPod/.test(navigator.userAgent) ||
    (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

  // NOTE: Host StreamSaver's mitm.html yourself on the same origin to avoid
  // Safari/iOS naming quirks (.html appendix) and to keep SW scoped correctly.
  // Place StreamSaver's mitm.html at /streamsaver/mitm.html
  function initStreamSaver() {
    if (!window.streamSaver) return;
    // Scope the service worker to your origin; prevents iOS saving the MITM page.
    window.streamSaver.mitm = new URL('./assets/streamsaver/mitm.html', location.href).toString();
  }

  // StreamSaver present & usable (no FS Access on iOS Safari as of 2025)
  function supportsStreamSaver() {
    return !!(window.streamSaver && window.streamSaver.createWriteStream);
  }

  function streamingSinkAvailable() {
    // iOS Safari does not support showSaveFilePicker; rely on StreamSaver there.
    return ('showSaveFilePicker' in window) || supportsStreamSaver();
  }

  async function createStreamingWritable(filename, size, mime = 'application/octet-stream') {
    // Prefer FS Access where available (not on iOS Safari).
    if ('showSaveFilePicker' in window && !isiOS()) {
      const ext = (filename.match(/\.[a-z0-9]+$/i)?.[0] || '.cryptit').toLowerCase();
      const handle = await window.showSaveFilePicker({
        suggestedName: filename,
        types: [{ description: 'File', accept: { [mime || 'application/octet-stream']: [ext] } }],
        excludeAcceptAllOption: false
      });
      return await handle.createWritable();
    }
    if (supportsStreamSaver()) {
      // Provide size for progress + better finalize behavior in StreamSaver.
      return window.streamSaver.createWriteStream(filename, { size });
    }
    throw new Error('No streaming sink available in this browser.');
  }

  // ─────────────────────────────────────────────────────────────────────────────
  // UI shortcuts
  // ─────────────────────────────────────────────────────────────────────────────
  const $ = (id) => document.getElementById(id);
  const els = {
    secret: $('secret'),
    scheme: $('scheme'),
    difficulty: $('difficulty'),
    saltStrength: $('saltStrength'),
    verbose: $('verbose'),
    fileInput: $('fileInput'),
    dropZone: $('dropZone'),
    resultsBody: $('resultsBody'),
    error: $('errorMsg'),
    encryptBtn: $('encryptBtn'),
    decryptBtn: $('decryptBtn'),
    clearBtn: $('clearBtn'),
  };

  // ===== Safari guard (>= 500 MB) =====
const SAFARI_LARGE_FILE_LIMIT = 500 * 1024 * 1024; // 500 MB

function isSafari() {
  const ua = navigator.userAgent;
  // True for Safari (macOS & iOS), false for Chrome/Edge/Firefox (incl. iOS variants)
  return /Safari/i.test(ua) && !/Chrome|CriOS|Chromium|Edg|OPR|Brave/i.test(ua);
}

function filesOverLimit(files, limit = SAFARI_LARGE_FILE_LIMIT) {
  return files.filter(f => Number.isFinite(f.size) && f.size > limit);
}

function showSafariLimitModal(blockedFiles) {
  const list = document.getElementById('safariLimitList');
  list.innerHTML = ''; // Clear previous
  if (blockedFiles && blockedFiles.length > 0) {
    blockedFiles.forEach(f => {
      const li = document.createElement('li');
      const code = document.createElement('code');
      code.className = 'kv';
      code.textContent = f.name;
      li.append(code, ` — ${formatBytes(f.size)}`);
      list.append(li);
    });
  } else {
    const li = document.createElement('li');
    li.textContent = 'No file details available.';
    list.append(li);
  }

  const modalEl = document.getElementById('safariLimitModal');
  const modal = bootstrap.Modal.getOrCreateInstance(modalEl);
  modal.show();
}

/**
 * Returns true if it is OK to proceed, otherwise shows modal and returns false.
 */
function guardSafariLargeFiles(files) {
  if (!isSafari()) return true;
  const blocked = filesOverLimit(files);
  if (blocked.length === 0) return true;
  showSafariLimitModal(blocked);
  return false;
}

  function showError(msg) {
    els.error.textContent = `error: ${msg || 'Something went wrong.'}`;
    els.error.classList.remove('d-none');
  }
  function clearError() {
    els.error.textContent = '';
    els.error.classList.add('d-none');
  }

  function cryptit() {
    return createCryptit({
      scheme: Number(els.scheme.value),
      difficulty: els.difficulty.value,
      saltStrength: els.saltStrength.value,
      verbose: Number(els.verbose.value),
    });
  }

  const sleep = (ms) => new Promise((r) => setTimeout(r, ms));
  let rowIdCounter = 0;

  async function setBusy(btn, busy) {
    const other = btn === els.encryptBtn ? els.decryptBtn : els.encryptBtn;
    if (busy) {
      if (!btn.dataset.original) btn.dataset.original = btn.textContent.trim();
      btn.textContent = '...';
      btn.disabled = true;
      other.disabled = true;
      els.clearBtn.disabled = true;
      await sleep(150);
    } else {
      btn.textContent = btn.dataset.original || btn.textContent;
      btn.disabled = false;
      other.disabled = false;
      els.clearBtn.disabled = false;
    }
  }

  function formatBytes(bytes) {
    if (!Number.isFinite(bytes)) return '-';
    const units = ['B','KB','MB','GB','TB'];
    const i = bytes === 0 ? 0 : Math.floor(Math.log(bytes) / Math.log(1024));
    const v = (bytes / Math.pow(1024, i));
    return `${v >= 100 ? v.toFixed(0) : v.toFixed(1)} ${units[i]}`;
  }
  const suggestEncName = (n='file') => `${n}.cryptit`;
  function suggestDecName(name='file') {
    const lower = name.toLowerCase();
    if (lower.endsWith('.cryptit')) return name.slice(0, -8);
    if (lower.endsWith('.enc')) return name.slice(0, -4);
    return `${name}.decrypted`;
  }
  const timestamp = () => new Date().toLocaleTimeString();

  // ─────────────────────────────────────────────────────────────────────────────
  // Progress helper
  // ─────────────────────────────────────────────────────────────────────────────
  function makeProgressReporter({ total = 0, interval = 500, onTick, onFinal } = {}) {
    let transferred = 0, lastShown = -1, timer = null;
    const emit = (final=false) => {
      if (!final && transferred === lastShown) return;
      lastShown = transferred;
      const pct = total ? (transferred / total) * 100 : 0;
      onTick?.({ transferred, total, pct });
    };
    return {
      start() { if (!timer) timer = setInterval(() => emit(false), interval); },
      add(n) { transferred += n; },
      stop(finalMsg='') { if (timer) { clearInterval(timer); timer = null; } emit(true); onFinal?.({ transferred, total, msg: finalMsg }); }
    };
  }

  // ─────────────────────────────────────────────────────────────────────────────
  // Table row
  // ─────────────────────────────────────────────────────────────────────────────
  const rowsByKey = new Map(); // key: `${op}|${name}|${size}|${lastModified}`

  function makeRowWithLog({ file, opInitial, sizeInitial, noteInitial }) {
    const key = `${opInitial}|${file.name}|${file.size}|${file.lastModified}`;
    if (rowsByKey.has(key)) return rowsByKey.get(key);

    const id = ++rowIdCounter;
    const logId = `log-${id}`;

    const tr = document.createElement('tr');

    const fileCell = document.createElement('td');
    fileCell.className = 'file-cell';
    const fileSpan = document.createElement('span');
    fileSpan.className = 'text-break';
    fileSpan.textContent = file.name;
    fileCell.appendChild(fileSpan);

    const opCell = document.createElement('td');
    opCell.className = 'op-cell';
    opCell.textContent = opInitial || '-';

    const sizeCell = document.createElement('td');
    sizeCell.className = 'size-cell';
    sizeCell.textContent = Number.isFinite(sizeInitial) ? formatBytes(sizeInitial) : '-';

    const dlCell = document.createElement('td');
    dlCell.className = 'dl-cell';
    const logButton = document.createElement('button');
    logButton.className = 'btn btn-sm btn-outline-secondary';
    logButton.setAttribute('data-bs-toggle', 'collapse');
    logButton.setAttribute('data-bs-target', `#${logId}`);
    logButton.setAttribute('aria-expanded', 'false');
    logButton.textContent = 'Log';
    dlCell.appendChild(logButton);

    const notesCell = document.createElement('td');
    notesCell.className = 'notes-cell';
    const notesSmall = document.createElement('small');
    notesSmall.className = 'text-muted';
    notesSmall.textContent = noteInitial || '';
    notesCell.appendChild(notesSmall);

    tr.append(fileCell, opCell, sizeCell, dlCell, notesCell);

    const logRow = document.createElement('tr');
    logRow.className = 'collapse';
    logRow.id = logId;
    const logCell = document.createElement('td');
    logCell.colSpan = 5;
    const logTextarea = document.createElement('textarea');
    logTextarea.className = 'form-control log-textarea';
    logTextarea.rows = 6;
    logTextarea.readOnly = true;
    logCell.appendChild(logTextarea);
    logRow.appendChild(logCell);
    els.resultsBody.prepend(logRow);
    els.resultsBody.prepend(tr);

    const logEl = logRow.querySelector('textarea');

    function appendLog(line) {
      logEl.value += `[${timestamp()}] ${line}\n`;
      logEl.scrollTop = logEl.scrollHeight;
    }
    function setOp(text) { tr.querySelector('.op-cell').textContent = text; }
    function setSize(n) { tr.querySelector('.size-cell').textContent = Number.isFinite(n) ? formatBytes(n) : '-'; }
    function setNote(html) { tr.querySelector('.notes-cell').innerHTML = `<small class="text-muted">${html}</small>`; }
    function setDownloadContent(elOrHtml) {
      const td = tr.querySelector('.dl-cell');
      if (typeof elOrHtml === 'string') td.innerHTML = elOrHtml;
      else { td.innerHTML = ''; td.appendChild(elOrHtml); }
      const logBtn = document.createElement('button');
      logBtn.className = 'btn btn-sm btn-outline-secondary ms-2';
      logBtn.textContent = 'Log';
      logBtn.setAttribute('data-bs-toggle','collapse');
      logBtn.setAttribute('data-bs-target',`#${logId}`);
      td.appendChild(logBtn);
    }

    const row = { appendLog, setOp, setSize, setNote, setDownloadContent, key };
    rowsByKey.set(key, row);
    return row;
  }

  // ─────────────────────────────────────────────────────────────────────────────
  // Chunker
  // ─────────────────────────────────────────────────────────────────────────────
  function chunker(max = 65536, onBytes) {
    return new TransformStream({
      transform(chunk, ctl) {
        chunk = chunk instanceof Uint8Array ? chunk : new Uint8Array(chunk);
        for (let i = 0; i < chunk.byteLength; i += max) {
          const sub = chunk.subarray(i, i + max);
          onBytes?.(sub.byteLength);
          ctl.enqueue(sub);
        }
      }
    });
  }

  // ─────────────────────────────────────────────────────────────────────────────
  // Finalization helper to solve “stuck on downloading…” (iOS)
  // ─────────────────────────────────────────────────────────────────────────────
  async function finalizeWritable(outStream, { graceMs = 800 } = {}) {
    // Try to use a writer.closed promise when available; otherwise a short grace.
    try {
      if (outStream?.getWriter) {
        const w = outStream.getWriter();
        // If a writer can be obtained, immediately release it (we only need .closed)
        w.releaseLock();
      }
    } catch {}
    // Best-effort tiny grace; on iOS the pipeTo() may resolve late.
    if (isiOS()) await sleep(graceMs);
  }

  // ─────────────────────────────────────────────────────────────────────────────
  // Encrypt (single-row, iOS-safe naming & completion)
  // ─────────────────────────────────────────────────────────────────────────────
  async function encryptOneFile(file, pass) {
    const row = makeRowWithLog({
      file, opInitial: 'Encrypting…', sizeInitial: NaN, noteInitial: 'starting'
    });
    row.appendLog(`Begin encryption of ${file.name} (${formatBytes(file.size)})`);

    if (!streamingSinkAvailable()) {
      row.setOp('Blocked');
      row.setNote('No streaming sink. Use Chrome/Edge or include StreamSaver.');
      row.appendLog('Aborted to avoid in-memory buffering.');
      return;
    }

    console.log(isiOS());

    // Initialize StreamSaver env early (mitm path) to avoid iOS ".html" suffix.
    initStreamSaver();

    const c = cryptit();
    const { header, writable, readable } = await c.createEncryptionStream(pass);
    const suggested = suggestEncName(file.name || 'file');

    let outStream;
    try {
      outStream = await createStreamingWritable(suggested, header.byteLength + file.size);
    } catch (e) {
      row.setOp('Canceled');
      row.setNote('Save was canceled or streaming sink unavailable.');
      row.appendLog(e?.message ?? String(e));
      return; // IMPORTANT: do not throw → no duplicate error row
    }

    row.setDownloadContent('<span class="badge text-bg-secondary">Saving to disk…</span>');

    const prog = makeProgressReporter({
      total: file.size,
      interval: 400,
      onTick: ({ transferred, total, pct }) => {
        const p = total ? `${pct.toFixed(1)}%` : '';
        row.setNote(`encrypted ${formatBytes(transferred)} ${total ? `/ ${formatBytes(total)} (${p})` : ''}`);
      },
      onFinal: ({ transferred }) => {
        row.appendLog(`Encrypted ${formatBytes(transferred)} of plaintext`);
      }
    });
    prog.start();

    // Write header first, then stream cipher body
    const writer = outStream.getWriter?.();
    try {
      if (writer?.write) {
        await writer.write(header);
        writer.releaseLock();
      } else if (typeof outStream.write === 'function') {
        await outStream.write(header);
      } else {
        // Fallback: concat header+body via a small ReadableStream
        const prelude = new ReadableStream({ start(c){ c.enqueue(header); c.close(); } });
        await prelude.pipeTo(outStream, { preventClose: true });
      }

      const pumpOut = readable.pipeTo(outStream)
        .catch(e => { throw e; });

      const pumpIn = file.stream()
        .pipeThrough(chunker(65536, n => prog.add(n)))
        .pipeTo(writable)
        .catch(e => { throw e; });

      await Promise.all([pumpIn, pumpOut]);
      prog.stop('complete');

      await finalizeWritable(outStream, { graceMs: 800 });
      if (typeof outStream.close === 'function') await outStream.close().catch(()=>{});

      row.setOp('Encrypted');
      row.setNote('Header embedded; MIME: application/octet-stream');
      row.setDownloadContent('<span class="badge text-bg-success">Saved to disk</span>');
      row.appendLog('Encryption complete');
    } catch (e) {
      prog.stop('error');
      try { if (typeof outStream?.abort === 'function') await outStream.abort(e); } catch {}
      row.setOp('Error');
      row.setNote((e?.message ?? String(e)));
      row.appendLog(`error: ${e?.message ?? String(e)}`);
      // IMPORTANT: swallow error here to avoid duplicate "Error" rows from caller
    }
  }

  // ─────────────────────────────────────────────────────────────────────────────
  // Decrypt (single-row, iOS completion)
  // ─────────────────────────────────────────────────────────────────────────────
  async function decryptOneFile(file, pass) {
    const row = makeRowWithLog({
      file, opInitial: 'Decrypting…', sizeInitial: NaN, noteInitial: 'starting'
    });
    row.appendLog(`Begin decryption of ${file.name} (${formatBytes(file.size)})`);

    if (!streamingSinkAvailable()) {
      row.setOp('Blocked');
      row.setNote('No streaming sink. Use Chrome/Edge or include StreamSaver.');
      row.appendLog('Aborted to avoid in-memory buffering.');
      return;
    }

    initStreamSaver();

    const c = cryptit();
    const dec = await c.createDecryptionStream(pass);

    const outName = suggestDecName(file.name || 'file');

    let outStream;
    try {
      // Note: ciphertext size progress baseline; plaintext size is unknown until done
      outStream = await createStreamingWritable(outName, file.size);
    } catch (e) {
      row.setOp('Canceled');
      row.setNote('Save was canceled or streaming sink unavailable.');
      row.appendLog(e?.message ?? String(e));
      return; // avoid duplicate row
    }

    row.setDownloadContent('<span class="badge text-bg-secondary">Saving to disk…</span>');

    const prog = makeProgressReporter({
      total: file.size,
      interval: 400,
      onTick: ({ transferred, total, pct }) => {
        const p = total ? `${pct.toFixed(1)}%` : '';
        row.setNote(`processed ${formatBytes(transferred)} ${total ? `/ ${formatBytes(total)} (${p})` : ''}`);
      },
      onFinal: ({ transferred }) => {
        row.appendLog(`Read ${formatBytes(transferred)} of ciphertext`);
      }
    });
    prog.start();

    try {
      await file.stream()
        .pipeThrough(chunker(65536, n => prog.add(n)))
        .pipeThrough(dec)
        .pipeTo(outStream);

      prog.stop('complete');

      await finalizeWritable(outStream, { graceMs: 800 });
      if (typeof outStream.close === 'function') await outStream.close().catch(()=>{});

      row.setOp('Decrypted');
      row.setNote('Derived from embedded parameters');
      row.setDownloadContent('<span class="badge text-bg-success">Saved to disk</span>');
      row.appendLog('Decryption complete');
    } catch (e) {
      prog.stop('error');
      try { if (typeof outStream?.abort === 'function') await outStream.abort(e); } catch {}
      row.setOp('Error');
      row.setNote((e?.message ?? String(e)));
      row.appendLog(`error: ${e?.message ?? String(e)}`);
      // swallow to avoid duplicate rows
    }
  }

  // ─────────────────────────────────────────────────────────────────────────────
  // Multi-file actions (no duplicate error rows)
  // ─────────────────────────────────────────────────────────────────────────────
  function getSelectedFiles() {
    return Array.from(els.fileInput.files || []);
  }

  async function encryptFiles() {
    clearError();
    const pass = els.secret.value;
    if (!pass) { showError('Passphrase is required'); return; }

    const files = getSelectedFiles();
    if (!files.length) { showError('Please choose at least one file.'); return; }

    if (!guardSafariLargeFiles(files)) return;

    if (!streamingSinkAvailable()) {
      showError('A streaming sink is required. Use Chrome/Edge or include StreamSaver.');
      return;
    }

    await setBusy(els.encryptBtn, true);
    try {
      for (const file of files) {
        await encryptOneFile(file, pass); // internal errors handled per-row
      }
    } finally {
      await setBusy(els.encryptBtn, false);
    }
  }

  async function decryptFiles() {
    clearError();
    const pass = els.secret.value;
    if (!pass) { showError('Passphrase is required'); return; }

    const files = getSelectedFiles();
    if (!files.length) { showError('Please choose at least one encrypted file.'); return; }

    if (!guardSafariLargeFiles(files)) return;

    if (!streamingSinkAvailable()) {
      showError('A streaming sink is required. Use Chrome/Edge or include StreamSaver.');
      return;
    }

    await setBusy(els.decryptBtn, true);
    try {
      for (const file of files) {
        await decryptOneFile(file, pass); // internal errors handled per-row
      }
    } finally {
      await setBusy(els.decryptBtn, false);
    }
  }

  function clearResults() {
    els.resultsBody.innerHTML = '';
    rowsByKey.clear();
    clearError();
    els.fileInput.value = '';
  }

  // ─────────────────────────────────────────────────────────────────────────────
  // Drag & drop
  // ─────────────────────────────────────────────────────────────────────────────
  function addFilesFromDataTransfer(dt) {
    const files = Array.from(dt.files || []);
    if (!files.length) return;
    const current = new DataTransfer();
    Array.from(els.fileInput.files || []).forEach(f => current.items.add(f));
    files.forEach(f => current.items.add(f));
    els.fileInput.files = current.files;
  }
  ['dragenter','dragover'].forEach(evt => {
    els.dropZone.addEventListener(evt, (e) => {
      e.preventDefault(); e.stopPropagation();
      els.dropZone.classList.add('dragover');
    });
  });
  ['dragleave','drop'].forEach(evt => {
    els.dropZone.addEventListener(evt, (e) => {
      e.preventDefault(); e.stopPropagation();
      if (evt === 'drop') addFilesFromDataTransfer(e.dataTransfer);
      els.dropZone.classList.remove('dragover');
    });
  });

  // ─────────────────────────────────────────────────────────────────────────────
  // Events
  // ─────────────────────────────────────────────────────────────────────────────
  els.encryptBtn.addEventListener('click', encryptFiles);
  els.decryptBtn.addEventListener('click', decryptFiles);
  els.clearBtn.addEventListener('click', clearResults);

  // One-time init for StreamSaver
  initStreamSaver();
</script>
</body>
</html>