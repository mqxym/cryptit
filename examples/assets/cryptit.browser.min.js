var __create=Object.create;var{getPrototypeOf:__getProtoOf,defineProperty:__defProp,getOwnPropertyNames:__getOwnPropNames,getOwnPropertyDescriptor:__getOwnPropDesc}=Object,__hasOwnProp=Object.prototype.hasOwnProperty;var __toESM=(mod,isNodeMode,target)=>{target=mod!=null?__create(__getProtoOf(mod)):{};let to=isNodeMode||!mod||!mod.__esModule?__defProp(target,"default",{value:mod,enumerable:!0}):target;for(let key of __getOwnPropNames(mod))if(!__hasOwnProp.call(to,key))__defProp(to,key,{get:()=>mod[key],enumerable:!0});return to},__moduleCache=new WeakMap,__toCommonJS=(from)=>{var entry=__moduleCache.get(from),desc;if(entry)return entry;if(entry=__defProp({},"__esModule",{value:!0}),from&&typeof from==="object"||typeof from==="function")__getOwnPropNames(from).map((key)=>!__hasOwnProp.call(entry,key)&&__defProp(entry,key,{get:()=>from[key],enumerable:!(desc=__getOwnPropDesc(from,key))||desc.enumerable}));return __moduleCache.set(from,entry),entry},__commonJS=(cb,mod)=>()=>(mod||cb((mod={exports:{}}).exports,mod),mod.exports);var __export=(target,all)=>{for(var name in all)__defProp(target,name,{get:all[name],enumerable:!0,configurable:!0,set:(newValue)=>all[name]=()=>newValue})};var __esm=(fn,res)=>()=>(fn&&(res=fn(fn=0)),res);var __require=((x)=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(x,{get:(a,b)=>(typeof require<"u"?require:a)[b]}):x)(function(x){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+x+'" is not supported')});var exports_path={};__export(exports_path,{sep:()=>sep,resolve:()=>resolve,relative:()=>relative,posix:()=>posix,parse:()=>parse,normalize:()=>normalize,join:()=>join,isAbsolute:()=>isAbsolute,format:()=>format,extname:()=>extname,dirname:()=>dirname,delimiter:()=>delimiter,default:()=>path_default,basename:()=>basename,_makeLong:()=>_makeLong});function assertPath(path){if(typeof path!=="string")throw TypeError("Path must be a string. Received "+JSON.stringify(path))}function normalizeStringPosix(path,allowAboveRoot){var res="",lastSegmentLength=0,lastSlash=-1,dots=0,code;for(var i=0;i<=path.length;++i){if(i<path.length)code=path.charCodeAt(i);else if(code===47)break;else code=47;if(code===47){if(lastSlash===i-1||dots===1);else if(lastSlash!==i-1&&dots===2){if(res.length<2||lastSegmentLength!==2||res.charCodeAt(res.length-1)!==46||res.charCodeAt(res.length-2)!==46){if(res.length>2){var lastSlashIndex=res.lastIndexOf("/");if(lastSlashIndex!==res.length-1){if(lastSlashIndex===-1)res="",lastSegmentLength=0;else res=res.slice(0,lastSlashIndex),lastSegmentLength=res.length-1-res.lastIndexOf("/");lastSlash=i,dots=0;continue}}else if(res.length===2||res.length===1){res="",lastSegmentLength=0,lastSlash=i,dots=0;continue}}if(allowAboveRoot){if(res.length>0)res+="/..";else res="..";lastSegmentLength=2}}else{if(res.length>0)res+="/"+path.slice(lastSlash+1,i);else res=path.slice(lastSlash+1,i);lastSegmentLength=i-lastSlash-1}lastSlash=i,dots=0}else if(code===46&&dots!==-1)++dots;else dots=-1}return res}function _format(sep,pathObject){var dir=pathObject.dir||pathObject.root,base=pathObject.base||(pathObject.name||"")+(pathObject.ext||"");if(!dir)return base;if(dir===pathObject.root)return dir+base;return dir+sep+base}function resolve(){var resolvedPath="",resolvedAbsolute=!1,cwd;for(var i=arguments.length-1;i>=-1&&!resolvedAbsolute;i--){var path;if(i>=0)path=arguments[i];else{if(cwd===void 0)cwd=process.cwd();path=cwd}if(assertPath(path),path.length===0)continue;resolvedPath=path+"/"+resolvedPath,resolvedAbsolute=path.charCodeAt(0)===47}if(resolvedPath=normalizeStringPosix(resolvedPath,!resolvedAbsolute),resolvedAbsolute)if(resolvedPath.length>0)return"/"+resolvedPath;else return"/";else if(resolvedPath.length>0)return resolvedPath;else return"."}function normalize(path){if(assertPath(path),path.length===0)return".";var isAbsolute=path.charCodeAt(0)===47,trailingSeparator=path.charCodeAt(path.length-1)===47;if(path=normalizeStringPosix(path,!isAbsolute),path.length===0&&!isAbsolute)path=".";if(path.length>0&&trailingSeparator)path+="/";if(isAbsolute)return"/"+path;return path}function isAbsolute(path){return assertPath(path),path.length>0&&path.charCodeAt(0)===47}function join(){if(arguments.length===0)return".";var joined;for(var i=0;i<arguments.length;++i){var arg=arguments[i];if(assertPath(arg),arg.length>0)if(joined===void 0)joined=arg;else joined+="/"+arg}if(joined===void 0)return".";return normalize(joined)}function relative(from,to){if(assertPath(from),assertPath(to),from===to)return"";if(from=resolve(from),to=resolve(to),from===to)return"";var fromStart=1;for(;fromStart<from.length;++fromStart)if(from.charCodeAt(fromStart)!==47)break;var fromEnd=from.length,fromLen=fromEnd-fromStart,toStart=1;for(;toStart<to.length;++toStart)if(to.charCodeAt(toStart)!==47)break;var toEnd=to.length,toLen=toEnd-toStart,length=fromLen<toLen?fromLen:toLen,lastCommonSep=-1,i=0;for(;i<=length;++i){if(i===length){if(toLen>length){if(to.charCodeAt(toStart+i)===47)return to.slice(toStart+i+1);else if(i===0)return to.slice(toStart+i)}else if(fromLen>length){if(from.charCodeAt(fromStart+i)===47)lastCommonSep=i;else if(i===0)lastCommonSep=0}break}var fromCode=from.charCodeAt(fromStart+i),toCode=to.charCodeAt(toStart+i);if(fromCode!==toCode)break;else if(fromCode===47)lastCommonSep=i}var out="";for(i=fromStart+lastCommonSep+1;i<=fromEnd;++i)if(i===fromEnd||from.charCodeAt(i)===47)if(out.length===0)out+="..";else out+="/..";if(out.length>0)return out+to.slice(toStart+lastCommonSep);else{if(toStart+=lastCommonSep,to.charCodeAt(toStart)===47)++toStart;return to.slice(toStart)}}function _makeLong(path){return path}function dirname(path){if(assertPath(path),path.length===0)return".";var code=path.charCodeAt(0),hasRoot=code===47,end=-1,matchedSlash=!0;for(var i=path.length-1;i>=1;--i)if(code=path.charCodeAt(i),code===47){if(!matchedSlash){end=i;break}}else matchedSlash=!1;if(end===-1)return hasRoot?"/":".";if(hasRoot&&end===1)return"//";return path.slice(0,end)}function basename(path,ext){if(ext!==void 0&&typeof ext!=="string")throw TypeError('"ext" argument must be a string');assertPath(path);var start=0,end=-1,matchedSlash=!0,i;if(ext!==void 0&&ext.length>0&&ext.length<=path.length){if(ext.length===path.length&&ext===path)return"";var extIdx=ext.length-1,firstNonSlashEnd=-1;for(i=path.length-1;i>=0;--i){var code=path.charCodeAt(i);if(code===47){if(!matchedSlash){start=i+1;break}}else{if(firstNonSlashEnd===-1)matchedSlash=!1,firstNonSlashEnd=i+1;if(extIdx>=0)if(code===ext.charCodeAt(extIdx)){if(--extIdx===-1)end=i}else extIdx=-1,end=firstNonSlashEnd}}if(start===end)end=firstNonSlashEnd;else if(end===-1)end=path.length;return path.slice(start,end)}else{for(i=path.length-1;i>=0;--i)if(path.charCodeAt(i)===47){if(!matchedSlash){start=i+1;break}}else if(end===-1)matchedSlash=!1,end=i+1;if(end===-1)return"";return path.slice(start,end)}}function extname(path){assertPath(path);var startDot=-1,startPart=0,end=-1,matchedSlash=!0,preDotState=0;for(var i=path.length-1;i>=0;--i){var code=path.charCodeAt(i);if(code===47){if(!matchedSlash){startPart=i+1;break}continue}if(end===-1)matchedSlash=!1,end=i+1;if(code===46){if(startDot===-1)startDot=i;else if(preDotState!==1)preDotState=1}else if(startDot!==-1)preDotState=-1}if(startDot===-1||end===-1||preDotState===0||preDotState===1&&startDot===end-1&&startDot===startPart+1)return"";return path.slice(startDot,end)}function format(pathObject){if(pathObject===null||typeof pathObject!=="object")throw TypeError('The "pathObject" argument must be of type Object. Received type '+typeof pathObject);return _format("/",pathObject)}function parse(path){assertPath(path);var ret={root:"",dir:"",base:"",ext:"",name:""};if(path.length===0)return ret;var code=path.charCodeAt(0),isAbsolute2=code===47,start;if(isAbsolute2)ret.root="/",start=1;else start=0;var startDot=-1,startPart=0,end=-1,matchedSlash=!0,i=path.length-1,preDotState=0;for(;i>=start;--i){if(code=path.charCodeAt(i),code===47){if(!matchedSlash){startPart=i+1;break}continue}if(end===-1)matchedSlash=!1,end=i+1;if(code===46){if(startDot===-1)startDot=i;else if(preDotState!==1)preDotState=1}else if(startDot!==-1)preDotState=-1}if(startDot===-1||end===-1||preDotState===0||preDotState===1&&startDot===end-1&&startDot===startPart+1){if(end!==-1)if(startPart===0&&isAbsolute2)ret.base=ret.name=path.slice(1,end);else ret.base=ret.name=path.slice(startPart,end)}else{if(startPart===0&&isAbsolute2)ret.name=path.slice(1,startDot),ret.base=path.slice(1,end);else ret.name=path.slice(startPart,startDot),ret.base=path.slice(startPart,end);ret.ext=path.slice(startDot,end)}if(startPart>0)ret.dir=path.slice(0,startPart-1);else if(isAbsolute2)ret.dir="/";return ret}var sep="/",delimiter=":",posix,path_default;var init_path=__esm(()=>{posix=((p)=>(p.posix=p,p))({resolve,normalize,isAbsolute,join,relative,_makeLong,dirname,basename,extname,format,parse,sep,delimiter,win32:null,posix:null}),path_default=posix});var require_argon2=__commonJS((exports,module)=>{var __dirname="/Users/maxim/Projects/Private/Packages/cryptit/node_modules/argon2-browser/dist",Module2=typeof self<"u"&&typeof self.Module<"u"?self.Module:{},jsModule=Module2,moduleOverrides={},key;for(key in Module2)if(Module2.hasOwnProperty(key))moduleOverrides[key]=Module2[key];var arguments_=[],thisProgram="./this.program",quit_=function(status,toThrow){throw toThrow},ENVIRONMENT_IS_WEB=!1,ENVIRONMENT_IS_WORKER=!1,ENVIRONMENT_IS_NODE=!1,ENVIRONMENT_IS_SHELL=!1;ENVIRONMENT_IS_WEB=typeof window==="object";ENVIRONMENT_IS_WORKER=typeof importScripts==="function";ENVIRONMENT_IS_NODE=typeof process==="object"&&typeof process.versions==="object"&&typeof process.versions.node==="string";ENVIRONMENT_IS_SHELL=!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_NODE&&!ENVIRONMENT_IS_WORKER;var scriptDirectory="";function locateFile(path){if(Module2.locateFile)return Module2.locateFile(path,scriptDirectory);return scriptDirectory+path}var read_,readAsync,readBinary,setWindowTitle,nodeFS,nodePath;if(ENVIRONMENT_IS_NODE){if(ENVIRONMENT_IS_WORKER)scriptDirectory=(init_path(),__toCommonJS(exports_path)).dirname(scriptDirectory)+"/";else scriptDirectory=__dirname+"/";if(read_=function shell_read(filename,binary){if(!nodeFS)nodeFS=(()=>({}));if(!nodePath)nodePath=(init_path(),__toCommonJS(exports_path));return filename=nodePath.normalize(filename),nodeFS.readFileSync(filename,binary?null:"utf8")},readBinary=function readBinary(filename){var ret=read_(filename,!0);if(!ret.buffer)ret=new Uint8Array(ret);return assert(ret.buffer),ret},process.argv.length>1)thisProgram=process.argv[1].replace(/\\/g,"/");if(arguments_=process.argv.slice(2),typeof module<"u")module.exports=Module2;process.on("uncaughtException",function(ex){if(!(ex instanceof ExitStatus))throw ex}),process.on("unhandledRejection",abort),quit_=function(status){process.exit(status)},Module2.inspect=function(){return"[Emscripten Module object]"}}else if(ENVIRONMENT_IS_SHELL){if(typeof read<"u")read_=function shell_read(f){return read(f)};if(readBinary=function readBinary(f){var data;if(typeof readbuffer==="function")return new Uint8Array(readbuffer(f));return data=read(f,"binary"),assert(typeof data==="object"),data},typeof scriptArgs<"u")arguments_=scriptArgs;else if(typeof arguments<"u")arguments_=arguments;if(typeof quit==="function")quit_=function(status){quit(status)};if(typeof print<"u"){if(typeof console>"u")console={};console.log=print,console.warn=console.error=typeof printErr<"u"?printErr:print}}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER)scriptDirectory=self.location.href;else if(typeof document<"u"&&document.currentScript)scriptDirectory=document.currentScript.src;if(scriptDirectory.indexOf("blob:")!==0)scriptDirectory=scriptDirectory.substr(0,scriptDirectory.lastIndexOf("/")+1);else scriptDirectory="";{if(read_=function(url){var xhr=new XMLHttpRequest;return xhr.open("GET",url,!1),xhr.send(null),xhr.responseText},ENVIRONMENT_IS_WORKER)readBinary=function(url){var xhr=new XMLHttpRequest;return xhr.open("GET",url,!1),xhr.responseType="arraybuffer",xhr.send(null),new Uint8Array(xhr.response)};readAsync=function(url,onload,onerror){var xhr=new XMLHttpRequest;xhr.open("GET",url,!0),xhr.responseType="arraybuffer",xhr.onload=function(){if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}onerror()},xhr.onerror=onerror,xhr.send(null)}}setWindowTitle=function(title){document.title=title}}var out=Module2.print||console.log.bind(console),err=Module2.printErr||console.warn.bind(console);for(key in moduleOverrides)if(moduleOverrides.hasOwnProperty(key))Module2[key]=moduleOverrides[key];moduleOverrides=null;if(Module2.arguments)arguments_=Module2.arguments;if(Module2.thisProgram)thisProgram=Module2.thisProgram;if(Module2.quit)quit_=Module2.quit;var wasmBinary;if(Module2.wasmBinary)wasmBinary=Module2.wasmBinary;var noExitRuntime=Module2.noExitRuntime||!0;if(typeof WebAssembly!=="object")abort("no native wasm support detected");var wasmMemory,ABORT=!1,EXITSTATUS;function assert(condition,text){if(!condition)abort("Assertion failed: "+text)}var ALLOC_NORMAL=0,ALLOC_STACK=1;function allocate(slab,allocator){var ret;if(allocator==ALLOC_STACK)ret=stackAlloc(slab.length);else ret=_malloc(slab.length);if(slab.subarray||slab.slice)HEAPU8.set(slab,ret);else HEAPU8.set(new Uint8Array(slab),ret);return ret}var UTF8Decoder=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function UTF8ArrayToString(heap,idx,maxBytesToRead){var endIdx=idx+maxBytesToRead,endPtr=idx;while(heap[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heap.subarray&&UTF8Decoder)return UTF8Decoder.decode(heap.subarray(idx,endPtr));else{var str="";while(idx<endPtr){var u0=heap[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heap[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heap[idx++]&63;if((u0&240)==224)u0=(u0&15)<<12|u1<<6|u2;else u0=(u0&7)<<18|u1<<12|u2<<6|heap[idx++]&63;if(u0<65536)str+=String.fromCharCode(u0);else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}}return str}function UTF8ToString(ptr,maxBytesToRead){return ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):""}function alignUp(x,multiple){if(x%multiple>0)x+=multiple-x%multiple;return x}var buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateGlobalBufferAndViews(buf){buffer=buf,Module2.HEAP8=HEAP8=new Int8Array(buf),Module2.HEAP16=HEAP16=new Int16Array(buf),Module2.HEAP32=HEAP32=new Int32Array(buf),Module2.HEAPU8=HEAPU8=new Uint8Array(buf),Module2.HEAPU16=HEAPU16=new Uint16Array(buf),Module2.HEAPU32=HEAPU32=new Uint32Array(buf),Module2.HEAPF32=HEAPF32=new Float32Array(buf),Module2.HEAPF64=HEAPF64=new Float64Array(buf)}var INITIAL_MEMORY=Module2.INITIAL_MEMORY||16777216,wasmTable,__ATPRERUN__=[],__ATINIT__=[],__ATPOSTRUN__=[],runtimeInitialized=!1;function preRun(){if(Module2.preRun){if(typeof Module2.preRun=="function")Module2.preRun=[Module2.preRun];while(Module2.preRun.length)addOnPreRun(Module2.preRun.shift())}callRuntimeCallbacks(__ATPRERUN__)}function initRuntime(){runtimeInitialized=!0,callRuntimeCallbacks(__ATINIT__)}function postRun(){if(Module2.postRun){if(typeof Module2.postRun=="function")Module2.postRun=[Module2.postRun];while(Module2.postRun.length)addOnPostRun(Module2.postRun.shift())}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnInit(cb){__ATINIT__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}var runDependencies=0,runDependencyWatcher=null,dependenciesFulfilled=null;function addRunDependency(id){if(runDependencies++,Module2.monitorRunDependencies)Module2.monitorRunDependencies(runDependencies)}function removeRunDependency(id){if(runDependencies--,Module2.monitorRunDependencies)Module2.monitorRunDependencies(runDependencies);if(runDependencies==0){if(runDependencyWatcher!==null)clearInterval(runDependencyWatcher),runDependencyWatcher=null;if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null,callback()}}}Module2.preloadedImages={};Module2.preloadedAudios={};function abort(what){if(Module2.onAbort)Module2.onAbort(what);what+="",err(what),ABORT=!0,EXITSTATUS=1,what="abort("+what+"). Build with -s ASSERTIONS=1 for more info.";var e=new WebAssembly.RuntimeError(what);throw e}var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return filename.startsWith(dataURIPrefix)}function isFileURI(filename){return filename.startsWith("file://")}var wasmBinaryFile="argon2.wasm";if(!isDataURI(wasmBinaryFile))wasmBinaryFile=locateFile(wasmBinaryFile);function getBinary(file){try{if(file==wasmBinaryFile&&wasmBinary)return new Uint8Array(wasmBinary);if(readBinary)return readBinary(file);else throw"both async and sync fetching of the wasm failed"}catch(err2){abort(err2)}}function getBinaryPromise(){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)){if(typeof fetch==="function"&&!isFileURI(wasmBinaryFile))return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){if(!response.ok)throw"failed to load wasm binary file at '"+wasmBinaryFile+"'";return response.arrayBuffer()}).catch(function(){return getBinary(wasmBinaryFile)});else if(readAsync)return new Promise(function(resolve2,reject){readAsync(wasmBinaryFile,function(response){resolve2(new Uint8Array(response))},reject)})}return Promise.resolve().then(function(){return getBinary(wasmBinaryFile)})}function createWasm(){var info={a:asmLibraryArg};function receiveInstance(instance,module2){var exports3=instance.exports;Module2.asm=exports3,wasmMemory=Module2.asm.c,updateGlobalBufferAndViews(wasmMemory.buffer),wasmTable=Module2.asm.k,addOnInit(Module2.asm.d),removeRunDependency("wasm-instantiate")}addRunDependency("wasm-instantiate");function receiveInstantiationResult(result){receiveInstance(result.instance)}function instantiateArrayBuffer(receiver){return getBinaryPromise().then(function(binary){var result=WebAssembly.instantiate(binary,info);return result}).then(receiver,function(reason){err("failed to asynchronously prepare wasm: "+reason),abort(reason)})}function instantiateAsync(){if(!wasmBinary&&typeof WebAssembly.instantiateStreaming==="function"&&!isDataURI(wasmBinaryFile)&&!isFileURI(wasmBinaryFile)&&typeof fetch==="function")return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){var result=WebAssembly.instantiateStreaming(response,info);return result.then(receiveInstantiationResult,function(reason){return err("wasm streaming compile failed: "+reason),err("falling back to ArrayBuffer instantiation"),instantiateArrayBuffer(receiveInstantiationResult)})});else return instantiateArrayBuffer(receiveInstantiationResult)}if(Module2.instantiateWasm)try{var exports2=Module2.instantiateWasm(info,receiveInstance);return exports2}catch(e){return err("Module.instantiateWasm callback failed with error: "+e),!1}return instantiateAsync(),{}}function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback=="function"){callback(Module2);continue}var func=callback.func;if(typeof func==="number")if(callback.arg===void 0)wasmTable.get(func)();else wasmTable.get(func)(callback.arg);else func(callback.arg===void 0?null:callback.arg)}}function _emscripten_memcpy_big(dest,src,num){HEAPU8.copyWithin(dest,src,src+num)}function emscripten_realloc_buffer(size){try{return wasmMemory.grow(size-buffer.byteLength+65535>>>16),updateGlobalBufferAndViews(wasmMemory.buffer),1}catch(e){}}function _emscripten_resize_heap(requestedSize){var oldSize=HEAPU8.length;requestedSize=requestedSize>>>0;var maxHeapSize=2147418112;if(requestedSize>maxHeapSize)return!1;for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+0.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignUp(Math.max(requestedSize,overGrownHeapSize),65536)),replacement=emscripten_realloc_buffer(newSize);if(replacement)return!0}return!1}var asmLibraryArg={a:_emscripten_memcpy_big,b:_emscripten_resize_heap},asm=createWasm(),___wasm_call_ctors=Module2.___wasm_call_ctors=function(){return(___wasm_call_ctors=Module2.___wasm_call_ctors=Module2.asm.d).apply(null,arguments)},_argon2_hash=Module2._argon2_hash=function(){return(_argon2_hash=Module2._argon2_hash=Module2.asm.e).apply(null,arguments)},_malloc=Module2._malloc=function(){return(_malloc=Module2._malloc=Module2.asm.f).apply(null,arguments)},_free=Module2._free=function(){return(_free=Module2._free=Module2.asm.g).apply(null,arguments)},_argon2_verify=Module2._argon2_verify=function(){return(_argon2_verify=Module2._argon2_verify=Module2.asm.h).apply(null,arguments)},_argon2_error_message=Module2._argon2_error_message=function(){return(_argon2_error_message=Module2._argon2_error_message=Module2.asm.i).apply(null,arguments)},_argon2_encodedlen=Module2._argon2_encodedlen=function(){return(_argon2_encodedlen=Module2._argon2_encodedlen=Module2.asm.j).apply(null,arguments)},_argon2_hash_ext=Module2._argon2_hash_ext=function(){return(_argon2_hash_ext=Module2._argon2_hash_ext=Module2.asm.l).apply(null,arguments)},_argon2_verify_ext=Module2._argon2_verify_ext=function(){return(_argon2_verify_ext=Module2._argon2_verify_ext=Module2.asm.m).apply(null,arguments)},stackAlloc=Module2.stackAlloc=function(){return(stackAlloc=Module2.stackAlloc=Module2.asm.n).apply(null,arguments)};Module2.allocate=allocate;Module2.UTF8ToString=UTF8ToString;Module2.ALLOC_NORMAL=ALLOC_NORMAL;var calledRun;function ExitStatus(status){this.name="ExitStatus",this.message="Program terminated with exit("+status+")",this.status=status}dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller};function run(args){if(args=args||arguments_,runDependencies>0)return;if(preRun(),runDependencies>0)return;function doRun(){if(calledRun)return;if(calledRun=!0,Module2.calledRun=!0,ABORT)return;if(initRuntime(),Module2.onRuntimeInitialized)Module2.onRuntimeInitialized();postRun()}if(Module2.setStatus)Module2.setStatus("Running..."),setTimeout(function(){setTimeout(function(){Module2.setStatus("")},1),doRun()},1);else doRun()}Module2.run=run;if(Module2.preInit){if(typeof Module2.preInit=="function")Module2.preInit=[Module2.preInit];while(Module2.preInit.length>0)Module2.preInit.pop()()}run();if(typeof module<"u")module.exports=Module2;Module2.unloadRuntime=function(){if(typeof self<"u")delete self.Module;if(Module2=jsModule=wasmMemory=wasmTable=asm=buffer=HEAP8=HEAPU8=HEAP16=HEAPU16=HEAP32=HEAPU32=HEAPF32=HEAPF64=void 0,typeof module<"u")delete module.exports}});var require_argon22=__commonJS((exports,module)=>{module.exports="./argon2.wasm"});var require_argon23=__commonJS((exports,module)=>{(function(root,factory){if(typeof define==="function"&&define.amd)define([],factory);else if(typeof module==="object"&&module.exports)module.exports=factory();else root.argon2=factory()})(typeof self<"u"?self:exports,function(){let global=typeof self<"u"?self:this,ArgonType={Argon2d:0,Argon2i:1,Argon2id:2};function loadModule(mem){if(loadModule._promise)return loadModule._promise;if(loadModule._module)return Promise.resolve(loadModule._module);let promise;if(global.process&&global.process.versions&&global.process.versions.node)promise=loadWasmModule().then((Module2)=>new Promise((resolve2)=>{Module2.postRun=()=>resolve2(Module2)}));else promise=loadWasmBinary().then((wasmBinary)=>{let wasmMemory=mem?createWasmMemory(mem):void 0;return initWasm(wasmBinary,wasmMemory)});return loadModule._promise=promise,promise.then((Module2)=>{return loadModule._module=Module2,delete loadModule._promise,Module2})}function initWasm(wasmBinary,wasmMemory){return new Promise((resolve2)=>{return global.Module={wasmBinary,wasmMemory,postRun(){resolve2(Module)}},loadWasmModule()})}function loadWasmModule(){if(global.loadArgon2WasmModule)return global.loadArgon2WasmModule();return Promise.resolve(require_argon2())}function loadWasmBinary(){if(global.loadArgon2WasmBinary)return global.loadArgon2WasmBinary();return Promise.resolve(require_argon22()).then((wasmModule)=>{return decodeWasmBinary(wasmModule)})}function decodeWasmBinary(base64){let text=atob(base64),binary=new Uint8Array(new ArrayBuffer(text.length));for(let i=0;i<text.length;i++)binary[i]=text.charCodeAt(i);return binary}function createWasmMemory(mem){let initialMemory=Math.min(Math.max(Math.ceil(mem*1024/65536),256)+256,32767);return new WebAssembly.Memory({initial:initialMemory,maximum:32767})}function allocateArray(Module2,arr){return Module2.allocate(arr,"i8",Module2.ALLOC_NORMAL)}function allocateArrayStr(Module2,arr){let nullTerminatedArray=new Uint8Array([...arr,0]);return allocateArray(Module2,nullTerminatedArray)}function encodeUtf8(str){if(typeof str!=="string")return str;if(typeof TextEncoder==="function")return new TextEncoder().encode(str);else if(typeof Buffer==="function")return Buffer.from(str);else throw Error("Don't know how to encode UTF8")}function argon2Hash(params){let mCost=params.mem||1024;return loadModule(mCost).then((Module2)=>{let tCost=params.time||1,parallelism=params.parallelism||1,pwdEncoded=encodeUtf8(params.pass),pwd=allocateArrayStr(Module2,pwdEncoded),pwdlen=pwdEncoded.length,saltEncoded=encodeUtf8(params.salt),salt=allocateArrayStr(Module2,saltEncoded),saltlen=saltEncoded.length,argon2Type=params.type||ArgonType.Argon2d,hash=Module2.allocate(Array(params.hashLen||24),"i8",Module2.ALLOC_NORMAL),secret=params.secret?allocateArray(Module2,params.secret):0,secretlen=params.secret?params.secret.byteLength:0,ad=params.ad?allocateArray(Module2,params.ad):0,adlen=params.ad?params.ad.byteLength:0,hashlen=params.hashLen||24,encodedlen=Module2._argon2_encodedlen(tCost,mCost,parallelism,saltlen,hashlen,argon2Type),encoded=Module2.allocate(Array(encodedlen+1),"i8",Module2.ALLOC_NORMAL),version=19,err,res;try{res=Module2._argon2_hash_ext(tCost,mCost,parallelism,pwd,pwdlen,salt,saltlen,hash,hashlen,encoded,encodedlen,argon2Type,secret,secretlen,ad,adlen,19)}catch(e){err=e}let result;if(res===0&&!err){let hashStr="",hashArr=new Uint8Array(hashlen);for(let i=0;i<hashlen;i++){let byte=Module2.HEAP8[hash+i];hashArr[i]=byte,hashStr+=("0"+(255&byte).toString(16)).slice(-2)}let encodedStr=Module2.UTF8ToString(encoded);result={hash:hashArr,hashHex:hashStr,encoded:encodedStr}}else{try{if(!err)err=Module2.UTF8ToString(Module2._argon2_error_message(res))}catch(e){}result={message:err,code:res}}try{if(Module2._free(pwd),Module2._free(salt),Module2._free(hash),Module2._free(encoded),ad)Module2._free(ad);if(secret)Module2._free(secret)}catch(e){}if(err)throw result;else return result})}function argon2Verify(params){return loadModule().then((Module2)=>{let pwdEncoded=encodeUtf8(params.pass),pwd=allocateArrayStr(Module2,pwdEncoded),pwdlen=pwdEncoded.length,secret=params.secret?allocateArray(Module2,params.secret):0,secretlen=params.secret?params.secret.byteLength:0,ad=params.ad?allocateArray(Module2,params.ad):0,adlen=params.ad?params.ad.byteLength:0,encEncoded=encodeUtf8(params.encoded),enc=allocateArrayStr(Module2,encEncoded),argon2Type=params.type;if(argon2Type===void 0){let typeStr=params.encoded.split("$")[1];if(typeStr)typeStr=typeStr.replace("a","A"),argon2Type=ArgonType[typeStr]||ArgonType.Argon2d}let err,res;try{res=Module2._argon2_verify_ext(enc,pwd,pwdlen,secret,secretlen,ad,adlen,argon2Type)}catch(e){err=e}let result;if(res||err){try{if(!err)err=Module2.UTF8ToString(Module2._argon2_error_message(res))}catch(e){}result={message:err,code:res}}try{Module2._free(pwd),Module2._free(enc)}catch(e){}if(err)throw result;else return result})}function unloadRuntime(){if(loadModule._module)loadModule._module.unloadRuntime(),delete loadModule._promise,delete loadModule._module}return{ArgonType,hash:argon2Hash,verify:argon2Verify,unloadRuntime}})});class CryptitError extends Error{constructor(message){super(message);Object.setPrototypeOf(this,new.target.prototype),this.name=new.target.name,this.stack=void 0}}class InvalidHeaderError extends CryptitError{}class DecodingError extends CryptitError{}class EncodingError extends CryptitError{}class SchemeError extends CryptitError{}class HeaderDecodeError extends CryptitError{}class KeyDerivationError extends CryptitError{}class EncryptionError extends CryptitError{}class DecryptionError extends CryptitError{}class SchemeRegistry{static byId=new Map;static register(s){if(this.byId.has(s.id))throw new SchemeError(`Scheme ${s.id} already registered`);this.byId.set(s.id,s)}static get(id){let v=this.byId.get(id);if(!v)throw new SchemeError(`Unknown scheme: ${id}`);return v}static get current(){return this.get(0)}}class BaseAEADWithPadAAD{p;padding=null;headerAAD=new Uint8Array(0);padAADMode="auto";padAlign=8;allowLegacyAADFallback=!0;legacyFallbackPolicy="auto";tryEmptyAADOnLegacyFallback=!1;setLegacyAADFallback(opts={}){if(opts.enabled!==void 0)this.allowLegacyAADFallback=!!opts.enabled;if(opts.policy)this.legacyFallbackPolicy=opts.policy;if(opts.tryEmptyAAD!==void 0)this.tryEmptyAADOnLegacyFallback=!!opts.tryEmptyAAD}static PAD_AAD_MAGIC=new Uint8Array([80,65,68,49]);static PAD_AAD_VER=1;constructor(p){this.p=p}setPaddingScheme(s){this.padding=s}setPaddingAADMode(mode){this.padAADMode=mode}setPaddingAlign(n){if(!Number.isInteger(n)||n<1||n>255)throw Error("padAlign must be 1..255");this.padAlign=n|0}setAAD(aadData){this.headerAAD=aadData&&aadData.byteLength?new Uint8Array(aadData):new Uint8Array(0)}async encryptChunk(plain){let effective=this.resolveMode(),toEncrypt=plain;if(effective==="require"){if(!this.padding)throw Error("Padding required but no scheme set");let rng=(n)=>this.p.getRandomValues(new Uint8Array(n));toEncrypt=this.padding.pad(plain,rng,this.padAlign)}let aad=this.composeAAD(effective),out=await this.encryptWithAAD(toEncrypt,aad);if(plain.fill(0),toEncrypt!==plain)toEncrypt.fill(0);return out}async decryptChunk(data){let effective=this.resolveMode(),newAAD=this.composeAAD(effective);try{let plain=await this.decryptWithAAD(data,newAAD);return this.enforcePolicyAfterDecrypt(plain,effective)}catch(primaryErr){if(!this.allowLegacyAADFallback)throw primaryErr;let candidates=[];if(this.headerAAD.length)candidates.push(this.headerAAD);if(this.tryEmptyAADOnLegacyFallback)candidates.push(new Uint8Array(0));let lastErr=primaryErr;for(let legacyAAD of candidates)try{let plainLegacy=await this.decryptWithAAD(data,legacyAAD),legacyMode=this.legacyFallbackPolicy==="auto"?"auto":this.legacyFallbackPolicy;return this.enforcePolicyAfterDecrypt(plainLegacy,legacyMode)}catch(e){lastErr=e}throw lastErr}}enforcePolicyAfterDecrypt(plain,mode){if(!this.padding){if(mode==="require")throw new DecryptionError("Expected padding but no scheme configured");return plain}let{used,plain:unpadded}=this.padding.tryUnpad(plain);if(mode==="require"){if(!used)throw new DecryptionError("Expected padding trailer not found");return new Uint8Array(unpadded)}if(mode==="forbid"){if(used)throw new DecryptionError("Padding forbidden by policy");return plain}return used?new Uint8Array(unpadded):plain}resolveMode(){if(this.padAADMode==="auto")return this.padding?"require":"forbid";return this.padAADMode}buildPadAAD(mode){let modeByte=mode==="require"?0:1,out=new Uint8Array(BaseAEADWithPadAAD.PAD_AAD_MAGIC.length+1+1+1),o=0;return out.set(BaseAEADWithPadAAD.PAD_AAD_MAGIC,o),o+=BaseAEADWithPadAAD.PAD_AAD_MAGIC.length,out[o++]=BaseAEADWithPadAAD.PAD_AAD_VER&255,out[o++]=modeByte,out[o++]=this.padAlign&255,out}composeAAD(mode){let padAAD=this.buildPadAAD(mode);if(!this.headerAAD.length)return padAAD;let out=new Uint8Array(this.headerAAD.length+padAAD.length);return out.set(this.headerAAD,0),out.set(padAAD,this.headerAAD.length),out}}class AESGCM extends BaseAEADWithPadAAD{static IV_LENGTH=12;static TAG_LENGTH=16;IV_LENGTH=AESGCM.IV_LENGTH;TAG_LENGTH=AESGCM.TAG_LENGTH;key=null;constructor(p){super(p)}async setKey(k){this.key=k}zeroKey(){this.key=null}async encryptWithAAD(toEncrypt,aad){let iv=this.p.getRandomValues(new Uint8Array(AESGCM.IV_LENGTH)),params={name:"AES-GCM",iv,additionalData:aad},cipherBuf=await this.p.subtle.encrypt(params,this.requireKey(),toEncrypt),cipher=new Uint8Array(cipherBuf),out=new Uint8Array(iv.length+cipher.length);return out.set(iv,0),out.set(cipher,iv.length),out}async decryptWithAAD(data,aad){if(data.byteLength<AESGCM.IV_LENGTH+AESGCM.TAG_LENGTH)throw new DecryptionError("Invalid ciphertext: too short.");let iv=data.subarray(0,AESGCM.IV_LENGTH),cipher=data.subarray(AESGCM.IV_LENGTH),params={name:"AES-GCM",iv,additionalData:aad};try{let buf=await this.p.subtle.decrypt(params,this.requireKey(),cipher);return new Uint8Array(buf)}catch{throw new DecryptionError("Decryption failed: wrong passphrase or corrupted ciphertext")}}requireKey(){if(!this.key)throw Error("Encryption key not set");return this.key}}/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function isBytes(a){return a instanceof Uint8Array||ArrayBuffer.isView(a)&&a.constructor.name==="Uint8Array"}function abool(b){if(typeof b!=="boolean")throw Error(`boolean expected, not ${b}`)}function anumber(n){if(!Number.isSafeInteger(n)||n<0)throw Error("positive integer expected, got "+n)}function abytes(value,length,title=""){let bytes=isBytes(value),len=value?.length,needsLen=length!==void 0;if(!bytes||needsLen&&len!==length){let prefix=title&&`"${title}" `,ofLen=needsLen?` of length ${length}`:"",got=bytes?`length=${len}`:`type=${typeof value}`;throw Error(prefix+"expected Uint8Array"+ofLen+", got "+got)}return value}function aexists(instance,checkFinished=!0){if(instance.destroyed)throw Error("Hash instance has been destroyed");if(checkFinished&&instance.finished)throw Error("Hash#digest() has already been called")}function aoutput(out,instance){abytes(out,void 0,"output");let min=instance.outputLen;if(out.length<min)throw Error("digestInto() expects output buffer of length at least "+min)}function u32(arr){return new Uint32Array(arr.buffer,arr.byteOffset,Math.floor(arr.byteLength/4))}function clean(...arrays){for(let i=0;i<arrays.length;i++)arrays[i].fill(0)}function createView(arr){return new DataView(arr.buffer,arr.byteOffset,arr.byteLength)}var isLE=(()=>new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68)();function checkOpts(defaults,opts){if(opts==null||typeof opts!=="object")throw Error("options must be defined");return Object.assign(defaults,opts)}function equalBytes(a,b){if(a.length!==b.length)return!1;let diff=0;for(let i=0;i<a.length;i++)diff|=a[i]^b[i];return diff===0}var wrapCipher=(params,constructor)=>{function wrappedCipher(key,...args){if(abytes(key,void 0,"key"),!isLE)throw Error("Non little-endian hardware is not yet supported");if(params.nonceLength!==void 0){let nonce=args[0];abytes(nonce,params.varSizeNonce?void 0:params.nonceLength,"nonce")}let tagl=params.tagLength;if(tagl&&args[1]!==void 0)abytes(args[1],void 0,"AAD");let cipher=constructor(key,...args),checkOutput=(fnLength,output)=>{if(output!==void 0){if(fnLength!==2)throw Error("cipher output not supported");abytes(output,void 0,"output")}},called=!1;return{encrypt(data,output){if(called)throw Error("cannot encrypt() twice with same key + nonce");return called=!0,abytes(data),checkOutput(cipher.encrypt.length,output),cipher.encrypt(data,output)},decrypt(data,output){if(abytes(data),tagl&&data.length<tagl)throw Error('"ciphertext" expected length bigger than tagLength='+tagl);return checkOutput(cipher.decrypt.length,output),cipher.decrypt(data,output)}}}return Object.assign(wrappedCipher,params),wrappedCipher};function getOutput(expectedLength,out,onlyAligned=!0){if(out===void 0)return new Uint8Array(expectedLength);if(out.length!==expectedLength)throw Error('"output" expected Uint8Array of length '+expectedLength+", got: "+out.length);if(onlyAligned&&!isAligned32(out))throw Error("invalid output, must be aligned");return out}function u64Lengths(dataLength,aadLength,isLE2){abool(isLE2);let num=new Uint8Array(16),view=createView(num);return view.setBigUint64(0,BigInt(aadLength),isLE2),view.setBigUint64(8,BigInt(dataLength),isLE2),num}function isAligned32(bytes){return bytes.byteOffset%4===0}function copyBytes(bytes){return Uint8Array.from(bytes)}var encodeStr=(str)=>Uint8Array.from(str.split(""),(c)=>c.charCodeAt(0)),sigma16=encodeStr("expand 16-byte k"),sigma32=encodeStr("expand 32-byte k"),sigma16_32=u32(sigma16),sigma32_32=u32(sigma32);function rotl(a,b){return a<<b|a>>>32-b}function isAligned322(b){return b.byteOffset%4===0}var BLOCK_LEN=64,BLOCK_LEN32=16,MAX_COUNTER=4294967295,U32_EMPTY=Uint32Array.of();function runCipher(core,sigma,key,nonce,data,output,counter,rounds){let len=data.length,block=new Uint8Array(BLOCK_LEN),b32=u32(block),isAligned=isAligned322(data)&&isAligned322(output),d32=isAligned?u32(data):U32_EMPTY,o32=isAligned?u32(output):U32_EMPTY;for(let pos=0;pos<len;counter++){if(core(sigma,key,nonce,b32,counter,rounds),counter>=MAX_COUNTER)throw Error("arx: counter overflow");let take=Math.min(BLOCK_LEN,len-pos);if(isAligned&&take===BLOCK_LEN){let pos32=pos/4;if(pos%4!==0)throw Error("arx: invalid block position");for(let j=0,posj;j<BLOCK_LEN32;j++)posj=pos32+j,o32[posj]=d32[posj]^b32[j];pos+=BLOCK_LEN;continue}for(let j=0,posj;j<take;j++)posj=pos+j,output[posj]=data[posj]^block[j];pos+=take}}function createCipher(core,opts){let{allowShortKeys,extendNonceFn,counterLength,counterRight,rounds}=checkOpts({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},opts);if(typeof core!=="function")throw Error("core must be a function");return anumber(counterLength),anumber(rounds),abool(counterRight),abool(allowShortKeys),(key,nonce,data,output,counter=0)=>{abytes(key,void 0,"key"),abytes(nonce,void 0,"nonce"),abytes(data,void 0,"data");let len=data.length;if(output===void 0)output=new Uint8Array(len);if(abytes(output,void 0,"output"),anumber(counter),counter<0||counter>=MAX_COUNTER)throw Error("arx: counter overflow");if(output.length<len)throw Error(`arx: output (${output.length}) is shorter than data (${len})`);let toClean=[],l=key.length,k,sigma;if(l===32)toClean.push(k=copyBytes(key)),sigma=sigma32_32;else if(l===16&&allowShortKeys)k=new Uint8Array(32),k.set(key),k.set(key,16),sigma=sigma16_32,toClean.push(k);else throw abytes(key,32,"arx key"),Error("invalid key size");if(!isAligned322(nonce))toClean.push(nonce=copyBytes(nonce));let k32=u32(k);if(extendNonceFn){if(nonce.length!==24)throw Error("arx: extended nonce must be 24 bytes");extendNonceFn(sigma,k32,u32(nonce.subarray(0,16)),k32),nonce=nonce.subarray(16)}let nonceNcLen=16-counterLength;if(nonceNcLen!==nonce.length)throw Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);if(nonceNcLen!==12){let nc=new Uint8Array(12);nc.set(nonce,counterRight?0:12-nonce.length),nonce=nc,toClean.push(nonce)}let n32=u32(nonce);return runCipher(core,sigma,k32,n32,data,output,counter,rounds),clean(...toClean),output}}function u8to16(a,i){return a[i++]&255|(a[i++]&255)<<8}class Poly1305{blockLen=16;outputLen=16;buffer=new Uint8Array(16);r=new Uint16Array(10);h=new Uint16Array(10);pad=new Uint16Array(8);pos=0;finished=!1;constructor(key){key=copyBytes(abytes(key,32,"key"));let t0=u8to16(key,0),t1=u8to16(key,2),t2=u8to16(key,4),t3=u8to16(key,6),t4=u8to16(key,8),t5=u8to16(key,10),t6=u8to16(key,12),t7=u8to16(key,14);this.r[0]=t0&8191,this.r[1]=(t0>>>13|t1<<3)&8191,this.r[2]=(t1>>>10|t2<<6)&7939,this.r[3]=(t2>>>7|t3<<9)&8191,this.r[4]=(t3>>>4|t4<<12)&255,this.r[5]=t4>>>1&8190,this.r[6]=(t4>>>14|t5<<2)&8191,this.r[7]=(t5>>>11|t6<<5)&8065,this.r[8]=(t6>>>8|t7<<8)&8191,this.r[9]=t7>>>5&127;for(let i=0;i<8;i++)this.pad[i]=u8to16(key,16+2*i)}process(data,offset,isLast=!1){let hibit=isLast?0:2048,{h,r}=this,r0=r[0],r1=r[1],r2=r[2],r3=r[3],r4=r[4],r5=r[5],r6=r[6],r7=r[7],r8=r[8],r9=r[9],t0=u8to16(data,offset+0),t1=u8to16(data,offset+2),t2=u8to16(data,offset+4),t3=u8to16(data,offset+6),t4=u8to16(data,offset+8),t5=u8to16(data,offset+10),t6=u8to16(data,offset+12),t7=u8to16(data,offset+14),h0=h[0]+(t0&8191),h1=h[1]+((t0>>>13|t1<<3)&8191),h2=h[2]+((t1>>>10|t2<<6)&8191),h3=h[3]+((t2>>>7|t3<<9)&8191),h4=h[4]+((t3>>>4|t4<<12)&8191),h5=h[5]+(t4>>>1&8191),h6=h[6]+((t4>>>14|t5<<2)&8191),h7=h[7]+((t5>>>11|t6<<5)&8191),h8=h[8]+((t6>>>8|t7<<8)&8191),h9=h[9]+(t7>>>5|hibit),c=0,d0=c+h0*r0+h1*(5*r9)+h2*(5*r8)+h3*(5*r7)+h4*(5*r6);c=d0>>>13,d0&=8191,d0+=h5*(5*r5)+h6*(5*r4)+h7*(5*r3)+h8*(5*r2)+h9*(5*r1),c+=d0>>>13,d0&=8191;let d1=c+h0*r1+h1*r0+h2*(5*r9)+h3*(5*r8)+h4*(5*r7);c=d1>>>13,d1&=8191,d1+=h5*(5*r6)+h6*(5*r5)+h7*(5*r4)+h8*(5*r3)+h9*(5*r2),c+=d1>>>13,d1&=8191;let d2=c+h0*r2+h1*r1+h2*r0+h3*(5*r9)+h4*(5*r8);c=d2>>>13,d2&=8191,d2+=h5*(5*r7)+h6*(5*r6)+h7*(5*r5)+h8*(5*r4)+h9*(5*r3),c+=d2>>>13,d2&=8191;let d3=c+h0*r3+h1*r2+h2*r1+h3*r0+h4*(5*r9);c=d3>>>13,d3&=8191,d3+=h5*(5*r8)+h6*(5*r7)+h7*(5*r6)+h8*(5*r5)+h9*(5*r4),c+=d3>>>13,d3&=8191;let d4=c+h0*r4+h1*r3+h2*r2+h3*r1+h4*r0;c=d4>>>13,d4&=8191,d4+=h5*(5*r9)+h6*(5*r8)+h7*(5*r7)+h8*(5*r6)+h9*(5*r5),c+=d4>>>13,d4&=8191;let d5=c+h0*r5+h1*r4+h2*r3+h3*r2+h4*r1;c=d5>>>13,d5&=8191,d5+=h5*r0+h6*(5*r9)+h7*(5*r8)+h8*(5*r7)+h9*(5*r6),c+=d5>>>13,d5&=8191;let d6=c+h0*r6+h1*r5+h2*r4+h3*r3+h4*r2;c=d6>>>13,d6&=8191,d6+=h5*r1+h6*r0+h7*(5*r9)+h8*(5*r8)+h9*(5*r7),c+=d6>>>13,d6&=8191;let d7=c+h0*r7+h1*r6+h2*r5+h3*r4+h4*r3;c=d7>>>13,d7&=8191,d7+=h5*r2+h6*r1+h7*r0+h8*(5*r9)+h9*(5*r8),c+=d7>>>13,d7&=8191;let d8=c+h0*r8+h1*r7+h2*r6+h3*r5+h4*r4;c=d8>>>13,d8&=8191,d8+=h5*r3+h6*r2+h7*r1+h8*r0+h9*(5*r9),c+=d8>>>13,d8&=8191;let d9=c+h0*r9+h1*r8+h2*r7+h3*r6+h4*r5;c=d9>>>13,d9&=8191,d9+=h5*r4+h6*r3+h7*r2+h8*r1+h9*r0,c+=d9>>>13,d9&=8191,c=(c<<2)+c|0,c=c+d0|0,d0=c&8191,c=c>>>13,d1+=c,h[0]=d0,h[1]=d1,h[2]=d2,h[3]=d3,h[4]=d4,h[5]=d5,h[6]=d6,h[7]=d7,h[8]=d8,h[9]=d9}finalize(){let{h,pad}=this,g=new Uint16Array(10),c=h[1]>>>13;h[1]&=8191;for(let i=2;i<10;i++)h[i]+=c,c=h[i]>>>13,h[i]&=8191;h[0]+=c*5,c=h[0]>>>13,h[0]&=8191,h[1]+=c,c=h[1]>>>13,h[1]&=8191,h[2]+=c,g[0]=h[0]+5,c=g[0]>>>13,g[0]&=8191;for(let i=1;i<10;i++)g[i]=h[i]+c,c=g[i]>>>13,g[i]&=8191;g[9]-=8192;let mask=(c^1)-1;for(let i=0;i<10;i++)g[i]&=mask;mask=~mask;for(let i=0;i<10;i++)h[i]=h[i]&mask|g[i];h[0]=(h[0]|h[1]<<13)&65535,h[1]=(h[1]>>>3|h[2]<<10)&65535,h[2]=(h[2]>>>6|h[3]<<7)&65535,h[3]=(h[3]>>>9|h[4]<<4)&65535,h[4]=(h[4]>>>12|h[5]<<1|h[6]<<14)&65535,h[5]=(h[6]>>>2|h[7]<<11)&65535,h[6]=(h[7]>>>5|h[8]<<8)&65535,h[7]=(h[8]>>>8|h[9]<<5)&65535;let f=h[0]+pad[0];h[0]=f&65535;for(let i=1;i<8;i++)f=(h[i]+pad[i]|0)+(f>>>16)|0,h[i]=f&65535;clean(g)}update(data){aexists(this),abytes(data),data=copyBytes(data);let{buffer,blockLen}=this,len=data.length;for(let pos=0;pos<len;){let take=Math.min(blockLen-this.pos,len-pos);if(take===blockLen){for(;blockLen<=len-pos;pos+=blockLen)this.process(data,pos);continue}if(buffer.set(data.subarray(pos,pos+take),this.pos),this.pos+=take,pos+=take,this.pos===blockLen)this.process(buffer,0,!1),this.pos=0}return this}destroy(){clean(this.h,this.r,this.buffer,this.pad)}digestInto(out){aexists(this),aoutput(out,this),this.finished=!0;let{buffer,h}=this,{pos}=this;if(pos){buffer[pos++]=1;for(;pos<16;pos++)buffer[pos]=0;this.process(buffer,0,!0)}this.finalize();let opos=0;for(let i=0;i<8;i++)out[opos++]=h[i]>>>0,out[opos++]=h[i]>>>8;return out}digest(){let{buffer,outputLen}=this;this.digestInto(buffer);let res=buffer.slice(0,outputLen);return this.destroy(),res}}function wrapConstructorWithKey(hashCons){let hashC=(msg,key)=>hashCons(key).update(msg).digest(),tmp=hashCons(new Uint8Array(32));return hashC.outputLen=tmp.outputLen,hashC.blockLen=tmp.blockLen,hashC.create=(key)=>hashCons(key),hashC}var poly1305=(()=>wrapConstructorWithKey((key)=>new Poly1305(key)))();function chachaCore(s,k,n,out,cnt,rounds=20){let y00=s[0],y01=s[1],y02=s[2],y03=s[3],y04=k[0],y05=k[1],y06=k[2],y07=k[3],y08=k[4],y09=k[5],y10=k[6],y11=k[7],y12=cnt,y13=n[0],y14=n[1],y15=n[2],x00=y00,x01=y01,x02=y02,x03=y03,x04=y04,x05=y05,x06=y06,x07=y07,x08=y08,x09=y09,x10=y10,x11=y11,x12=y12,x13=y13,x14=y14,x15=y15;for(let r=0;r<rounds;r+=2)x00=x00+x04|0,x12=rotl(x12^x00,16),x08=x08+x12|0,x04=rotl(x04^x08,12),x00=x00+x04|0,x12=rotl(x12^x00,8),x08=x08+x12|0,x04=rotl(x04^x08,7),x01=x01+x05|0,x13=rotl(x13^x01,16),x09=x09+x13|0,x05=rotl(x05^x09,12),x01=x01+x05|0,x13=rotl(x13^x01,8),x09=x09+x13|0,x05=rotl(x05^x09,7),x02=x02+x06|0,x14=rotl(x14^x02,16),x10=x10+x14|0,x06=rotl(x06^x10,12),x02=x02+x06|0,x14=rotl(x14^x02,8),x10=x10+x14|0,x06=rotl(x06^x10,7),x03=x03+x07|0,x15=rotl(x15^x03,16),x11=x11+x15|0,x07=rotl(x07^x11,12),x03=x03+x07|0,x15=rotl(x15^x03,8),x11=x11+x15|0,x07=rotl(x07^x11,7),x00=x00+x05|0,x15=rotl(x15^x00,16),x10=x10+x15|0,x05=rotl(x05^x10,12),x00=x00+x05|0,x15=rotl(x15^x00,8),x10=x10+x15|0,x05=rotl(x05^x10,7),x01=x01+x06|0,x12=rotl(x12^x01,16),x11=x11+x12|0,x06=rotl(x06^x11,12),x01=x01+x06|0,x12=rotl(x12^x01,8),x11=x11+x12|0,x06=rotl(x06^x11,7),x02=x02+x07|0,x13=rotl(x13^x02,16),x08=x08+x13|0,x07=rotl(x07^x08,12),x02=x02+x07|0,x13=rotl(x13^x02,8),x08=x08+x13|0,x07=rotl(x07^x08,7),x03=x03+x04|0,x14=rotl(x14^x03,16),x09=x09+x14|0,x04=rotl(x04^x09,12),x03=x03+x04|0,x14=rotl(x14^x03,8),x09=x09+x14|0,x04=rotl(x04^x09,7);let oi=0;out[oi++]=y00+x00|0,out[oi++]=y01+x01|0,out[oi++]=y02+x02|0,out[oi++]=y03+x03|0,out[oi++]=y04+x04|0,out[oi++]=y05+x05|0,out[oi++]=y06+x06|0,out[oi++]=y07+x07|0,out[oi++]=y08+x08|0,out[oi++]=y09+x09|0,out[oi++]=y10+x10|0,out[oi++]=y11+x11|0,out[oi++]=y12+x12|0,out[oi++]=y13+x13|0,out[oi++]=y14+x14|0,out[oi++]=y15+x15|0}function hchacha(s,k,i,out){let x00=s[0],x01=s[1],x02=s[2],x03=s[3],x04=k[0],x05=k[1],x06=k[2],x07=k[3],x08=k[4],x09=k[5],x10=k[6],x11=k[7],x12=i[0],x13=i[1],x14=i[2],x15=i[3];for(let r=0;r<20;r+=2)x00=x00+x04|0,x12=rotl(x12^x00,16),x08=x08+x12|0,x04=rotl(x04^x08,12),x00=x00+x04|0,x12=rotl(x12^x00,8),x08=x08+x12|0,x04=rotl(x04^x08,7),x01=x01+x05|0,x13=rotl(x13^x01,16),x09=x09+x13|0,x05=rotl(x05^x09,12),x01=x01+x05|0,x13=rotl(x13^x01,8),x09=x09+x13|0,x05=rotl(x05^x09,7),x02=x02+x06|0,x14=rotl(x14^x02,16),x10=x10+x14|0,x06=rotl(x06^x10,12),x02=x02+x06|0,x14=rotl(x14^x02,8),x10=x10+x14|0,x06=rotl(x06^x10,7),x03=x03+x07|0,x15=rotl(x15^x03,16),x11=x11+x15|0,x07=rotl(x07^x11,12),x03=x03+x07|0,x15=rotl(x15^x03,8),x11=x11+x15|0,x07=rotl(x07^x11,7),x00=x00+x05|0,x15=rotl(x15^x00,16),x10=x10+x15|0,x05=rotl(x05^x10,12),x00=x00+x05|0,x15=rotl(x15^x00,8),x10=x10+x15|0,x05=rotl(x05^x10,7),x01=x01+x06|0,x12=rotl(x12^x01,16),x11=x11+x12|0,x06=rotl(x06^x11,12),x01=x01+x06|0,x12=rotl(x12^x01,8),x11=x11+x12|0,x06=rotl(x06^x11,7),x02=x02+x07|0,x13=rotl(x13^x02,16),x08=x08+x13|0,x07=rotl(x07^x08,12),x02=x02+x07|0,x13=rotl(x13^x02,8),x08=x08+x13|0,x07=rotl(x07^x08,7),x03=x03+x04|0,x14=rotl(x14^x03,16),x09=x09+x14|0,x04=rotl(x04^x09,12),x03=x03+x04|0,x14=rotl(x14^x03,8),x09=x09+x14|0,x04=rotl(x04^x09,7);let oi=0;out[oi++]=x00,out[oi++]=x01,out[oi++]=x02,out[oi++]=x03,out[oi++]=x12,out[oi++]=x13,out[oi++]=x14,out[oi++]=x15}var chacha20=createCipher(chachaCore,{counterRight:!1,counterLength:4,allowShortKeys:!1}),xchacha20=createCipher(chachaCore,{counterRight:!1,counterLength:8,extendNonceFn:hchacha,allowShortKeys:!1});var ZEROS16=new Uint8Array(16),updatePadded=(h,msg)=>{h.update(msg);let leftover=msg.length%16;if(leftover)h.update(ZEROS16.subarray(leftover))},ZEROS32=new Uint8Array(32);function computeTag(fn,key,nonce,ciphertext,AAD){if(AAD!==void 0)abytes(AAD,void 0,"AAD");let authKey=fn(key,nonce,ZEROS32),lengths=u64Lengths(ciphertext.length,AAD?AAD.length:0,!0),h=poly1305.create(authKey);if(AAD)updatePadded(h,AAD);updatePadded(h,ciphertext),h.update(lengths);let res=h.digest();return clean(authKey,lengths),res}var _poly1305_aead=(xorStream)=>(key,nonce,AAD)=>{return{encrypt(plaintext,output){let plength=plaintext.length;output=getOutput(plength+16,output,!1),output.set(plaintext);let oPlain=output.subarray(0,-16);xorStream(key,nonce,oPlain,oPlain,1);let tag=computeTag(xorStream,key,nonce,oPlain,AAD);return output.set(tag,plength),clean(tag),output},decrypt(ciphertext,output){output=getOutput(ciphertext.length-16,output,!1);let data=ciphertext.subarray(0,-16),passedTag=ciphertext.subarray(-16),tag=computeTag(xorStream,key,nonce,data,AAD);if(!equalBytes(passedTag,tag))throw Error("invalid tag");return output.set(ciphertext.subarray(0,-16)),xorStream(key,nonce,output,output,1),clean(tag),output}}},chacha20poly1305=wrapCipher({blockSize:64,nonceLength:12,tagLength:16},_poly1305_aead(chacha20)),xchacha20poly1305=wrapCipher({blockSize:64,nonceLength:24,tagLength:16},_poly1305_aead(xchacha20));class XChaCha20Poly1305 extends BaseAEADWithPadAAD{static IV_LENGTH=24;static TAG_LENGTH=16;IV_LENGTH=XChaCha20Poly1305.IV_LENGTH;TAG_LENGTH=XChaCha20Poly1305.TAG_LENGTH;key=null;constructor(p){super(p)}async setKey(k){this.key=new Uint8Array(await this.p.subtle.exportKey("raw",k))}zeroKey(){if(this.key)this.key.fill(0);this.key=null}async encryptWithAAD(toEncrypt,aad){let nonce=this.p.getRandomValues(new Uint8Array(XChaCha20Poly1305.IV_LENGTH)),cipherAndTag=xchacha20poly1305(this.requireRawKey(),nonce,aad).encrypt(toEncrypt),out=new Uint8Array(nonce.length+cipherAndTag.length);return out.set(nonce,0),out.set(cipherAndTag,nonce.length),out}async decryptWithAAD(data,aad){if(data.byteLength<XChaCha20Poly1305.IV_LENGTH+XChaCha20Poly1305.TAG_LENGTH)throw new DecryptionError("Invalid ciphertext: too short.");let nonce=data.subarray(0,XChaCha20Poly1305.IV_LENGTH),cipherAndTag=data.subarray(XChaCha20Poly1305.IV_LENGTH),cipher=xchacha20poly1305(this.requireRawKey(),nonce,aad);try{return cipher.decrypt(cipherAndTag)}catch{throw new DecryptionError("Decryption failed: wrong passphrase or corrupted ciphertext")}}requireRawKey(){if(!this.key)throw Error("Encryption key not set");return this.key}}var Argon2Browser=__toESM(require_argon23(),1);async function ensureArgon2ModuleHook(){if(typeof window<"u")return;if(globalThis.loadArgon2WasmModule)return;try{let{createRequire}=await import("node:module"),{readFile}=await import("node:fs/promises"),require2=createRequire(import.meta.url),jsPath=require2.resolve("argon2-browser/dist/argon2.js"),wasmPath=require2.resolve("argon2-browser/dist/argon2.wasm");globalThis.loadArgon2WasmModule=async()=>{let wasmBinary=new Uint8Array(await readFile(wasmPath));return globalThis.Module={wasmBinary,locateFile:(p)=>p==="argon2.wasm"?wasmPath:p},require2(jsPath)}}catch{}}async function argon2id(password,salt,opts,env){if(env==="node"){let argon2=await import("@node-rs/argon2"),pwdBuf=typeof password==="string"?Buffer.from(password,"utf8"):Buffer.from(password),digestBase64=(await argon2.hash(pwdBuf,{salt,timeCost:opts.time,memoryCost:opts.mem,parallelism:opts.parallelism,outputLen:32,algorithm:argon2.Algorithm.Argon2id})).split("$").pop();if(!digestBase64)throw Error("Unexpected argon2 hash format");let raw=Buffer.from(digestBase64,"base64");return pwdBuf.fill(0),{hash:new Uint8Array(raw)}}if(env==="browser")return await ensureArgon2ModuleHook(),Argon2Browser.hash({pass:password,salt,time:opts.time,mem:opts.mem,parallelism:opts.parallelism,hashLen:32,type:Argon2Browser.ArgonType.Argon2id}).then((result)=>{if(!result||!result.hash)throw new KeyDerivationError("Failed to produce key derivation");return{hash:result.hash}}).catch((error)=>{let message=error instanceof Error?error.message:typeof error==="string"?error:"Unknown error";throw new KeyDerivationError(`argon2-browser failure: ${message}`)});throw Error(`Unsupported environment: ${env}`)}class Argon2KDF{presets;exportExtractable;name="argon2id";constructor(presets,exportExtractable=!1){this.presets=presets;this.exportExtractable=exportExtractable}async derive(passphrase,salt,difficulty,provider){let{hash:hash2}=await argon2id(passphrase,salt,this.presets[difficulty],provider.isNode?"node":"browser");return provider.subtle.importKey("raw",hash2,{name:"AES-GCM",length:256},this.exportExtractable,["encrypt","decrypt"])}}var DEFAULT_DIFFICULTIES={low:{time:5,mem:65536,parallelism:1},middle:{time:20,mem:65536,parallelism:1},high:{time:40,mem:65536,parallelism:1}},v0={id:0,cipher:AESGCM,kdf:new Argon2KDF(DEFAULT_DIFFICULTIES),saltLengths:{low:12,high:16},difficulties:DEFAULT_DIFFICULTIES,defaultChunkSize:524288};SchemeRegistry.register(v0);var VERSION_1_DIFFICULTIES={low:{time:5,mem:65536,parallelism:2},middle:{time:10,mem:98304,parallelism:4},high:{time:20,mem:98304,parallelism:4}},v1={id:1,cipher:XChaCha20Poly1305,kdf:new Argon2KDF(VERSION_1_DIFFICULTIES,!0),saltLengths:{low:12,high:16},difficulties:VERSION_1_DIFFICULTIES,defaultChunkSize:524288};SchemeRegistry.register(v1);var HEADER_START_BYTE=1;function isNodeLike(){return typeof process<"u"&&typeof process.versions==="object"&&!1}function concat(...chunks){let total=chunks.reduce((n,c)=>n+c.byteLength,0),out=new Uint8Array(total),offset=0;for(let c of chunks)out.set(c,offset),offset+=c.byteLength;return out}function base64Encode(...chunks){try{let data=concat(...chunks);if(isNodeLike())return Buffer.from(data).toString("base64");let binary="";for(let i=0;i<data.length;i++)binary+=String.fromCharCode(data[i]);return btoa(binary)}catch{throw new EncodingError("Base64 Encoding Error")}}function base64Decode(b64){try{if(!/^[A-Za-z0-9+/]+={0,2}$/.test(b64)||b64.length%4!==0)throw Error("Invalid Base64");if(isNodeLike())return new Uint8Array(Buffer.from(b64,"base64"));let bin=atob(b64),out=new Uint8Array(bin.length);for(let i=0;i<bin.length;i++)out[i]=bin.charCodeAt(i);return out}catch{throw new DecodingError(`Invalid Base64: length=${b64.length}, content='${b64.slice(0,12)}…'`)}}function zeroizeString(ref){let len=ref.value.length,fill=Array(len).fill("\x00").join("");ref.value=fill}function encodeHeader(scheme,difficulty,saltStrength,salt,cipher){let diffMap={low:0,middle:1,high:2};if(!(difficulty in diffMap))throw TypeError(`Unsupported difficulty: ${difficulty}`);let diffCode=diffMap[difficulty],infoByte=scheme<<5|(saltStrength==="high"?1:0)<<2|diffCode,header=concat(new Uint8Array([HEADER_START_BYTE,infoByte]),salt);if(cipher)cipher.setAAD(header);return header}function decodeHeader(buf,cipher){if(buf[0]!==HEADER_START_BYTE)throw new InvalidHeaderError("Invalid input format. The input is unknown.");if(buf.length<14)throw new InvalidHeaderError("Invalid input format. Header too short.");try{let info=buf[1],scheme=info>>5,saltStrength=info>>2&1?"high":"low",diffCode=info&3,difficulty=["low","middle","high"][diffCode],saltLen=SchemeRegistry.get(scheme).saltLengths[saltStrength],headerLen=2+saltLen;if(buf.length<headerLen)throw new InvalidHeaderError("Invalid input format. Header truncated.");if(cipher)cipher.setAAD(buf.subarray(0,headerLen));let salt=buf.slice(2,2+saltLen);return{scheme,difficulty,saltStrength,salt,headerLen}}catch(err){throw new HeaderDecodeError(err instanceof Error?err.message:String(err))}}async function ensureUint8Array(src){if(src instanceof Uint8Array)return src;if(src instanceof ArrayBuffer)return new Uint8Array(src);return new Uint8Array(await src.arrayBuffer())}function encodeFrameLen(n){let hdr=new Uint8Array(4);return new DataView(hdr.buffer).setUint32(0,n,!1),hdr}function decodeFrameLen(buf,off=0){if(buf.length-off<4)throw RangeError("Not enough bytes for frame header");return new DataView(buf.buffer,buf.byteOffset+off,4).getUint32(0,!1)}var FRAME_HEADER_BYTES=4;class EncryptTransform{engine;chunkSize;buffer=new Uint8Array(0);constructor(engine,chunkSize=524288){this.engine=engine;this.chunkSize=chunkSize}toTransformStream(){return new TransformStream({transform:async(chunk,ctl)=>{await this.transform(await ensureUint8Array(chunk),ctl)},flush:async(ctl)=>this.flush(ctl)})}async transform(bytes,ctl){if(bytes.length>Math.min(this.chunkSize*4,67108864))throw RangeError(`Input block (${bytes.length} B) exceeds maximum allowed ${Math.min(this.chunkSize*4,67108864)} B`);let combined=new Uint8Array(this.buffer.length+bytes.length);combined.set(this.buffer),combined.set(bytes,this.buffer.length);let offset=0;while(combined.length-offset>=this.chunkSize){let block=combined.slice(offset,offset+this.chunkSize);offset+=this.chunkSize;let encrypted=await this.engine.encryptChunk(block),out=new Uint8Array(FRAME_HEADER_BYTES+encrypted.length);out.set(encodeFrameLen(encrypted.length)),out.set(encrypted,FRAME_HEADER_BYTES),ctl.enqueue(out)}this.buffer=combined.slice(offset)}async flush(ctl){if(!this.buffer.length)return;let encrypted=await this.engine.encryptChunk(this.buffer),out=new Uint8Array(FRAME_HEADER_BYTES+encrypted.length);out.set(encodeFrameLen(encrypted.length)),out.set(encrypted,FRAME_HEADER_BYTES),ctl.enqueue(out),this.buffer=new Uint8Array(0),this.engine.zeroKey()}}class DecryptTransform{engine;chunkSize;buffer=new Uint8Array(0);constructor(engine,chunkSize=524288){this.engine=engine;this.chunkSize=chunkSize}toTransformStream(){return new TransformStream({transform:async(chunk,ctl)=>{await this.transform(await ensureUint8Array(chunk),ctl)},flush:async(ctl)=>this.flush(ctl)})}async transform(bytes,ctl){let combined=new Uint8Array(this.buffer.length+bytes.length);combined.set(this.buffer),combined.set(bytes,this.buffer.length);let offset=0;while(!0){if(combined.length-offset<FRAME_HEADER_BYTES)break;let cipherLen=decodeFrameLen(combined,offset),HARD_LIMIT=67108864,minFrame=this.engine.IV_LENGTH+this.engine.TAG_LENGTH;if(!Number.isInteger(cipherLen)||cipherLen<minFrame||cipherLen>HARD_LIMIT){ctl.error(new DecryptionError(`Invalid frame length ${cipherLen} (min=${minFrame}, max=${HARD_LIMIT})`));return}if(combined.length-offset-FRAME_HEADER_BYTES<cipherLen)break;offset+=FRAME_HEADER_BYTES;let cipher=combined.slice(offset,offset+cipherLen);offset+=cipherLen;try{let plain=await this.engine.decryptChunk(cipher);ctl.enqueue(plain)}catch(err){ctl.error(err instanceof DecryptionError?err:new DecryptionError("Decryption failed: Wrong passphrase or corrupted ciphertext"));return}}this.buffer=combined.slice(offset)}async flush(ctl){await this.transform(new Uint8Array(0),ctl);let leftover=this.buffer.byteLength;if(this.buffer=new Uint8Array(0),this.engine.zeroKey(),leftover!==0){ctl.error(new DecryptionError("Truncated ciphertext: incomplete final frame"));return}}}async function collectStream(rs,prefix){let reader=rs.getReader(),chunks=prefix&&prefix.length?[prefix]:[];try{while(!0){let{value,done}=await reader.read();if(done)break;chunks.push(value)}}finally{reader.releaseLock()}let total=chunks.reduce((n,c)=>n+c.byteLength,0),out=new Uint8Array(total),offset=0;for(let c of chunks)out.set(c,offset),offset+=c.byteLength;return out}class StreamProcessor{engine;chunkSize;constructor(engine,chunkSize=524288){this.engine=engine;this.chunkSize=chunkSize}encryptionStream(){let enc=new EncryptTransform(this.engine,this.chunkSize).toTransformStream();return{writable:enc.writable,readable:enc.readable}}decryptionStream(headerLen){let skip=headerLen,strip=new TransformStream({transform(chunk,ctl){if(skip===0){ctl.enqueue(chunk);return}if(chunk.byteLength<=skip){skip-=chunk.byteLength;return}ctl.enqueue(chunk.slice(skip)),skip=0}}),decryptTs=new DecryptTransform(this.engine,this.chunkSize).toTransformStream();return{writable:strip.writable,readable:strip.readable.pipeThrough(decryptTs)}}async collect(readable,transform,prefix=null){return collectStream(readable.pipeThrough(transform),prefix??void 0)}getEngine(){return this.engine}}function wipe(buf){try{if(buf)buf.fill(0)}catch{}}function hexEncode(u8){let s="";for(let i=0;i<u8.length;i++){let v=u8[i].toString(16).padStart(2,"0");s+=v}return s}class ConvertibleInput{bytes;destroyed=!1;static from(input){if(input instanceof ConvertibleInput)return input;if(typeof input==="string")return new ConvertibleInput(new TextEncoder().encode(input));if(input instanceof Uint8Array)return new ConvertibleInput(input);throw TypeError("ConvertibleInput: unsupported input type")}constructor(bytes){this.bytes=bytes}toUint8Array(){if(this.destroyed)throw Error("ConvertibleInput: already cleared");return this.bytes}clear(){if(!this.destroyed)wipe(this.bytes),this.bytes=new Uint8Array(0),this.destroyed=!0}}class ConvertibleOutput{bytes;destroyed=!1;constructor(bytes){this.bytes=bytes}get uint8array(){if(this.destroyed)throw Error("ConvertibleOutput: already cleared");return this.bytes}get base64(){if(this.destroyed)throw Error("ConvertibleOutput: already cleared");return base64Encode(this.bytes)}get hex(){if(this.destroyed)throw Error("ConvertibleOutput: already cleared");return hexEncode(this.bytes)}get text(){if(this.destroyed)throw Error("ConvertibleOutput: already cleared");return new TextDecoder().decode(this.bytes)}clear(){if(!this.destroyed)wipe(this.bytes),this.bytes=new Uint8Array(0),this.destroyed=!0}toString(){return this.base64}}class MalformedPaddingError extends Error{constructor(msg="Malformed padding"){super(msg)}}class Magic48VerCrc8Padding{static STRUCT_SIZE=8;static MAGIC40=new Uint8Array([196,231,155,173,242]);static VERSION=41;static CRC8_POLY=7;maxPad=Magic48VerCrc8Padding.STRUCT_SIZE+8-1;static ctEqU8(a,b){return(((a|0)^(b|0))&255)===0}static ctEqFixedLen(a,b){let diff=0,len=a.length;for(let i=0;i<len;i++)diff|=a[i]^b[i];return diff===0}crc8(buf){let crc=0;for(let i=0;i<buf.length;i++){crc^=buf[i]&255;for(let b=0;b<8;b++)crc=crc&128?crc<<1^Magic48VerCrc8Padding.CRC8_POLY:crc<<1,crc&=255}return crc&255}computeK(len,align){let s=Magic48VerCrc8Padding.STRUCT_SIZE;if(!Number.isInteger(align)||align<1)throw new MalformedPaddingError("align must be a positive integer");if(s+align-1>255)throw new MalformedPaddingError("align too large for 1-byte LEN");let maxPadForAlign=s+align-1,k=(align-len%align)%align;if(k===0)k=align;while(k<s)k+=align;if(k>maxPadForAlign)throw new MalformedPaddingError("Cannot satisfy alignment within 1-byte LEN");return k}pad(plain,rng,align=8){let s=Magic48VerCrc8Padding.STRUCT_SIZE,k=this.computeK(plain.length,align),rndLen=k-s,out=new Uint8Array(plain.length+k);if(out.set(plain,0),rndLen>0){let rnd=rng(rndLen);if(!rnd||rnd.length!==rndLen)throw new MalformedPaddingError("rng returned wrong length");out.set(rnd,plain.length)}let base=plain.length+rndLen;out.set(Magic48VerCrc8Padding.MAGIC40,base+0),out[base+5]=Magic48VerCrc8Padding.VERSION&255,out[base+6]=k&255;let crcInput=new Uint8Array(7);return crcInput.set(Magic48VerCrc8Padding.MAGIC40,0),crcInput[5]=Magic48VerCrc8Padding.VERSION&255,crcInput[6]=k&255,out[base+7]=this.crc8(crcInput),out}tryUnpad(padded){let s=Magic48VerCrc8Padding.STRUCT_SIZE,fail=()=>({used:!1,plain:padded});if(padded.length<s)return fail();let end=padded.length,crc=padded[end-1]&255,lenByte=padded[end-2]&255,verByte=padded[end-3]&255;if(lenByte<s||lenByte>padded.length)return fail();let magicStart=end-s,magic=padded.subarray(magicStart,magicStart+5);if(!Magic48VerCrc8Padding.ctEqFixedLen(magic,Magic48VerCrc8Padding.MAGIC40))return fail();if(!Magic48VerCrc8Padding.ctEqU8(verByte,Magic48VerCrc8Padding.VERSION&255))return fail();let crcInput=new Uint8Array(7);crcInput.set(Magic48VerCrc8Padding.MAGIC40,0),crcInput[5]=verByte,crcInput[6]=lenByte;let expected=this.crc8(crcInput);if(!Magic48VerCrc8Padding.ctEqU8(expected,crc))return fail();return{used:!0,plain:padded.subarray(0,end-lenByte)}}}function createLogger(level=0,sink=console.info){return{level,log(lvl,msg){if(lvl<=level)sink(`${lvl}| ${msg}`)}}}function assertSliceBounds(total,offset,len){if(offset<0||len<0||offset+len>total)throw RangeError("read() slice exceeds data bounds")}var{promises:fs}=(()=>({}));class ByteSource{src;#buf=null;constructor(src){this.src=src}get length(){if(this.src instanceof Uint8Array)return this.src.byteLength;if(this.src instanceof Blob)return this.src.size;return this.ensureUint8().byteLength}async read(offset,len){if(assertSliceBounds(this.length,offset,len),this.src instanceof Uint8Array)return this.src.slice(offset,offset+len);if(this.src instanceof Blob){let buf=await this.src.slice(offset,offset+len).arrayBuffer();return new Uint8Array(buf)}return this.ensureUint8().slice(offset,offset+len)}ensureUint8(){if(!this.#buf)this.#buf=base64Decode(this.src);return this.#buf}}var _cache=new WeakMap;class EngineManager{static getEngine(provider,schemeId){let perProvider=_cache.get(provider);if(!perProvider)perProvider=new Map,_cache.set(provider,perProvider);let engine=perProvider.get(schemeId);if(engine)return engine;let desc=SchemeRegistry.get(schemeId);return engine={desc,cipher:new desc.cipher(provider),kdf:desc.kdf,chunkSize:desc.defaultChunkSize,provider},perProvider.set(schemeId,engine),engine}static async deriveKey(engine,secret,salt,difficulty){try{let key=await engine.kdf.derive(secret.value,salt,difficulty,engine.provider);await engine.cipher.setKey(key)}catch(err){let msg=err instanceof Error?err.message:String(err);throw new KeyDerivationError(msg)}finally{zeroizeString(secret)}}}class Cryptit{provider;v;cipher;kdf;chunkSize;stream;acceptUnauthenticatedHeader;difficulty;saltStrength;engines=new Map;log;constructor(provider,opt={}){this.provider=provider;this.v=SchemeRegistry.get(opt.scheme??SchemeRegistry.current.id),this.cipher=new this.v.cipher(provider),this.kdf=this.v.kdf,this.chunkSize=this.setChunkSize(opt.chunkSize??this.v.defaultChunkSize),this.stream=new StreamProcessor(this.cipher,this.chunkSize),this.difficulty=opt.difficulty??"middle",this.saltStrength=opt.saltStrength??"high",this.acceptUnauthenticatedHeader=opt.acceptUnauthenticatedHeader??!1,this.log=createLogger(opt.verbose??0,opt.logger)}static async isEncrypted(input){try{return await Cryptit.peekHeader(input),!0}catch{return!1}}static async decodeHeader(input){let hdr=await Cryptit.peekHeader(input),h=decodeHeader(hdr);return{scheme:h.scheme,difficulty:h.difficulty,salt:base64Encode(h.salt),saltBytes:h.salt,saltLength:h.salt.byteLength}}static async headerDecode(input){return this.decodeHeader(input)}static isRandomAccessSource(input){return typeof input==="object"&&input!==null&&typeof input.read==="function"}static async decodeData(input){let src=Cryptit.isRandomAccessSource(input)?input:new ByteSource(input),headSlice=await src.read(0,Math.min(256,src.length)),header=await Cryptit.peekHeader(headSlice),{scheme,headerLen}=decodeHeader(header),totalLen=src.length,remain=totalLen-headerLen;if(remain<0)throw new InvalidHeaderError("Payload underflow");if(remain===0)return{isChunked:!0,chunks:{chunkSize:0,count:0,totalPayload:0}};let first4=await src.read(headerLen,4),firstLen=new DataView(first4.buffer,first4.byteOffset,4).getUint32(0,!1);if(firstLen+4<=remain&&firstLen>=28){let chunkSize=firstLen,offset=headerLen,count=0,total=0;while(offset+4<=totalLen){let lenBuf=await src.read(offset,4),len=new DataView(lenBuf.buffer,lenBuf.byteOffset,4).getUint32(0,!1);if(len===0||offset+4+len>totalLen)break;count++,total+=len,offset+=4+len}return{isChunked:!0,chunks:{chunkSize,count,totalPayload:total}}}let cipher=await src.read(headerLen,remain),ivLen=SchemeRegistry.get(scheme).cipher.IV_LENGTH,tagLen=SchemeRegistry.get(scheme).cipher.TAG_LENGTH;if(cipher.length<ivLen+tagLen)throw new InvalidHeaderError("Ciphertext too short for IV & tag");return{isChunked:!1,payloadLength:remain-ivLen-tagLen,params:{iv:cipher.slice(0,ivLen),ivLength:ivLen,tag:cipher.slice(cipher.length-tagLen),tagLength:tagLen}}}setDifficulty(d){this.difficulty=d}getDifficulty(){return this.difficulty}setScheme(id){this.v=SchemeRegistry.get(id),this.cipher=new this.v.cipher(this.provider),this.kdf=this.v.kdf,this.stream=new StreamProcessor(this.cipher,this.chunkSize)}getScheme(){return this.v.id}setSaltDifficulty(d){this.saltStrength=d}getSaltDifficulty(){return this.saltStrength}setChunkSize(bytes){let rawSize=bytes,size;if(rawSize==null)size=this.v.defaultChunkSize;else{if(size=Number(rawSize),!Number.isInteger(size)||size<1)throw Error(`Invalid chunkSize: ${rawSize}. Must be a positive integer.`);if(size>134217728)throw RangeError("chunkSize cannot exceed 134217728 bytes.")}if(this.chunkSize=size,this.stream)this.stream=new StreamProcessor(this.cipher,this.chunkSize);return size}getChunkSize(){return this.chunkSize}setVerbose(level){this.log.level=level}getVerbose(){return this.log.level}async encryptText(plain,pass){if(pass===null)throw new EncryptionError("Password can't be null");let secret={value:pass};try{if(pass==="")this.log.log(0,"Empty passphrase provided to encryptText");this.log.log(1,`Start text encryption, scheme: ${this.getScheme()}`);let inp=ConvertibleInput.from(plain),plainBytes=inp.toUint8Array();this.log.log(2,"Deriving key for text encryption");let salt=this.genSalt();await this.deriveKey(secret,salt),zeroizeString(secret),pass=null,this.log.log(3,`Salt generated: ${base64Encode(salt)}, KDF difficulty: ${this.difficulty}`),this.log.log(3,"Encoding header");let header=encodeHeader(this.v.id,this.difficulty,this.saltStrength,salt,this.cipher);this.cipher.setPaddingScheme(new Magic48VerCrc8Padding),this.cipher.setPaddingAlign(8),this.cipher.setPaddingAADMode("require"),this.log.log(2,"Encrypting text data");let cipher=await this.cipher.encryptChunk(plainBytes);this.cipher.zeroKey();try{inp.clear()}catch{}let container=concat(header,cipher);return this.log.log(1,"Encryption finished"),new ConvertibleOutput(container)}catch(err){throw new EncryptionError(err instanceof Error?err.message:String(err))}}async decryptText(data,pass){if(pass===null)throw new EncryptionError("Password can't be null");let secret={value:pass};try{if(pass==="")this.log.log(0,"Empty passphrase provided to decryptText");this.log.log(1,`Start text decryption, Version ${this.getScheme()}`);let container;if(typeof data==="string")this.log.log(3,"Decoding Base64 ciphertext"),container=base64Decode(data);else if(data instanceof Uint8Array)container=data;else if(data instanceof ConvertibleInput)container=data.toUint8Array();else throw new DecodingError("Unsupported ciphertext input type");this.log.log(3,"Start header decoding");let hdr=decodeHeader(container);this.log.log(3,"Selecting decryption engine");let engine=EngineManager.getEngine(this.provider,hdr.scheme);this.log.log(2,`Deriving key via engine for scheme: ${hdr.scheme}`),this.log.log(3,`Salt use: ${base64Encode(hdr.salt)}, KDF difficulty: ${hdr.difficulty}`);try{await EngineManager.deriveKey(engine,secret,hdr.salt,hdr.difficulty)}finally{zeroizeString(secret),pass=null}engine.cipher.setPaddingScheme(new Magic48VerCrc8Padding),engine.cipher.setPaddingAlign(8),engine.cipher.setPaddingAADMode("require"),engine.cipher.setLegacyAADFallback({enabled:!0,policy:"auto",tryEmptyAAD:this.acceptUnauthenticatedHeader?!0:!1}),this.log.log(2,"Decrypting text data"),decodeHeader(container,engine.cipher);let plainBytes=await engine.cipher.decryptChunk(container.slice(hdr.headerLen));if(engine.cipher.zeroKey(),data instanceof ConvertibleInput)try{data.clear()}catch{}return this.log.log(1,"Decryption finished"),new ConvertibleOutput(plainBytes)}catch(err){if(err instanceof DecryptionError||err instanceof InvalidHeaderError||err instanceof HeaderDecodeError||err instanceof DecodingError||err instanceof KeyDerivationError)throw err;throw new DecryptionError("Decryption failed: wrong passphrase or corrupted ciphertext")}}async encryptFile(file,pass){if(pass===null)throw new EncryptionError("Password can't be null");let secret={value:pass};try{if(file.size===0){let salt2=this.genSalt();await this.deriveKey(secret,salt2),zeroizeString(secret),pass=null;let header2=encodeHeader(this.v.id,this.difficulty,this.saltStrength,salt2);return new Blob([header2],{type:"application/octet-stream"})}this.log.log(2,"Deriving key for file encryption");let salt=this.genSalt();await this.deriveKey(secret,salt),zeroizeString(secret),pass=null;let header=encodeHeader(this.v.id,this.difficulty,this.saltStrength,salt,this.stream.getEngine());this.stream.getEngine().setPaddingAADMode("forbid");let cipher=await this.stream.collect(file.stream(),new EncryptTransform(this.cipher,this.chunkSize).toTransformStream(),header);return new Blob([cipher],{type:"application/octet-stream"})}catch(err){throw new EncryptionError(err instanceof Error?err.message:String(err))}}async decryptFile(file,pass){if(pass===null)throw new EncryptionError("Password can't be null");let secret={value:pass};try{let header=await Cryptit.peekHeader(file),parsed=decodeHeader(header),engine=EngineManager.getEngine(this.provider,parsed.scheme);try{await EngineManager.deriveKey(engine,secret,parsed.salt,parsed.difficulty)}finally{zeroizeString(secret),pass=null}if(file.size===parsed.headerLen)return new Blob([],{type:"application/octet-stream"});this.log.log(2,"Decrypting file data");let streamProc=new StreamProcessor(engine.cipher,engine.chunkSize);decodeHeader(header,streamProc.getEngine()),engine.cipher.setPaddingAADMode("forbid"),engine.cipher.setLegacyAADFallback({enabled:!0,policy:"auto",tryEmptyAAD:this.acceptUnauthenticatedHeader?!0:!1});let plain=await streamProc.collect(file.slice(parsed.headerLen).stream(),new DecryptTransform(engine.cipher,engine.chunkSize).toTransformStream());return new Blob([plain],{type:"application/octet-stream"})}catch(err){if(err instanceof DecryptionError)throw err;throw new DecryptionError(err instanceof Error?err.message:String(err))}}async createEncryptionStream(pass){if(pass===null)throw new EncryptionError("Password can't be null");let secret={value:pass};this.log.log(2,"Deriving key for stream encryption");let salt=this.genSalt();await this.deriveKey(secret,salt),zeroizeString(secret),pass=null;let header=encodeHeader(this.v.id,this.difficulty,this.saltStrength,salt,this.stream.getEngine());this.stream.getEngine().setPaddingAADMode("forbid");let tf=this.stream.encryptionStream();return{header,writable:tf.writable,readable:tf.readable}}async createDecryptionStream(pass){if(pass===null)throw new EncryptionError("Password can't be null");let provider=this.provider,secret={value:pass},buf=new Uint8Array(0),downstream=null,MAX_HEADER_PREFIX=65536,MIN_INFO_BYTES=2,pipeOut=async(readable,ctl)=>{let rd=readable.getReader();while(!0){let{value,done}=await rd.read();if(done)break;ctl.enqueue(value)}};return new TransformStream({transform:async(chunk,ctl)=>{if(!downstream){let tail=new Uint8Array(0);if(chunk&&chunk.byteLength){let room=Math.max(0,MAX_HEADER_PREFIX-buf.byteLength),head=room?chunk.subarray(0,room):new Uint8Array(0);if(tail=chunk.subarray(head.byteLength),head.byteLength){let nxt=new Uint8Array(buf.byteLength+head.byteLength);nxt.set(buf),nxt.set(head,buf.byteLength),buf=nxt}}if(buf.byteLength<MIN_INFO_BYTES)return;let info=buf[1],scheme=info>>5,saltStrength=info>>2&1?"high":"low",hdrLen=0;try{hdrLen=2+SchemeRegistry.get(scheme).saltLengths[saltStrength]}catch(e){zeroizeString(secret),ctl.error(new HeaderDecodeError(e instanceof Error?e.message:String(e)));return}if(buf.byteLength<hdrLen){if(buf.byteLength>=MAX_HEADER_PREFIX)zeroizeString(secret),ctl.error(new InvalidHeaderError(`Header not found within ${MAX_HEADER_PREFIX} bytes`));return}let headerBytes=buf.subarray(0,hdrLen),parsed;try{parsed=decodeHeader(headerBytes)}catch(err){zeroizeString(secret),ctl.error(err instanceof Error?err:new HeaderDecodeError("Invalid header"));return}let engine=EngineManager.getEngine(provider,parsed.scheme);try{await EngineManager.deriveKey(engine,secret,parsed.salt,parsed.difficulty)}finally{zeroizeString(secret),pass=null}decodeHeader(headerBytes,engine.cipher),engine.cipher.setPaddingAADMode("forbid"),engine.cipher.setLegacyAADFallback({enabled:!0,policy:"auto",tryEmptyAAD:this.acceptUnauthenticatedHeader?!0:!1}),downstream=new DecryptTransform(engine.cipher,engine.chunkSize).toTransformStream(),pipeOut(downstream.readable,ctl).catch((err)=>ctl.error(err));let remainder=buf.subarray(hdrLen);if(buf=new Uint8Array(0),remainder.byteLength||tail.byteLength){let w=downstream.writable.getWriter();if(remainder.byteLength)await w.write(remainder);if(tail.byteLength)await w.write(tail);w.releaseLock()}return}let writer=downstream.writable.getWriter();await writer.write(chunk),writer.releaseLock()},flush:async()=>{if(!downstream)throw zeroizeString(secret),new InvalidHeaderError("Header not found before end of stream");let writer=downstream.writable.getWriter();await writer.close(),writer.releaseLock()}})}generateFakeData(payloadLength=0,usePadding=!1){if(!Number.isInteger(payloadLength)||payloadLength<0)throw RangeError("payloadLength must be a non-negative integer.");let salt=this.genSalt(),header=encodeHeader(this.v.id,this.difficulty,this.saltStrength,salt,this.cipher),tailLen=payloadLength;if(usePadding){let atLeastMin=Math.max(16,tailLen);tailLen=Math.ceil(atLeastMin/8)*8}let tail=tailLen>0?this.provider.getRandomValues(new Uint8Array(tailLen)):new Uint8Array(0);return concat(header,tail)}async deriveKey(secret,salt,diff=this.difficulty){let start=performance.now();try{let key=await this.kdf.derive(secret.value,salt,diff,this.provider);zeroizeString(secret),await this.cipher.setKey(key),this.log.log(3,`Key derivation completed in ${(performance.now()-start).toFixed(1)} ms`)}catch(err){throw new KeyDerivationError(err instanceof Error?err.message:String(err))}}genSalt(strength=this.saltStrength){let len=this.v.saltLengths[strength];return this.provider.getRandomValues(new Uint8Array(len))}static async peekHeader(input){let buf=await this.readAsUint8(input);if(buf.length<2)throw new InvalidHeaderError("Input too short");let{headerLen}=decodeHeader(buf.length>=32?buf:buf.slice());if(buf.length<headerLen)throw new InvalidHeaderError("Incomplete header");return buf.slice(0,headerLen)}static async readAsUint8(input){if(typeof input==="string")return base64Decode(input);if(input instanceof Uint8Array)return input;if(input instanceof Blob){let need=Math.max(32,Math.min(256,input.size)),slice=input.slice(0,need);return new Uint8Array(await slice.arrayBuffer())}throw new HeaderDecodeError("Unsupported input type")}}var browserProvider={subtle:globalThis.crypto.subtle,getRandomValues(buf){return globalThis.crypto.getRandomValues(buf)},isNode:!1};function createCryptit(cfg){return new Cryptit(browserProvider,cfg)}export{createCryptit,Cryptit,ConvertibleOutput,ConvertibleInput};

//# debugId=4DE72C20CADCABB564756E2164756E21
